{
  "firecrawl": {
    "name": "firecrawl",
    "display_name": "Firecrawl",
    "description": "Advanced web scraping with JavaScript rendering, PDF support, and smart rate limiting",
    "repository": {
      "type": "git",
      "url": "https://github.com/mendableai/firecrawl-mcp-server"
    },
    "homepage": "https://github.com/mendableai/firecrawl-mcp-server",
    "author": {
      "name": "mendableai"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "firecrawl",
      "scraping",
      "web",
      "api",
      "automation"
    ],
    "examples": [
      {
        "title": "Basic Scraping Example",
        "description": "Scrape content from a single URL",
        "prompt": "firecrawl_scrape with url 'https://example.com'"
      },
      {
        "title": "Batch Scraping",
        "description": "Scrape multiple URLs",
        "prompt": "firecrawl_batch_scrape with urls ['https://example1.com', 'https://example2.com']"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "firecrawl-mcp"
        ],
        "env": {
          "FIRECRAWL_API_KEY": "${FIRECRAWL_API_KEY}"
        }
      }
    },
    "arguments": {
      "FIRECRAWL_API_KEY": {
        "description": "Your FireCrawl API key. Required for using the cloud API (default) and optional for self-hosted instances.",
        "required": true,
        "example": "fc-YOUR_API_KEY"
      }
    },
    "tools": [
      {
        "name": "firecrawl_scrape",
        "description": "Scrape a single webpage with advanced options for content extraction. Supports various formats including markdown, HTML, and screenshots. Can execute custom actions like clicking or scrolling before scraping.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to scrape"
            },
            "formats": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "markdown",
                  "html",
                  "rawHtml",
                  "screenshot",
                  "links",
                  "screenshot@fullPage",
                  "extract"
                ]
              },
              "description": "Content formats to extract (default: ['markdown'])"
            },
            "onlyMainContent": {
              "type": "boolean",
              "description": "Extract only the main content, filtering out navigation, footers, etc."
            },
            "includeTags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "HTML tags to specifically include in extraction"
            },
            "excludeTags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "HTML tags to exclude from extraction"
            },
            "waitFor": {
              "type": "number",
              "description": "Time in milliseconds to wait for dynamic content to load"
            },
            "timeout": {
              "type": "number",
              "description": "Maximum time in milliseconds to wait for the page to load"
            },
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "wait",
                      "click",
                      "screenshot",
                      "write",
                      "press",
                      "scroll",
                      "scrape",
                      "executeJavascript"
                    ],
                    "description": "Type of action to perform"
                  },
                  "selector": {
                    "type": "string",
                    "description": "CSS selector for the target element"
                  },
                  "milliseconds": {
                    "type": "number",
                    "description": "Time to wait in milliseconds (for wait action)"
                  },
                  "text": {
                    "type": "string",
                    "description": "Text to write (for write action)"
                  },
                  "key": {
                    "type": "string",
                    "description": "Key to press (for press action)"
                  },
                  "direction": {
                    "type": "string",
                    "enum": [
                      "up",
                      "down"
                    ],
                    "description": "Scroll direction"
                  },
                  "script": {
                    "type": "string",
                    "description": "JavaScript code to execute"
                  },
                  "fullPage": {
                    "type": "boolean",
                    "description": "Take full page screenshot"
                  }
                },
                "required": [
                  "type"
                ]
              },
              "description": "List of actions to perform before scraping"
            },
            "extract": {
              "type": "object",
              "properties": {
                "schema": {
                  "type": "object",
                  "description": "Schema for structured data extraction"
                },
                "systemPrompt": {
                  "type": "string",
                  "description": "System prompt for LLM extraction"
                },
                "prompt": {
                  "type": "string",
                  "description": "User prompt for LLM extraction"
                }
              },
              "description": "Configuration for structured data extraction"
            },
            "mobile": {
              "type": "boolean",
              "description": "Use mobile viewport"
            },
            "skipTlsVerification": {
              "type": "boolean",
              "description": "Skip TLS certificate verification"
            },
            "removeBase64Images": {
              "type": "boolean",
              "description": "Remove base64 encoded images from output"
            },
            "location": {
              "type": "object",
              "properties": {
                "country": {
                  "type": "string",
                  "description": "Country code for geolocation"
                },
                "languages": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Language codes for content"
                }
              },
              "description": "Location settings for scraping"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_map",
        "description": "Discover URLs from a starting point. Can use both sitemap.xml and HTML link discovery.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Starting URL for URL discovery"
            },
            "search": {
              "type": "string",
              "description": "Optional search term to filter URLs"
            },
            "ignoreSitemap": {
              "type": "boolean",
              "description": "Skip sitemap.xml discovery and only use HTML links"
            },
            "sitemapOnly": {
              "type": "boolean",
              "description": "Only use sitemap.xml for discovery, ignore HTML links"
            },
            "includeSubdomains": {
              "type": "boolean",
              "description": "Include URLs from subdomains in results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of URLs to return"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_crawl",
        "description": "Start an asynchronous crawl of multiple pages from a starting URL. Supports depth control, path filtering, and webhook notifications.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Starting URL for the crawl"
            },
            "excludePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "URL paths to exclude from crawling"
            },
            "includePaths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Only crawl these URL paths"
            },
            "maxDepth": {
              "type": "number",
              "description": "Maximum link depth to crawl"
            },
            "ignoreSitemap": {
              "type": "boolean",
              "description": "Skip sitemap.xml discovery"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of pages to crawl"
            },
            "allowBackwardLinks": {
              "type": "boolean",
              "description": "Allow crawling links that point to parent directories"
            },
            "allowExternalLinks": {
              "type": "boolean",
              "description": "Allow crawling links to external domains"
            },
            "webhook": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Webhook URL to notify when crawl is complete"
                },
                {
                  "type": "object",
                  "properties": {
                    "url": {
                      "type": "string",
                      "description": "Webhook URL"
                    },
                    "headers": {
                      "type": "object",
                      "description": "Custom headers for webhook requests"
                    }
                  },
                  "required": [
                    "url"
                  ]
                }
              ]
            },
            "deduplicateSimilarURLs": {
              "type": "boolean",
              "description": "Remove similar URLs during crawl"
            },
            "ignoreQueryParameters": {
              "type": "boolean",
              "description": "Ignore query parameters when comparing URLs"
            },
            "scrapeOptions": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml",
                      "screenshot",
                      "links",
                      "screenshot@fullPage",
                      "extract"
                    ]
                  }
                },
                "onlyMainContent": {
                  "type": "boolean"
                },
                "includeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "excludeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "waitFor": {
                  "type": "number"
                }
              },
              "description": "Options for scraping each page"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "firecrawl_batch_scrape",
        "description": "Scrape multiple URLs in batch mode. Returns a job ID that can be used to check status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to scrape"
            },
            "options": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml",
                      "screenshot",
                      "links",
                      "screenshot@fullPage",
                      "extract"
                    ]
                  }
                },
                "onlyMainContent": {
                  "type": "boolean"
                },
                "includeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "excludeTags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "waitFor": {
                  "type": "number"
                }
              }
            }
          },
          "required": [
            "urls"
          ]
        }
      },
      {
        "name": "firecrawl_check_batch_status",
        "description": "Check the status of a batch scraping job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Batch job ID to check"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "firecrawl_check_crawl_status",
        "description": "Check the status of a crawl job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Crawl job ID to check"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "firecrawl_search",
        "description": "Search and retrieve content from web pages with optional scraping. Returns SERP results by default (url, title, description) or full page content when scrapeOptions are provided.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query string"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 5)"
            },
            "lang": {
              "type": "string",
              "description": "Language code for search results (default: en)"
            },
            "country": {
              "type": "string",
              "description": "Country code for search results (default: us)"
            },
            "tbs": {
              "type": "string",
              "description": "Time-based search filter"
            },
            "filter": {
              "type": "string",
              "description": "Search filter"
            },
            "location": {
              "type": "object",
              "properties": {
                "country": {
                  "type": "string",
                  "description": "Country code for geolocation"
                },
                "languages": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Language codes for content"
                }
              },
              "description": "Location settings for search"
            },
            "scrapeOptions": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "enum": [
                      "markdown",
                      "html",
                      "rawHtml"
                    ]
                  },
                  "description": "Content formats to extract from search results"
                },
                "onlyMainContent": {
                  "type": "boolean",
                  "description": "Extract only the main content from results"
                },
                "waitFor": {
                  "type": "number",
                  "description": "Time in milliseconds to wait for dynamic content"
                }
              },
              "description": "Options for scraping search results"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "firecrawl_extract",
        "description": "Extract structured information from web pages using LLM. Supports both cloud AI and self-hosted LLM extraction.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract information from"
            },
            "prompt": {
              "type": "string",
              "description": "Prompt for the LLM extraction"
            },
            "systemPrompt": {
              "type": "string",
              "description": "System prompt for LLM extraction"
            },
            "schema": {
              "type": "object",
              "description": "JSON schema for structured data extraction"
            },
            "allowExternalLinks": {
              "type": "boolean",
              "description": "Allow extraction from external links"
            },
            "enableWebSearch": {
              "type": "boolean",
              "description": "Enable web search for additional context"
            },
            "includeSubdomains": {
              "type": "boolean",
              "description": "Include subdomains in extraction"
            }
          },
          "required": [
            "urls"
          ]
        }
      },
      {
        "name": "firecrawl_deep_research",
        "description": "Conduct deep research on a query using web crawling, search, and AI analysis.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to research"
            },
            "maxDepth": {
              "type": "number",
              "description": "Maximum depth of research iterations (1-10)"
            },
            "timeLimit": {
              "type": "number",
              "description": "Time limit in seconds (30-300)"
            },
            "maxUrls": {
              "type": "number",
              "description": "Maximum number of URLs to analyze (1-1000)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "firecrawl_generate_llmstxt",
        "description": "Generate standardized LLMs.txt file for a given URL, which provides context about how LLMs should interact with the website.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to generate LLMs.txt from"
            },
            "maxUrls": {
              "type": "number",
              "description": "Maximum number of URLs to process (1-100, default: 10)"
            },
            "showFullText": {
              "type": "boolean",
              "description": "Whether to show the full LLMs-full.txt in the response"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  "rabbitmq": {
    "name": "rabbitmq",
    "display_name": "RabbitMQ",
    "description": "The MCP server that interacts with RabbitMQ to publish and consume messages.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kenliao94/mcp-server-rabbitmq"
    },
    "homepage": "https://github.com/kenliao94/mcp-server-rabbitmq",
    "author": {
      "name": "kenliao94"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "rabbitmq",
      "server",
      "messaging"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kenliao94/mcp-server-rabbitmq",
          "mcp-server-rabbitmq",
          "--rabbitmq-host",
          "${RABBITMQ_HOST}",
          "--port",
          "${RABBITMQ_PORT}",
          "--username",
          "${RABBITMQ_USERNAME}",
          "--password",
          "${RABBITMQ_PASSWORD}",
          "--use-tls",
          "${USE_TLS}"
        ]
      }
    },
    "examples": [
      {
        "title": "Publish Message",
        "description": "Ask Claude to publish a message to a queue.",
        "prompt": "Please publish a message to the queue."
      }
    ],
    "arguments": {
      "RABBITMQ_HOST": {
        "description": "The hostname of the RabbitMQ server (e.g., test.rabbit.com, localhost).",
        "required": true,
        "example": "test.rabbit.com"
      },
      "RABBITMQ_PORT": {
        "description": "The port number to connect to the RabbitMQ server (e.g., 5672).",
        "required": true,
        "example": "5672"
      },
      "RABBITMQ_USERNAME": {
        "description": "The username to authenticate with the RabbitMQ server.",
        "required": true,
        "example": "guest"
      },
      "RABBITMQ_PASSWORD": {
        "description": "The password for the RabbitMQ username provided.",
        "required": true,
        "example": "guest"
      },
      "USE_TLS": {
        "description": "Set to true if using TLS (AMQPS), otherwise false.",
        "required": false,
        "example": "true or false"
      }
    },
    "tools": [
      {
        "name": "enqueue",
        "description": "Enqueue a message to a queue hosted on RabbitMQ",
        "inputSchema": {
          "properties": {
            "message": {
              "description": "The message to publish",
              "title": "Message",
              "type": "string"
            },
            "queue": {
              "description": "The name of the queue",
              "title": "Queue",
              "type": "string"
            }
          },
          "required": [
            "message",
            "queue"
          ],
          "title": "Enqueue",
          "type": "object"
        }
      },
      {
        "name": "fanout",
        "description": "Publish a message to an exchange with fanout type",
        "inputSchema": {
          "properties": {
            "message": {
              "description": "The message to publish",
              "title": "Message",
              "type": "string"
            },
            "exchange": {
              "description": "The name of the exchange",
              "title": "Exchange",
              "type": "string"
            }
          },
          "required": [
            "message",
            "exchange"
          ],
          "title": "Fanout",
          "type": "object"
        }
      },
      {
        "name": "list_queues",
        "description": "List all the queues in the broker",
        "inputSchema": {
          "properties": {},
          "title": "ListQueues",
          "type": "object"
        }
      },
      {
        "name": "list_exchanges",
        "description": "List all the exchanges in the broker",
        "inputSchema": {
          "properties": {},
          "title": "ListExchanges",
          "type": "object"
        }
      },
      {
        "name": "get_queue_info",
        "description": "Get detailed information about a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to get info about",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "GetQueueInfo",
          "type": "object"
        }
      },
      {
        "name": "delete_queue",
        "description": "Delete a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to delete",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "DeleteQueue",
          "type": "object"
        }
      },
      {
        "name": "purge_queue",
        "description": "Remove all messages from a specific queue",
        "inputSchema": {
          "properties": {
            "queue": {
              "description": "The name of the queue to purge",
              "title": "Queue",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the queue exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "queue"
          ],
          "title": "PurgeQueue",
          "type": "object"
        }
      },
      {
        "name": "delete_exchange",
        "description": "Delete a specific exchange",
        "inputSchema": {
          "properties": {
            "exchange": {
              "description": "The name of the exchange to delete",
              "title": "Exchange",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the exchange exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "exchange"
          ],
          "title": "DeleteExchange",
          "type": "object"
        }
      },
      {
        "name": "get_exchange_info",
        "description": "Get detailed information about a specific exchange",
        "inputSchema": {
          "properties": {
            "exchange": {
              "description": "The name of the exchange to get info about",
              "title": "Exchange",
              "type": "string"
            },
            "vhost": {
              "default": "/",
              "description": "The virtual host where the exchange exists",
              "title": "Vhost",
              "type": "string"
            }
          },
          "required": [
            "exchange"
          ],
          "title": "GetExchangeInfo",
          "type": "object"
        }
      }
    ]
  },
  "aws-cost-explorer": {
    "name": "aws-cost-explorer",
    "display_name": "AWS Cost Explorer",
    "description": "Optimize your AWS spend (including Amazon Bedrock spend) with this MCP server by examining spend across regions, services, instance types and foundation models ([demo video](https://www.youtube.com/watch?v=WuVOmYLRFmI&feature=youtu.be)).",
    "repository": {
      "type": "git",
      "url": "https://github.com/aarora79/aws-cost-explorer-mcp-server"
    },
    "homepage": "https://github.com/aarora79/aws-cost-explorer-mcp-server",
    "author": {
      "name": "aarora79"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Cost Explorer",
      "Amazon Bedrock",
      "AWS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--directory",
          "/path/to/aws-cost-explorer-mcp-server",
          "run",
          "server.py"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}",
          "BEDROCK_LOG_GROUP_NAME": "${BEDROCK_LOG_GROUP_NAME}",
          "MCP_TRANSPORT": "stdio"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID",
          "-e",
          "AWS_SECRET_ACCESS_KEY",
          "-e",
          "AWS_REGION",
          "-e",
          "BEDROCK_LOG_GROUP_NAME",
          "-e",
          "MCP_TRANSPORT",
          "aws-cost-explorer-mcp:latest"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}",
          "BEDROCK_LOG_GROUP_NAME": "${BEDROCK_LOG_GROUP_NAME}",
          "MCP_TRANSPORT": "stdio"
        }
      }
    },
    "examples": [
      {
        "title": "Get EC2 Spending",
        "description": "Retrieve the EC2 spending data for the previous day.",
        "prompt": "What was my EC2 spend yesterday?"
      },
      {
        "title": "Analyze Spending",
        "description": "Analyze spending by region for the past 14 days.",
        "prompt": "Analyze my spending by region for the past 14 days."
      },
      {
        "title": "Show Top Services",
        "description": "Show me my top 5 AWS services by cost for the last month.",
        "prompt": "Show me my top 5 AWS services by cost for the last month."
      }
    ],
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "Your AWS Access Key ID required for authenticating API calls to AWS services.",
        "required": true,
        "example": "AKIAIOSFODNN7EXAMPLE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "Your AWS Secret Access Key required alongside the Access Key ID for authentication.",
        "required": true,
        "example": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      },
      "AWS_REGION": {
        "description": "The AWS region where your resources are located. Examples include 'us-east-1', 'eu-west-1'.",
        "required": true,
        "example": "us-east-1"
      },
      "BEDROCK_LOG_GROUP_NAME": {
        "description": "The name of the CloudWatch log group where Amazon Bedrock model invocation logs are stored.",
        "required": true,
        "example": "my-bedrock-log-group-name"
      }
    }
  },
  "cfbd-api": {
    "name": "cfbd-api",
    "display_name": "College Football Data API",
    "description": "An MCP server for the [College Football Data API](https://collegefootballdata.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/lenwood/cfbd-mcp-server"
    },
    "homepage": "https://github.com/lenwood/cfbd-mcp-server",
    "author": {
      "name": "lenwood"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "football",
      "college",
      "API",
      "statistics"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/lenwood/cfbd-mcp-server",
          "cfbd-mcp-server"
        ],
        "env": {
          "CFB_API_KEY": "${CFB_API_KEY}",
          "PATH": "${PATH}"
        }
      }
    },
    "examples": [
      {
        "title": "Get the largest upset among FCS games during the 2014 season",
        "description": "Query the server for significant game upsets in the 2014 college football season.",
        "prompt": "What was the largest upset among FCS games during the 2014 season?"
      }
    ],
    "arguments": {
      "CFB_API_KEY": {
        "description": "The API key required to authenticate requests to the College Football Data API.",
        "required": true,
        "example": "your_api_key_here"
      },
      "PATH": {
        "description": "Environment variable that specifies the path to the Python executable being used by the server.",
        "required": false,
        "example": "/full/path/to/python"
      }
    },
    "tools": [
      {
        "name": "get-games",
        "description": "Get college football game data. Required: year. Optional: week, season_type, team, conference, category, game_id.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the games"
            },
            "week": {
              "type": "integer",
              "description": "Week of the games"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "category": {
              "type": "string",
              "description": "Category of games"
            },
            "game_id": {
              "type": "integer",
              "description": "ID of the game"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-records",
        "description": "Get college football team record data. Optional: year, team, conference.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the records"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-games-teams",
        "description": "Get college football team game data. Required: year plus at least one of: week, team or conference.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the games"
            },
            "week": {
              "type": "integer",
              "description": "Week of the games"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-plays",
        "description": "Get college football play-by-play data. Required: year AND week. Optional: season_type, team, offense, defense, conference, offense_conference, defense_conference, play_type, classification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the plays"
            },
            "week": {
              "type": "integer",
              "description": "Week of the plays"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "offense": {
              "type": "string",
              "description": "Name of the offense team"
            },
            "defense": {
              "type": "string",
              "description": "Name of the defense team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "offense_conference": {
              "type": "string",
              "description": "Conference of the offense team"
            },
            "defense_conference": {
              "type": "string",
              "description": "Conference of the defense team"
            },
            "play_type": {
              "type": "string",
              "description": "Type of play"
            },
            "classification": {
              "type": "string",
              "description": "Classification of the play"
            }
          },
          "required": [
            "year",
            "week"
          ]
        }
      },
      {
        "name": "get-drives",
        "description": "Get college football drive data. Required: year. Optional: season_type, week, team, offense, defense, conference, offense_conference, defense_conference, classification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the drives"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "week": {
              "type": "integer",
              "description": "Week of the drives"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "offense": {
              "type": "string",
              "description": "Name of the offense team"
            },
            "defense": {
              "type": "string",
              "description": "Name of the defense team"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            },
            "offense_conference": {
              "type": "string",
              "description": "Conference of the offense team"
            },
            "defense_conference": {
              "type": "string",
              "description": "Conference of the defense team"
            },
            "classification": {
              "type": "string",
              "description": "Classification of the drive"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-play-stats",
        "description": "Get college football play statistic data. Optional: year, week, team, game_id, athlete_id, stat_type_id, season_type, conference. At least one parameter is required.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the statistics"
            },
            "week": {
              "type": "integer",
              "description": "Week of the statistics"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "game_id": {
              "type": "integer",
              "description": "ID of the game"
            },
            "athlete_id": {
              "type": "integer",
              "description": "ID of the athlete"
            },
            "stat_type_id": {
              "type": "integer",
              "description": "ID of the statistic type"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            },
            "conference": {
              "type": "string",
              "description": "Name of the conference"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-rankings",
        "description": "Get college football rankings data. Required: year. Optional: week, season_type.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the rankings"
            },
            "week": {
              "type": "integer",
              "description": "Week of the rankings"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            }
          },
          "required": [
            "year"
          ]
        }
      },
      {
        "name": "get-pregame-win-probability",
        "description": "Get college football pregame win probability data. Optional: year, week, team, season_type. At least one parameter is required.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "year": {
              "type": "integer",
              "description": "Year of the probabilities"
            },
            "week": {
              "type": "integer",
              "description": "Week of the probabilities"
            },
            "team": {
              "type": "string",
              "description": "Name of the team"
            },
            "season_type": {
              "type": "string",
              "description": "Type of season (e.g., regular, postseason)"
            }
          },
          "required": []
        }
      },
      {
        "name": "get-advanced-box-score",
        "description": "Get advanced box score data for college football games. Required: gameId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "gameId": {
              "type": "integer",
              "description": "ID of the game"
            }
          },
          "required": [
            "gameId"
          ]
        }
      }
    ]
  },
  "redis": {
    "name": "redis",
    "display_name": "Redis",
    "description": "MCP server to interact with Redis Server, AWS Memory DB, etc for caching or other use-cases where in-memory and key-value based storage is appropriate",
    "repository": {
      "type": "git",
      "url": "https://github.com/prajwalnayak7/mcp-server-redis"
    },
    "homepage": "https://github.com/prajwalnayak7/mcp-server-redis",
    "author": {
      "name": "prajwalnayak7"
    },
    "license": "MIT",
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/prajwalnayak7/mcp-server-redis",
          "src/server.py"
        ]
      }
    },
    "examples": [
      {
        "title": "Check Redis Connection Status",
        "description": "User requests the current Redis connection status.",
        "prompt": "What's the current Redis connection status?"
      },
      {
        "title": "Store Name in Redis",
        "description": "User wants to store their name in Redis.",
        "prompt": "Can you store my name \"Alice\" in Redis?"
      },
      {
        "title": "Verify Stored Name in Redis",
        "description": "User wants to verify the value stored in Redis.",
        "prompt": "Yes please verify it"
      }
    ],
    "categories": [
      "Databases"
    ]
  },
  "iterm-mcp": {
    "name": "iterm-mcp",
    "display_name": "iTerm",
    "description": "Integration with iTerm2 terminal emulator for macOS, enabling LLMs to execute and monitor terminal commands.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ferrislucas/iterm-mcp"
    },
    "homepage": "https://github.com/ferrislucas/iterm-mcp",
    "author": {
      "name": "ferrislucas"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "iTerm",
      "server",
      "automation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "iterm-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "write_to_terminal",
        "description": "Writes text to the active iTerm terminal - often used to run a command in the terminal",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to run or text to write to the terminal"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "read_terminal_output",
        "description": "Reads the output from the active iTerm terminal",
        "inputSchema": {
          "type": "object",
          "properties": {
            "linesOfOutput": {
              "type": "number",
              "description": "The number of lines of output to read."
            }
          },
          "required": [
            "linesOfOutput"
          ]
        }
      },
      {
        "name": "send_control_character",
        "description": "Sends a control character to the active iTerm terminal (e.g., Control-C, or special sequences like ']' for telnet escape)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "letter": {
              "type": "string",
              "description": "The letter corresponding to the control character (e.g., 'C' for Control-C, ']' for telnet escape)"
            }
          },
          "required": [
            "letter"
          ]
        }
      }
    ]
  },
  "everything-search": {
    "name": "everything-search",
    "display_name": "Everything Search",
    "description": "Fast file searching capabilities across Windows (using [Everything SDK](https://www.voidtools.com/support/everything/sdk/)), macOS (using mdfind command), and Linux (using locate/plocate command).",
    "repository": {
      "type": "git",
      "url": "https://github.com/mamertofabian/mcp-everything-search"
    },
    "homepage": "https://github.com/mamertofabian/mcp-everything-search",
    "author": {
      "name": "mamertofabian"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "search",
      "everything"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-everything-search"
        ],
        "env": {
          "EVERYTHING_SDK_PATH": "${EVERYTHING_SDK_PATH}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_everything_search"
        ],
        "env": {
          "EVERYTHING_SDK_PATH": "${EVERYTHING_SDK_PATH}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Python files",
        "description": "Search for all Python files in the system.",
        "prompt": "{\"query\": \"*.py\",\"max_results\": 50,\"sort_by\": 6}"
      },
      {
        "title": "Search files modified today",
        "description": "Find files with the .py extension that were modified today.",
        "prompt": "{\"query\": \"ext:py datemodified:today\",\"max_results\": 10}"
      }
    ],
    "arguments": {
      "EVERYTHING_SDK_PATH": {
        "description": "Environment variable that specifies the path to the Everything SDK DLL required for the server to function properly.",
        "required": true,
        "example": "path/to/Everything-SDK/dll/Everything64.dll"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Universal file search tool for Darwin\n\nCurrent Implementation:\nUsing mdfind (Spotlight) with native macOS search capabilities\n\nSearch Syntax Guide:\nmacOS Spotlight (mdfind) Search Syntax:\n                \nBasic Usage:\n- Simple text search: Just type the words you're looking for\n- Phrase search: Use quotes (\"exact phrase\")\n- Filename search: -name \"filename\"\n- Directory scope: -onlyin /path/to/dir\n\nSpecial Parameters:\n- Live updates: -live\n- Literal search: -literal\n- Interpreted search: -interpret\n\nMetadata Attributes:\n- kMDItemDisplayName\n- kMDItemTextContent\n- kMDItemKind\n- kMDItemFSSize\n- And many more OS X metadata attributes\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base": {
              "description": "Base search parameters common to all platforms.",
              "properties": {
                "query": {
                  "description": "Search query string. See platform-specific documentation for syntax details.",
                  "title": "Query",
                  "type": "string"
                },
                "max_results": {
                  "default": 100,
                  "description": "Maximum number of results to return (1-1000)",
                  "maximum": 1000,
                  "minimum": 1,
                  "title": "Max Results",
                  "type": "integer"
                }
              },
              "required": [
                "query"
              ],
              "title": "BaseSearchQuery",
              "type": "object"
            },
            "mac_params": {
              "description": "macOS-specific search parameters for mdfind.",
              "properties": {
                "live_updates": {
                  "default": false,
                  "description": "Provide live updates to search results",
                  "title": "Live Updates",
                  "type": "boolean"
                },
                "search_directory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Limit search to specific directory (-onlyin parameter)",
                  "title": "Search Directory"
                },
                "literal_query": {
                  "default": false,
                  "description": "Treat query as literal string without interpretation",
                  "title": "Literal Query",
                  "type": "boolean"
                },
                "interpret_query": {
                  "default": false,
                  "description": "Interpret query as if typed in Spotlight menu",
                  "title": "Interpret Query",
                  "type": "boolean"
                }
              },
              "title": "MacSpecificParams",
              "type": "object"
            }
          },
          "required": [
            "base"
          ]
        }
      }
    ]
  },
  "chroma": {
    "name": "chroma",
    "display_name": "Chroma",
    "description": "Vector database server for semantic document search and metadata filtering, built on Chroma",
    "repository": {
      "type": "git",
      "url": "https://github.com/privetin/chroma"
    },
    "homepage": "https://github.com/privetin/chroma",
    "author": {
      "name": "privetin"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "vector database",
      "semantic search"
    ],
    "examples": [
      {
        "title": "Create a document",
        "description": "Creates a new document with specified content and metadata.",
        "prompt": "create_document({\"document_id\": \"ml_paper1\", \"content\": \"Convolutional neural networks improve image recognition accuracy.\", \"metadata\": {\"year\": 2020, \"field\": \"computer vision\", \"complexity\": \"advanced\"}})"
      },
      {
        "title": "Search similar documents",
        "description": "Finds documents semantically similar to a given query.",
        "prompt": "search_similar({\"query\": \"machine learning models\", \"num_results\": 2, \"metadata_filter\": {\"year\": 2020, \"field\": \"computer vision\"}})"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/privetin/chroma",
          "chroma"
        ]
      }
    },
    "tools": [
      {
        "name": "create_document",
        "description": "Create a new document in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "required": [
            "document_id",
            "content"
          ]
        }
      },
      {
        "name": "read_document",
        "description": "Retrieve a document from the Chroma vector database by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            }
          },
          "required": [
            "document_id"
          ]
        }
      },
      {
        "name": "update_document",
        "description": "Update an existing document in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "required": [
            "document_id",
            "content"
          ]
        }
      },
      {
        "name": "delete_document",
        "description": "Delete a document from the Chroma vector database by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "document_id": {
              "type": "string"
            }
          },
          "required": [
            "document_id"
          ]
        }
      },
      {
        "name": "list_documents",
        "description": "List all documents stored in the Chroma vector database with pagination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10
            },
            "offset": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        }
      },
      {
        "name": "search_similar",
        "description": "Search for semantically similar documents in the Chroma vector database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "num_results": {
              "type": "integer",
              "minimum": 1,
              "default": 5
            },
            "metadata_filter": {
              "type": "object",
              "additionalProperties": true
            },
            "content_filter": {
              "type": "string"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "kubernetes": {
    "name": "kubernetes",
    "display_name": "Kubernetes",
    "description": "Connect to Kubernetes cluster and manage pods, deployments, and services.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Flux159/mcp-server-kubernetes"
    },
    "homepage": "https://github.com/Flux159/mcp-server-kubernetes",
    "author": {
      "name": "Flux159"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "kubernetes",
      "server",
      "management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-server-kubernetes"
        ]
      }
    },
    "tools": [
      {
        "name": "cleanup",
        "description": "Cleanup all managed resources",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_deployment",
        "description": "Create a new Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "template": {
              "type": "string",
              "enum": [
                "ubuntu",
                "nginx",
                "busybox",
                "alpine",
                "custom"
              ]
            },
            "replicas": {
              "type": "number",
              "default": 1
            },
            "ports": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "optional": true
            },
            "customConfig": {
              "type": "object",
              "optional": true,
              "properties": {
                "image": {
                  "type": "string"
                },
                "command": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "args": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ports": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "containerPort": {
                        "type": "number"
                      },
                      "name": {
                        "type": "string"
                      },
                      "protocol": {
                        "type": "string"
                      }
                    }
                  }
                },
                "resources": {
                  "type": "object",
                  "properties": {
                    "limits": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "requests": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "env": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "valueFrom": {
                        "type": "object"
                      }
                    }
                  }
                },
                "volumeMounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "mountPath": {
                        "type": "string"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          },
          "required": [
            "name",
            "namespace",
            "template"
          ]
        }
      },
      {
        "name": "create_namespace",
        "description": "Create a new Kubernetes namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_pod",
        "description": "Create a new Kubernetes pod",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "template": {
              "type": "string",
              "enum": [
                "ubuntu",
                "nginx",
                "busybox",
                "alpine",
                "custom"
              ]
            },
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "customConfig": {
              "type": "object",
              "optional": true,
              "properties": {
                "image": {
                  "type": "string"
                },
                "command": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "args": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ports": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "containerPort": {
                        "type": "number"
                      },
                      "name": {
                        "type": "string"
                      },
                      "protocol": {
                        "type": "string"
                      }
                    }
                  }
                },
                "resources": {
                  "type": "object",
                  "properties": {
                    "limits": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "requests": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                },
                "env": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "valueFrom": {
                        "type": "object"
                      }
                    }
                  }
                },
                "volumeMounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "mountPath": {
                        "type": "string"
                      },
                      "readOnly": {
                        "type": "boolean"
                      }
                    }
                  }
                }
              }
            }
          },
          "required": [
            "name",
            "namespace",
            "template"
          ]
        }
      },
      {
        "name": "create_cronjob",
        "description": "Create a new Kubernetes CronJob",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "schedule": {
              "type": "string"
            },
            "image": {
              "type": "string"
            },
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "optional": true
            },
            "suspend": {
              "type": "boolean",
              "optional": true
            }
          },
          "required": [
            "name",
            "namespace",
            "schedule",
            "image"
          ]
        }
      },
      {
        "name": "delete_pod",
        "description": "Delete a Kubernetes pod",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "ignoreNotFound": {
              "type": "boolean",
              "default": false
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_cronjob",
        "description": "Get detailed information about a Kubernetes CronJob including recent job history",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_pod",
        "description": "Describe a Kubernetes pod (read details like status, containers, etc.)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "describe_deployment",
        "description": "Get details about a Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "explain_resource",
        "description": "Get documentation for a Kubernetes resource or field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resource": {
              "type": "string",
              "description": "Resource name or field path (e.g. 'pods' or 'pods.spec.containers')"
            },
            "apiVersion": {
              "type": "string",
              "description": "API version to use (e.g. 'apps/v1')"
            },
            "recursive": {
              "type": "boolean",
              "description": "Print the fields of fields recursively",
              "default": false
            },
            "output": {
              "type": "string",
              "description": "Output format (plaintext or plaintext-openapiv2)",
              "enum": [
                "plaintext",
                "plaintext-openapiv2"
              ],
              "default": "plaintext"
            }
          },
          "required": [
            "resource"
          ]
        }
      },
      {
        "name": "get_events",
        "description": "Get Kubernetes events from the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "description": "Namespace to get events from. If not specified, gets events from all namespaces"
            },
            "fieldSelector": {
              "type": "string",
              "description": "Field selector to filter events"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_job_logs",
        "description": "Get logs from Pods created by a specific Job",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the Job to get logs from"
            },
            "namespace": {
              "type": "string",
              "default": "default"
            },
            "tail": {
              "type": "number",
              "description": "Number of lines to return from the end of the logs",
              "optional": true
            },
            "timestamps": {
              "type": "boolean",
              "description": "Include timestamps in the logs",
              "optional": true
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "get_logs",
        "description": "Get logs from pods, deployments, jobs, or resources matching a label selector",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourceType": {
              "type": "string",
              "enum": [
                "pod",
                "deployment",
                "job"
              ],
              "description": "Type of resource to get logs from"
            },
            "name": {
              "type": "string",
              "description": "Name of the resource"
            },
            "namespace": {
              "type": "string",
              "description": "Namespace of the resource",
              "default": "default"
            },
            "labelSelector": {
              "type": "string",
              "description": "Label selector to filter resources",
              "optional": true
            },
            "container": {
              "type": "string",
              "description": "Container name (required when pod has multiple containers)",
              "optional": true
            },
            "tail": {
              "type": "number",
              "description": "Number of lines to show from end of logs",
              "optional": true
            },
            "since": {
              "type": "number",
              "description": "Get logs since relative time in seconds",
              "optional": true
            },
            "timestamps": {
              "type": "boolean",
              "description": "Include timestamps in logs",
              "default": false
            }
          },
          "required": [
            "resourceType"
          ]
        }
      },
      {
        "name": "install_helm_chart",
        "description": "Install a Helm chart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "chart": {
              "type": "string",
              "description": "Chart name"
            },
            "repo": {
              "type": "string",
              "description": "Chart repository URL"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            },
            "values": {
              "type": "object",
              "description": "Chart values",
              "additionalProperties": true
            }
          },
          "required": [
            "name",
            "chart",
            "repo",
            "namespace"
          ]
        }
      },
      {
        "name": "list_api_resources",
        "description": "List the API resources available in the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "apiGroup": {
              "type": "string",
              "description": "API group to filter by"
            },
            "namespaced": {
              "type": "boolean",
              "description": "If true, only show namespaced resources"
            },
            "verbs": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of verbs to filter by"
            },
            "output": {
              "type": "string",
              "description": "Output format (wide, name, or no-headers)",
              "enum": [
                "wide",
                "name",
                "no-headers"
              ],
              "default": "wide"
            }
          }
        }
      },
      {
        "name": "list_cronjobs",
        "description": "List CronJobs in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_deployments",
        "description": "List deployments in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_jobs",
        "description": "List Jobs in a namespace, optionally filtered by a CronJob parent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            },
            "cronJobName": {
              "type": "string",
              "description": "Optional: Filter jobs created by a specific CronJob",
              "optional": true
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_namespaces",
        "description": "List all namespaces",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_nodes",
        "description": "List all nodes in the cluster",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_pods",
        "description": "List pods in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "list_services",
        "description": "List services in a namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "namespace": {
              "type": "string",
              "default": "default"
            }
          },
          "required": [
            "namespace"
          ]
        }
      },
      {
        "name": "uninstall_helm_chart",
        "description": "Uninstall a Helm release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            }
          },
          "required": [
            "name",
            "namespace"
          ]
        }
      },
      {
        "name": "upgrade_helm_chart",
        "description": "Upgrade a Helm release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Release name"
            },
            "chart": {
              "type": "string",
              "description": "Chart name"
            },
            "repo": {
              "type": "string",
              "description": "Chart repository URL"
            },
            "namespace": {
              "type": "string",
              "description": "Kubernetes namespace"
            },
            "values": {
              "type": "object",
              "description": "Chart values",
              "additionalProperties": true
            }
          },
          "required": [
            "name",
            "chart",
            "repo",
            "namespace"
          ]
        }
      },
      {
        "name": "port_forward",
        "description": "Forward a local port to a port on a Kubernetes resource",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resourceType": {
              "type": "string"
            },
            "resourceName": {
              "type": "string"
            },
            "localPort": {
              "type": "number"
            },
            "targetPort": {
              "type": "number"
            },
            "namespace": {
              "type": "string"
            }
          },
          "required": [
            "resourceType",
            "resourceName",
            "localPort",
            "targetPort"
          ]
        }
      },
      {
        "name": "stop_port_forward",
        "description": "Stop a port-forward process",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "scale_deployment",
        "description": "Scale a Kubernetes deployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "namespace": {
              "type": "string"
            },
            "replicas": {
              "type": "number"
            }
          },
          "required": [
            "name",
            "namespace",
            "replicas"
          ]
        }
      }
    ]
  },
  "contentful-mcp": {
    "name": "contentful-mcp",
    "display_name": "Contentful Management",
    "description": "Read, update, delete, publish content in your [Contentful](https://contentful.com/) space(s) from this MCP Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ivo-toby/contentful-mcp"
    },
    "homepage": "https://github.com/ivo-toby/contentful-mcp",
    "author": {
      "name": "ivo-toby"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Contentful",
      "Management API",
      "CRUD Operations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ivotoby/contentful-management-mcp-server"
        ],
        "env": {
          "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN": "${CONTENTFUL_MANAGEMENT_ACCESS_TOKEN}"
        }
      }
    },
    "arguments": {
      "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN": {
        "description": "Your Content Management API token for accessing Contentful services.",
        "required": true,
        "example": "<Your CMA token>"
      }
    },
    "tools": [
      {
        "name": "search_entries",
        "description": "Search for entries using query parameters. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "object",
              "description": "Query parameters for searching entries",
              "properties": {
                "content_type": {
                  "type": "string"
                },
                "select": {
                  "type": "string"
                },
                "limit": {
                  "type": "number",
                  "default": 3,
                  "maximum": 3,
                  "description": "Maximum number of items to return (max: 3)"
                },
                "skip": {
                  "type": "number",
                  "default": 0,
                  "description": "Number of items to skip for pagination"
                },
                "order": {
                  "type": "string"
                },
                "query": {
                  "type": "string"
                }
              },
              "required": [
                "limit",
                "skip"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "query",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_entry",
        "description": "Create a new entry in Contentful, before executing this function, you need to know the contentTypeId (not the content type NAME) and the fields of that contentType, you can get the fields definition by using the GET_CONTENT_TYPE tool. ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string",
              "description": "The ID of the content type for the new entry"
            },
            "fields": {
              "type": "object",
              "description": "The fields of the entry"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_entry",
        "description": "Retrieve an existing entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_entry",
        "description": "Update an existing entry, very important: always send all field values and all values related to locales, also the fields values that have not been updated",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "fields": {
              "type": "object"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_entry",
        "description": "Delete an entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_entry",
        "description": "Publish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard publish operation. For multiple entries, it automatically uses bulk publishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to publish (max: 100)"
                }
              ],
              "description": "ID of the entry to publish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_entry",
        "description": "Unpublish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard unpublish operation. For multiple entries, it automatically uses bulk unpublishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to unpublish (max: 100)"
                }
              ],
              "description": "ID of the entry to unpublish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_assets",
        "description": "List assets in a space. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 3,
              "maximum": 3,
              "description": "Maximum number of items to return (max: 3)"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "upload_asset",
        "description": "Upload a new asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "file": {
              "type": "object",
              "properties": {
                "upload": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              },
              "required": [
                "upload",
                "fileName",
                "contentType"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "title",
            "file",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_asset",
        "description": "Retrieve an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_asset",
        "description": "Update an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "file": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              },
              "required": [
                "url",
                "fileName",
                "contentType"
              ]
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_asset",
        "description": "Delete an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_asset",
        "description": "Publish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_asset",
        "description": "Unpublish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_content_types",
        "description": "List content types in a space. Returns a maximum of 10 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 20,
              "description": "Maximum number of items to return (max: 3)"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_content_type",
        "description": "Get details of a specific content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_content_type",
        "description": "Create a new content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "description": "Array of field definitions for the content type",
              "items": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "The ID of the field"
                  },
                  "name": {
                    "type": "string",
                    "description": "Display name of the field"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the field (Text, Number, Date, Location, Media, Boolean, JSON, Link, Array, etc)",
                    "enum": [
                      "Symbol",
                      "Text",
                      "Integer",
                      "Number",
                      "Date",
                      "Location",
                      "Object",
                      "Boolean",
                      "Link",
                      "Array"
                    ]
                  },
                  "required": {
                    "type": "boolean",
                    "description": "Whether this field is required",
                    "default": false
                  },
                  "localized": {
                    "type": "boolean",
                    "description": "Whether this field can be localized",
                    "default": false
                  },
                  "linkType": {
                    "type": "string",
                    "description": "Required for Link fields. Specifies what type of resource this field links to",
                    "enum": [
                      "Entry",
                      "Asset"
                    ]
                  },
                  "items": {
                    "type": "object",
                    "description": "Required for Array fields. Specifies the type of items in the array",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "Symbol",
                          "Link"
                        ]
                      },
                      "linkType": {
                        "type": "string",
                        "enum": [
                          "Entry",
                          "Asset"
                        ]
                      },
                      "validations": {
                        "type": "array",
                        "items": {
                          "type": "object"
                        }
                      }
                    }
                  },
                  "validations": {
                    "type": "array",
                    "description": "Array of validation rules for the field",
                    "items": {
                      "type": "object"
                    }
                  }
                },
                "required": [
                  "id",
                  "name",
                  "type"
                ]
              }
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "name",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_content_type",
        "description": "Update an existing content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "object"
              }
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "name",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_content_type",
        "description": "Delete a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_content_type",
        "description": "Publish a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contentTypeId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_spaces",
        "description": "List all available spaces",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_space",
        "description": "Get details of a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "list_environments",
        "description": "List all environments in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "create_environment",
        "description": "Create a new environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId",
            "name"
          ]
        }
      },
      {
        "name": "delete_environment",
        "description": "Delete an environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "bulk_validate",
        "description": "Validate multiple entries at once",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryIds": {
              "type": "array",
              "description": "Array of entry IDs to validate",
              "items": {
                "type": "string"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "entryIds",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_ai_actions",
        "description": "List all AI Actions in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of AI Actions to return"
            },
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of AI Actions to skip for pagination"
            },
            "status": {
              "type": "string",
              "enum": [
                "all",
                "published"
              ],
              "description": "Filter AI Actions by status"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action",
        "description": "Get a specific AI Action by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to retrieve"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_ai_action",
        "description": "Create a new AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "description": "The instruction object containing the template and variables",
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "description": "Array of variable definitions",
                  "items": {
                    "type": "object"
                  }
                },
                "conditions": {
                  "type": "array",
                  "description": "Optional array of conditions for the template",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template",
                "variables"
              ]
            },
            "configuration": {
              "type": "object",
              "description": "The model configuration",
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "description": "The temperature setting for the model (0.0 to 1.0)",
                  "minimum": 0,
                  "maximum": 1
                }
              },
              "required": [
                "modelType",
                "modelTemperature"
              ]
            },
            "testCases": {
              "type": "array",
              "description": "Optional array of test cases for the AI Action",
              "items": {
                "type": "object"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_ai_action",
        "description": "Update an existing AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to update"
            },
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "description": "The instruction object containing the template and variables",
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "description": "Array of variable definitions",
                  "items": {
                    "type": "object"
                  }
                },
                "conditions": {
                  "type": "array",
                  "description": "Optional array of conditions for the template",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template",
                "variables"
              ]
            },
            "configuration": {
              "type": "object",
              "description": "The model configuration",
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "description": "The temperature setting for the model (0.0 to 1.0)",
                  "minimum": 0,
                  "maximum": 1
                }
              },
              "required": [
                "modelType",
                "modelTemperature"
              ]
            },
            "testCases": {
              "type": "array",
              "description": "Optional array of test cases for the AI Action",
              "items": {
                "type": "object"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_ai_action",
        "description": "Delete an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to delete"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_ai_action",
        "description": "Publish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to publish"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_ai_action",
        "description": "Unpublish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to unpublish"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "invoke_ai_action",
        "description": "Invoke an AI Action with variables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to invoke"
            },
            "variables": {
              "type": "object",
              "description": "Key-value pairs of variable IDs and their values",
              "additionalProperties": {
                "type": "string"
              }
            },
            "rawVariables": {
              "type": "array",
              "description": "Array of raw variable objects (for complex variable types like references)",
              "items": {
                "type": "object"
              }
            },
            "outputFormat": {
              "type": "string",
              "enum": [
                "Markdown",
                "RichText",
                "PlainText"
              ],
              "default": "Markdown",
              "description": "The format of the output content"
            },
            "waitForCompletion": {
              "type": "boolean",
              "default": true,
              "description": "Whether to wait for the AI Action to complete before returning"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action_invocation",
        "description": "Get the result of a previous AI Action invocation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action"
            },
            "invocationId": {
              "type": "string",
              "description": "The ID of the specific invocation to retrieve"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "description": "The ID of the environment within the space, by default this will be called Master",
              "default": "master"
            }
          },
          "required": [
            "aiActionId",
            "invocationId",
            "spaceId",
            "environmentId"
          ]
        }
      }
    ]
  },
  "deepseek-mcp-server": {
    "name": "deepseek-mcp-server",
    "display_name": "DeepSeek",
    "description": "Model Context Protocol server integrating DeepSeek's advanced language models, in addition to [other useful API endpoints](https://github.com/DMontgomery40/deepseek-mcp-server?tab=readme-ov-file#features)",
    "repository": {
      "type": "git",
      "url": "https://github.com/DMontgomery40/deepseek-mcp-server"
    },
    "homepage": "https://github.com/DMontgomery40/deepseek-mcp-server",
    "author": {
      "name": "DMontgomery40"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "DeepSeek",
      "API",
      "Language Model"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deepseek-mcp-server"
        ],
        "env": {
          "DEEPSEEK_API_KEY": "${DEEPSEEK_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEEPSEEK_API_KEY": {
        "description": "An API key required to authenticate requests to the DeepSeek API.",
        "required": true,
        "example": "your-api-key"
      }
    },
    "tools": [
      {
        "name": "chat_completion",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string"
            },
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "role": {
                    "type": "string",
                    "enum": [
                      "system",
                      "user",
                      "assistant"
                    ]
                  },
                  "content": {
                    "type": "string"
                  }
                },
                "required": [
                  "role",
                  "content"
                ],
                "additionalProperties": false
              }
            },
            "model": {
              "type": "string",
              "default": "deepseek-reasoner"
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "default": 0.7
            },
            "max_tokens": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "default": 8000
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 1
            },
            "frequency_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0.1
            },
            "presence_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0
            }
          }
        }
      },
      {
        "name": "multi_turn_chat",
        "inputSchema": {
          "type": "object",
          "properties": {
            "messages": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "role": {
                        "type": "string",
                        "enum": [
                          "system",
                          "user",
                          "assistant"
                        ]
                      },
                      "content": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "const": "text"
                          },
                          "text": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "type",
                          "text"
                        ],
                        "additionalProperties": false
                      }
                    },
                    "required": [
                      "role",
                      "content"
                    ],
                    "additionalProperties": false
                  }
                }
              ]
            },
            "model": {
              "type": "string",
              "default": "deepseek-chat"
            },
            "temperature": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "default": 0.7
            },
            "max_tokens": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "default": 8000
            },
            "top_p": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "default": 1
            },
            "frequency_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0.1
            },
            "presence_penalty": {
              "type": "number",
              "minimum": -2,
              "maximum": 2,
              "default": 0
            }
          },
          "required": [
            "messages"
          ]
        }
      }
    ]
  },
  "gitlab": {
    "name": "gitlab",
    "display_name": "GitLab",
    "description": "GitLab API, enabling project management",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/gitlab",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GitLab",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-gitlab"
        ],
        "env": {
          "GITLAB_PERSONAL_ACCESS_TOKEN": "${GITLAB_PERSONAL_ACCESS_TOKEN}",
          "GITLAB_API_URL": "${GITLAB_API_URL}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-e",
          "GITLAB_PERSONAL_ACCESS_TOKEN",
          "-e",
          "GITLAB_API_URL",
          "mcp/gitlab"
        ],
        "env": {
          "GITLAB_PERSONAL_ACCESS_TOKEN": "${GITLAB_PERSONAL_ACCESS_TOKEN}",
          "GITLAB_API_URL": "${GITLAB_API_URL}"
        }
      }
    },
    "arguments": {
      "GITLAB_PERSONAL_ACCESS_TOKEN": {
        "description": "Your GitLab personal access token",
        "required": true
      },
      "GITLAB_API_URL": {
        "description": "Base URL for GitLab API",
        "required": false,
        "example": "https://gitlab.com/api/v4"
      }
    },
    "tools": [
      {
        "name": "create_or_update_file",
        "description": "Create or update a single file in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "file_path": {
              "type": "string",
              "description": "Path where to create/update the file"
            },
            "content": {
              "type": "string",
              "description": "Content of the file"
            },
            "commit_message": {
              "type": "string",
              "description": "Commit message"
            },
            "branch": {
              "type": "string",
              "description": "Branch to create/update the file in"
            },
            "previous_path": {
              "type": "string",
              "description": "Path of the file to move/rename"
            }
          },
          "required": [
            "project_id",
            "file_path",
            "content",
            "commit_message",
            "branch"
          ]
        }
      },
      {
        "name": "search_repositories",
        "description": "Search for GitLab projects",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "Search query"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination (default: 1)"
            },
            "per_page": {
              "type": "number",
              "description": "Number of results per page (default: 20)"
            }
          },
          "required": [
            "search"
          ]
        }
      },
      {
        "name": "create_repository",
        "description": "Create a new GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Repository name"
            },
            "description": {
              "type": "string",
              "description": "Repository description"
            },
            "visibility": {
              "type": "string",
              "enum": [
                "private",
                "internal",
                "public"
              ],
              "description": "Repository visibility level"
            },
            "initialize_with_readme": {
              "type": "boolean",
              "description": "Initialize with README.md"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_file_contents",
        "description": "Get the contents of a file or directory from a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "file_path": {
              "type": "string",
              "description": "Path to the file or directory"
            },
            "ref": {
              "type": "string",
              "description": "Branch/tag/commit to get contents from"
            }
          },
          "required": [
            "project_id",
            "file_path"
          ]
        }
      },
      {
        "name": "push_files",
        "description": "Push multiple files to a GitLab project in a single commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "branch": {
              "type": "string",
              "description": "Branch to push to"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "file_path": {
                    "type": "string",
                    "description": "Path where to create the file"
                  },
                  "content": {
                    "type": "string",
                    "description": "Content of the file"
                  }
                },
                "required": [
                  "file_path",
                  "content"
                ],
                "additionalProperties": false
              },
              "description": "Array of files to push"
            },
            "commit_message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "project_id",
            "branch",
            "files",
            "commit_message"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "Create a new issue in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "description": {
              "type": "string",
              "description": "Issue description"
            },
            "assignee_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of user IDs to assign"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names"
            },
            "milestone_id": {
              "type": "number",
              "description": "Milestone ID to assign"
            }
          },
          "required": [
            "project_id",
            "title"
          ]
        }
      },
      {
        "name": "create_merge_request",
        "description": "Create a new merge request in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "title": {
              "type": "string",
              "description": "Merge request title"
            },
            "description": {
              "type": "string",
              "description": "Merge request description"
            },
            "source_branch": {
              "type": "string",
              "description": "Branch containing changes"
            },
            "target_branch": {
              "type": "string",
              "description": "Branch to merge into"
            },
            "draft": {
              "type": "boolean",
              "description": "Create as draft merge request"
            },
            "allow_collaboration": {
              "type": "boolean",
              "description": "Allow commits from upstream members"
            }
          },
          "required": [
            "project_id",
            "title",
            "source_branch",
            "target_branch"
          ]
        }
      },
      {
        "name": "fork_repository",
        "description": "Fork a GitLab project to your account or specified namespace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "namespace": {
              "type": "string",
              "description": "Namespace to fork to (full path)"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "create_branch",
        "description": "Create a new branch in a GitLab project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID or URL-encoded path"
            },
            "branch": {
              "type": "string",
              "description": "Name for the new branch"
            },
            "ref": {
              "type": "string",
              "description": "Source branch/commit for new branch"
            }
          },
          "required": [
            "project_id",
            "branch"
          ]
        }
      }
    ]
  },
  "dune-analytics-mcp": {
    "name": "dune-analytics-mcp",
    "display_name": "Dune Analytics",
    "description": "A mcp server that bridges Dune Analytics data to AI agents.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/dune-analytics-mcp"
    },
    "homepage": "https://github.com/kukapay/dune-analytics-mcp",
    "author": {
      "name": "Kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Dune",
      "Analytics",
      "AI agents"
    ],
    "examples": [
      {
        "title": "Get Latest Result",
        "description": "Retrieves the latest results of a specified Dune query.",
        "prompt": "get_latest_result(query_id=4853921)"
      },
      {
        "title": "Run Query",
        "description": "Executes a Dune query and returns the results.",
        "prompt": "run_query(query_id=1215383)"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/dune-analytics-mcp",
          "main.py"
        ],
        "env": {
          "DUNE_API_KEY": "${DUNE_API_KEY}"
        }
      }
    },
    "arguments": {
      "DUNE_API_KEY": {
        "description": "A valid Dune Analytics API key obtained from Dune Analytics for authentication and data access.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "whois-mcp": {
    "name": "whois-mcp",
    "display_name": "Whois Lookup",
    "description": "MCP server that performs whois lookup against domain, IP, ASN and TLD.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bharathvaj-ganesan/whois-mcp"
    },
    "homepage": "https://github.com/bharathvaj-ganesan/whois-mcp",
    "author": {
      "name": "bharathvaj-ganesan"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "whois",
      "domain",
      "tools"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@bharathvaj/whois-mcp@latest"
        ]
      }
    },
    "examples": [
      {
        "title": "Look up WHOIS information",
        "description": "Using the Whois MCP to find out domain details.",
        "prompt": "What can you tell me about example.com?"
      }
    ],
    "tools": [
      {
        "name": "whois_domain",
        "description": "Looksup whois information about the domain",
        "inputSchema": {
          "type": "object",
          "properties": {
            "domain": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "domain"
          ]
        }
      },
      {
        "name": "whois_tld",
        "description": "Looksup whois information about the Top Level Domain (TLD)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tld": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "tld"
          ]
        }
      },
      {
        "name": "whois_ip",
        "description": "Looksup whois information about the IP",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "anyOf": [
                {
                  "format": "ipv4"
                },
                {
                  "format": "ipv6"
                }
              ]
            }
          },
          "required": [
            "ip"
          ]
        }
      },
      {
        "name": "whois_as",
        "description": "Looksup whois information about the Autonomous System Number (ASN)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "asn": {
              "type": "string",
              "pattern": "^AS\\d+$"
            }
          },
          "required": [
            "asn"
          ]
        }
      }
    ]
  },
  "deepseek-thinker-mcp": {
    "name": "deepseek-thinker-mcp",
    "display_name": "Deepseek Thinker",
    "description": "A MCP (Model Context Protocol) provider Deepseek reasoning content to MCP-enabled AI Clients, like Claude Desktop. Supports access to Deepseek's thought processes from the Deepseek API service or from a local Ollama server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ruixingshi/deepseek-thinker-mcp"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Deepseek",
      "AI Clients",
      "Reasoning"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deepseek-thinker-mcp"
        ],
        "env": {
          "API_KEY": "${API_KEY}",
          "BASE_URL": "${BASE_URL}"
        }
      }
    },
    "author": {
      "name": "ruixingshi"
    },
    "homepage": "https://github.com/ruixingshi/deepseek-thinker-mcp",
    "arguments": {
      "API_KEY": {
        "description": "Your OpenAI API Key for authentication with the OpenAI services.",
        "required": true,
        "example": "sk-xxxxxxxxxx"
      },
      "BASE_URL": {
        "description": "The base URL for the OpenAI API that you are connecting to.",
        "required": true,
        "example": "https://api.openai.com/v1"
      }
    },
    "tools": [
      {
        "name": "get-deepseek-thinker",
        "description": "think with deepseek",
        "inputSchema": {
          "type": "object",
          "properties": {
            "originPrompt": {
              "type": "string",
              "description": "user's original prompt"
            }
          },
          "required": [
            "originPrompt"
          ]
        }
      }
    ]
  },
  "git": {
    "name": "git",
    "display_name": "git",
    "description": "Tools to read, search, and manipulate Git repositories",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/git",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Git",
      "Server",
      "Automation"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-git",
          "--repository",
          "${GIT_REPO_PATH}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "--mount",
          "type=bind,src=${GIT_REPO_PATH},dst=${GIT_REPO_PATH}",
          "mcp/git"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_git",
          "--repository",
          "${GIT_REPO_PATH}"
        ]
      }
    },
    "arguments": {
      "GIT_REPO_PATH": {
        "description": "The path to the Git repository that the mcp-server-git will interact with.",
        "required": true,
        "example": "/path/to/git/repo"
      }
    },
    "tools": [
      {
        "name": "git_status",
        "description": "Shows the working tree status",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitStatus",
          "type": "object"
        }
      },
      {
        "name": "git_diff_unstaged",
        "description": "Shows changes in the working directory that are not yet staged",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitDiffUnstaged",
          "type": "object"
        }
      },
      {
        "name": "git_diff_staged",
        "description": "Shows changes that are staged for commit",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitDiffStaged",
          "type": "object"
        }
      },
      {
        "name": "git_diff",
        "description": "Shows differences between branches or commits",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "target": {
              "title": "Target",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "target"
          ],
          "title": "GitDiff",
          "type": "object"
        }
      },
      {
        "name": "git_commit",
        "description": "Records changes to the repository",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "message": {
              "title": "Message",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "message"
          ],
          "title": "GitCommit",
          "type": "object"
        }
      },
      {
        "name": "git_add",
        "description": "Adds file contents to the staging area",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "files": {
              "items": {
                "type": "string"
              },
              "title": "Files",
              "type": "array"
            }
          },
          "required": [
            "repo_path",
            "files"
          ],
          "title": "GitAdd",
          "type": "object"
        }
      },
      {
        "name": "git_reset",
        "description": "Unstages all staged changes",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitReset",
          "type": "object"
        }
      },
      {
        "name": "git_log",
        "description": "Shows the commit logs",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "max_count": {
              "default": 10,
              "title": "Max Count",
              "type": "integer"
            }
          },
          "required": [
            "repo_path"
          ],
          "title": "GitLog",
          "type": "object"
        }
      },
      {
        "name": "git_create_branch",
        "description": "Creates a new branch from an optional base branch",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "branch_name": {
              "title": "Branch Name",
              "type": "string"
            },
            "base_branch": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Base Branch"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ],
          "title": "GitCreateBranch",
          "type": "object"
        }
      },
      {
        "name": "git_checkout",
        "description": "Switches branches",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "branch_name": {
              "title": "Branch Name",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ],
          "title": "GitCheckout",
          "type": "object"
        }
      },
      {
        "name": "git_show",
        "description": "Shows the contents of a commit",
        "inputSchema": {
          "properties": {
            "repo_path": {
              "title": "Repo Path",
              "type": "string"
            },
            "revision": {
              "title": "Revision",
              "type": "string"
            }
          },
          "required": [
            "repo_path",
            "revision"
          ],
          "title": "GitShow",
          "type": "object"
        }
      }
    ]
  },
  "code-executor": {
    "name": "code-executor",
    "display_name": "Code Executor",
    "description": "An MCP server that allows LLMs to execute Python code within a specified Conda environment.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bazinga012/mcp_code_executor"
    },
    "homepage": "https://github.com/bazinga012/mcp_code_executor",
    "author": {
      "name": "bazinga012"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Python",
      "Conda",
      "Execution"
    ],
    "examples": [
      {
        "title": "Execute Python Code",
        "description": "An example of executing Python code using MCP Code Executor",
        "prompt": "Please execute the following code: print('Hello, World!')"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/bazinga012/mcp_code_executor"
        ],
        "env": {
          "CODE_STORAGE_DIR": "${CODE_STORAGE_DIR}",
          "CONDA_ENV_NAME": "${CONDA_ENV_NAME}"
        }
      }
    },
    "arguments": {
      "CODE_STORAGE_DIR": {
        "description": "The directory where the generated code will be stored.",
        "required": true,
        "example": "/path/to/code/storage"
      },
      "CONDA_ENV_NAME": {
        "description": "The name of the Conda environment in which the code will be executed.",
        "required": true,
        "example": "your-conda-env"
      }
    },
    "tools": [
      {
        "name": "execute_code",
        "description": "Execute Python code in the specified conda environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Python code to execute"
            },
            "filename": {
              "type": "string",
              "description": "Optional: Name of the file to save the code (default: generated UUID)"
            }
          },
          "required": [
            "code"
          ]
        }
      }
    ]
  },
  "world-bank-data-api": {
    "name": "world-bank-data-api",
    "display_name": "World Bank Data API",
    "description": "A server that fetches data indicators available with the World Bank as part of their data API",
    "repository": {
      "type": "git",
      "url": "https://github.com/anshumax/world_bank_mcp_server"
    },
    "homepage": "https://github.com/anshumax/world_bank_mcp_server",
    "author": {
      "name": "anshumax"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "World Bank",
      "Data",
      "API",
      "Indicators",
      "Analysis"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/anshumax/world_bank_mcp_server",
          "world_bank_mcp_server"
        ]
      }
    },
    "examples": [
      {
        "title": "List Countries",
        "description": "Lists available countries in the World Bank open data API.",
        "prompt": "List all countries available in the World Bank data."
      },
      {
        "title": "List Indicators",
        "description": "Lists available indicators in the World Bank open data API.",
        "prompt": "List all indicators available in the World Bank data."
      },
      {
        "title": "Analyze Indicators",
        "description": "Analyzes specific indicators for a selected country.",
        "prompt": "Analyze the poverty indicators for Kenya."
      }
    ],
    "tools": [
      {
        "name": "get_indicator_for_country",
        "description": "Get values for an indicator for a specific country from the World Bank API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "country_id": {
              "type": "string",
              "description": "The ID of the country for which the indicator is to be queried"
            },
            "indicator_id": {
              "type": "string",
              "description": "The ID of the indicator to be queried"
            }
          },
          "required": [
            "country_id",
            "indicator_id"
          ]
        }
      }
    ]
  },
  "firebase": {
    "name": "firebase",
    "display_name": "Firebase",
    "description": "Server to interact with Firebase services including Firebase Authentication, Firestore, and Firebase Storage.",
    "repository": {
      "type": "git",
      "url": "https://github.com/gannonh/firebase-mcp"
    },
    "homepage": "https://github.com/gannonh/firebase-mcp",
    "author": {
      "name": "gannonh"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Firebase",
      "LLM",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gannonh/firebase-mcp"
        ],
        "env": {
          "SERVICE_ACCOUNT_KEY_PATH": "${SERVICE_ACCOUNT_KEY_PATH}",
          "FIREBASE_STORAGE_BUCKET": "${FIREBASE_STORAGE_BUCKET}"
        }
      }
    },
    "arguments": {
      "SERVICE_ACCOUNT_KEY_PATH": {
        "description": "Path to your Firebase service account key JSON file",
        "required": true,
        "example": "/absolute/path/to/serviceAccountKey.json"
      },
      "FIREBASE_STORAGE_BUCKET": {
        "description": "Bucket name for Firebase Storage",
        "required": false,
        "example": "your-project-id.firebasestorage.app"
      }
    },
    "tools": [
      {
        "name": "firestore_add_document",
        "description": "Add a document to a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "data": {
              "type": "object",
              "description": "Document data"
            }
          },
          "required": [
            "collection",
            "data"
          ]
        }
      },
      {
        "name": "firestore_list_documents",
        "description": "List documents from a Firestore collection with filtering and ordering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "filters": {
              "type": "array",
              "description": "Array of filter conditions",
              "items": {
                "type": "object",
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to filter"
                  },
                  "operator": {
                    "type": "string",
                    "description": "Comparison operator (==, >, <, >=, <=, array-contains, in, array-contains-any)"
                  },
                  "value": {
                    "description": "Value to compare against (use ISO format for dates)"
                  }
                },
                "required": [
                  "field",
                  "operator",
                  "value"
                ]
              }
            },
            "limit": {
              "type": "number",
              "description": "Number of documents to return",
              "default": 20
            },
            "pageToken": {
              "type": "string",
              "description": "Token for pagination to get the next page of results"
            },
            "orderBy": {
              "type": "array",
              "description": "Array of fields to order by",
              "items": {
                "type": "object",
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to order by"
                  },
                  "direction": {
                    "type": "string",
                    "description": "Sort direction (asc or desc)",
                    "enum": [
                      "asc",
                      "desc"
                    ],
                    "default": "asc"
                  }
                },
                "required": [
                  "field"
                ]
              }
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "firestore_get_document",
        "description": "Get a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "firestore_update_document",
        "description": "Update a document in a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            },
            "data": {
              "type": "object",
              "description": "Updated document data"
            }
          },
          "required": [
            "collection",
            "id",
            "data"
          ]
        }
      },
      {
        "name": "firestore_delete_document",
        "description": "Delete a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "id": {
              "type": "string",
              "description": "Document ID"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "auth_get_user",
        "description": "Get a user by ID or email from Firebase Authentication",
        "inputSchema": {
          "type": "object",
          "properties": {
            "identifier": {
              "type": "string",
              "description": "User ID or email address"
            }
          },
          "required": [
            "identifier"
          ]
        }
      },
      {
        "name": "storage_list_files",
        "description": "List files in a given path in Firebase Storage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directoryPath": {
              "type": "string",
              "description": "The optional path to list files from. If not provided, the root is used."
            }
          },
          "required": []
        }
      },
      {
        "name": "storage_get_file_info",
        "description": "Get file information including metadata and download URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path of the file to get information for"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "firestore_list_collections",
        "description": "List root collections in Firestore",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  "dify": {
    "name": "dify",
    "display_name": "Dify",
    "description": "A simple implementation of an MCP server for dify workflows.",
    "repository": {
      "type": "git",
      "url": "https://github.com/YanxingLiu/dify-mcp-server"
    },
    "homepage": "https://github.com/YanxingLiu/dify-mcp-server",
    "author": {
      "name": "YanxingLiu"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "dify",
      "server",
      "workflows"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/YanxingLiu/dify-mcp-server",
          "dify_mcp_server"
        ],
        "env": {
          "CONFIG_PATH": "${CONFIG_PATH}"
        }
      }
    },
    "arguments": {
      "CONFIG_PATH": {
        "description": "This environment variable indicates the path to the configuration file for the Dify MCP server, typically a YAML file containing necessary settings.",
        "required": true,
        "example": "/Users/lyx/Downloads/config.yaml"
      }
    }
  },
  "code-sandbox-mcp": {
    "name": "code-sandbox-mcp",
    "display_name": "Code Sandbox",
    "description": "An MCP server to create secure code sandbox environment for executing code within Docker containers.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Automata-Labs-team/code-sandbox-mcp"
    },
    "homepage": "https://github.com/Automata-Labs-team/code-sandbox-mcp",
    "author": {
      "name": "Automata-Labs-team"
    },
    "license": "MIT",
    "installations": {
      "custom": {
        "type": "custom",
        "command": "/path/to/code-sandbox-mcp",
        "args": [],
        "env": {}
      }
    },
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Docker",
      "Sandbox",
      "Code Execution"
    ]
  },
  "rijksmuseum": {
    "name": "rijksmuseum",
    "display_name": "Rijksmuseum",
    "description": "Interface with the Rijksmuseum API to search artworks, retrieve artwork details, access image tiles, and explore user collections.",
    "repository": {
      "type": "git",
      "url": "https://github.com/r-huijts/rijksmuseum-mcp"
    },
    "homepage": "https://github.com/r-huijts/rijksmuseum-mcp",
    "author": {
      "name": "r-huijts"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "collection",
      "Rijksmuseum"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-server-rijksmuseum"
        ],
        "env": {
          "RIJKSMUSEUM_API_KEY": "${RIJKSMUSEUM_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Artwork Discovery",
        "description": "Queries related to discovering artworks in the museum's collection.",
        "prompt": "\"Show me all paintings by Rembrandt from the 1640s\""
      },
      {
        "title": "Artwork Analysis",
        "description": "Queries related to analyzing specific artworks.",
        "prompt": "\"Tell me everything about The Night Watch\""
      },
      {
        "title": "Artist Research",
        "description": "Queries focused on researching artists and their works.",
        "prompt": "\"Create a timeline of Rembrandt's self-portraits\""
      },
      {
        "title": "Thematic Exploration",
        "description": "Queries that explore themes in the artworks.",
        "prompt": "\"Find all artworks depicting biblical scenes\""
      },
      {
        "title": "Collection Analysis",
        "description": "Queries about user-curated collections.",
        "prompt": "\"Show me the most popular user-curated collections\""
      },
      {
        "title": "Visual Details",
        "description": "Queries for examining visual details in artworks.",
        "prompt": "\"Let me examine the details in the background of The Night Watch\""
      }
    ],
    "arguments": {
      "RIJKSMUSEUM_API_KEY": {
        "description": "Your Rijksmuseum API key used for authenticating requests to the Rijksmuseum API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "search_artwork",
        "description": "Search and filter artworks in the Rijksmuseum collection. This tool provides extensive filtering options including artist name, type of artwork, materials, techniques, time periods, colors, and more. Results can be sorted in various ways and are paginated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "General search query that will match against artwork titles, descriptions, materials, techniques, etc. Use this for broad searches like 'sunflowers', 'portrait', 'landscape', etc."
            },
            "involvedMaker": {
              "type": "string",
              "description": "Search for artworks by a specific artist. Must be case-sensitive and exact, e.g., 'Rembrandt van Rijn', 'Vincent van Gogh'. Use + for spaces in names."
            },
            "type": {
              "type": "string",
              "description": "Filter by the type of artwork. Common values include 'painting', 'print', 'drawing', 'sculpture', 'photograph', 'furniture'. Use singular form."
            },
            "material": {
              "type": "string",
              "description": "Filter by the material used in the artwork. Examples: 'canvas', 'paper', 'wood', 'oil paint', 'marble'. Matches exact material names from the museum's classification."
            },
            "technique": {
              "type": "string",
              "description": "Filter by the technique used to create the artwork. Examples: 'oil painting', 'etching', 'watercolor', 'photography'. Matches specific techniques from the museum's classification."
            },
            "century": {
              "type": "integer",
              "description": "Filter artworks by the century they were created in. Use negative numbers for BCE, positive for CE. Range from -1 (100-1 BCE) to 21 (2000-2099 CE). Example: 17 for 17th century (1600-1699).",
              "minimum": -1,
              "maximum": 21
            },
            "color": {
              "type": "string",
              "description": "Filter artworks by predominant color. Use hexadecimal color codes without the # symbol. Examples: 'FF0000' for red, '00FF00' for green, '0000FF' for blue. The API will match artworks containing this color."
            },
            "imgonly": {
              "type": "boolean",
              "description": "When true, only returns artworks that have associated images. Set to true if you need to show or analyze the visual aspects of artworks.",
              "default": false
            },
            "toppieces": {
              "type": "boolean",
              "description": "When true, only returns artworks designated as masterpieces by the Rijksmuseum. These are the most significant and famous works in the collection.",
              "default": false
            },
            "sortBy": {
              "type": "string",
              "enum": [
                "relevance",
                "objecttype",
                "chronologic",
                "achronologic",
                "artist",
                "artistdesc"
              ],
              "description": "Determines the order of results. Options: 'relevance' (best matches first), 'objecttype' (grouped by type), 'chronologic' (oldest to newest), 'achronologic' (newest to oldest), 'artist' (artist name A-Z), 'artistdesc' (artist name Z-A).",
              "default": "relevance"
            },
            "p": {
              "type": "integer",
              "description": "Page number for paginated results, starting at 0. Use in combination with 'ps' to navigate through large result sets. Note: p * ps cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "ps": {
              "type": "integer",
              "description": "Number of artworks to return per page. Higher values return more results but take longer to process. Maximum of 100 items per page.",
              "minimum": 1,
              "maximum": 100,
              "default": 10
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the search and returned data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects artwork titles, descriptions, and other text fields.",
              "default": "en"
            }
          }
        }
      },
      {
        "name": "get_artwork_details",
        "description": "Retrieve comprehensive details about a specific artwork from the Rijksmuseum collection. Returns extensive information including:\n\n- Basic details (title, artist, dates)\n- Physical properties (dimensions, materials, techniques)\n- Historical context (dating, historical persons, documentation)\n- Visual information (colors, image data)\n- Curatorial information (descriptions, labels, location)\n- Acquisition details\n- Exhibition history\n\nThis is the primary tool for in-depth research on a specific artwork, providing all available museum documentation and metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectNumber": {
              "type": "string",
              "description": "The unique identifier of the artwork in the Rijksmuseum collection. Format is typically a combination of letters and numbers (e.g., 'SK-C-5' for The Night Watch, 'SK-A-3262' for Van Gogh's Self Portrait). Case-sensitive. This ID can be obtained from search results."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the artwork details. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects all textual information including descriptions, titles, and historical documentation.",
              "default": "en"
            }
          },
          "required": [
            "objectNumber"
          ]
        }
      },
      {
        "name": "get_artwork_image",
        "description": "Retrieve detailed image tile information for high-resolution viewing of an artwork. This tool provides data for implementing deep zoom functionality, allowing detailed examination of the artwork at various zoom levels.\n\nThe response includes multiple zoom levels (z0 to z6):\n- z0: Highest resolution (largest image)\n- z6: Lowest resolution (smallest image)\n\nEach zoom level contains:\n- Total width and height of the image at that level\n- A set of image tiles that make up the complete image\n- Position information (x,y) for each tile\n\nThis is particularly useful for:\n- Implementing deep zoom viewers\n- Studying fine artwork details\n- Analyzing brushwork or conservation details\n- Creating interactive viewing experiences",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectNumber": {
              "type": "string",
              "description": "The unique identifier of the artwork in the Rijksmuseum collection. Same format as used in get_artwork_details. The artwork must have an associated image for this to work."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the API response. Use 'en' for English or 'nl' for Dutch (Nederlands). While this endpoint primarily returns image data, any textual metadata will be in the specified language.",
              "default": "en"
            }
          },
          "required": [
            "objectNumber"
          ]
        }
      },
      {
        "name": "get_user_sets",
        "description": "Retrieve collections created by Rijksstudio users. These are curated sets of artworks that users have grouped together based on themes, artists, periods, or personal interests.\n\nEach set includes:\n- Basic information (name, description, creation date)\n- Creator details (username, language preference)\n- Collection statistics (number of items)\n- Navigation links (API and web URLs)\n\nThis tool is useful for:\n- Discovering user-curated exhibitions\n- Finding thematically related artworks\n- Exploring popular artwork groupings\n- Studying collection patterns",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "Page number for paginated results, starting at 0. Use with pageSize to navigate through sets. Note: page * pageSize cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "pageSize": {
              "type": "number",
              "description": "Number of user sets to return per page. Must be between 1 and 100. Larger values return more results but take longer to process.",
              "minimum": 1,
              "maximum": 100,
              "default": 10
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the response data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects set descriptions and user information.",
              "default": "en"
            }
          }
        }
      },
      {
        "name": "get_user_set_details",
        "description": "Retrieve detailed information about a specific user-created collection in Rijksstudio. Returns comprehensive information about the set and its contents, including:\n\n- Set metadata (name, description, creation date)\n- Creator information\n- List of artworks in the set\n- Image data for each artwork\n- Navigation links\n\nThis tool is particularly useful for:\n- Analyzing thematic groupings of artworks\n- Studying curatorial choices\n- Understanding collection patterns\n- Exploring relationships between artworks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "setId": {
              "type": "string",
              "description": "The unique identifier of the user set to fetch. Format is typically 'userId-setname'. This ID can be obtained from the get_user_sets results."
            },
            "culture": {
              "type": "string",
              "enum": [
                "nl",
                "en"
              ],
              "description": "Language for the response data. Use 'en' for English or 'nl' for Dutch (Nederlands). Affects set descriptions and artwork information.",
              "default": "en"
            },
            "page": {
              "type": "number",
              "description": "Page number for paginated results, starting at 0. Use with pageSize to navigate through large sets. Note: page * pageSize cannot exceed 10,000.",
              "minimum": 0,
              "default": 0
            },
            "pageSize": {
              "type": "number",
              "description": "Number of artworks to return per page. Must be between 1 and 100. Default is 25. Larger values return more artworks but take longer to process.",
              "minimum": 1,
              "maximum": 100,
              "default": 25
            }
          },
          "required": [
            "setId"
          ]
        }
      },
      {
        "name": "open_image_in_browser",
        "description": "Open a high-resolution image of an artwork in the default web browser for viewing. This tool is useful when you want to examine an artwork visually or show it to the user. Works with any valid Rijksmuseum image URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageUrl": {
              "type": "string",
              "description": "The full URL of the artwork image to open. Must be a valid HTTP/HTTPS URL from the Rijksmuseum's servers. These URLs can be obtained from artwork search results or details."
            }
          },
          "required": [
            "imageUrl"
          ]
        }
      },
      {
        "name": "get_artist_timeline",
        "description": "Generate a chronological timeline of an artist's works in the Rijksmuseum collection. This tool is perfect for studying an artist's development, analyzing their artistic periods, or understanding their contribution to art history over time.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "artist": {
              "type": "string",
              "description": "The name of the artist to create a timeline for. Must match the museum's naming convention (e.g., 'Rembrandt van Rijn', 'Vincent van Gogh'). Case sensitive and exact match required."
            },
            "maxWorks": {
              "type": "number",
              "description": "Maximum number of works to include in the timeline. Works are selected based on significance and quality of available images. Higher numbers give a more complete picture but may include less significant works.",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            }
          },
          "required": [
            "artist"
          ]
        }
      }
    ]
  },
  "mem0-mcp": {
    "name": "mem0-mcp",
    "display_name": "Mem0 Server",
    "description": "A Model Context Protocol server for Mem0, which helps with managing coding preferences.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mem0ai/mem0-mcp"
    },
    "homepage": "https://github.com/mem0ai/mem0-mcp",
    "author": {
      "name": "mem0ai"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "coding preferences",
      "mem0"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/mem0ai/mem0-mcp",
          "main.py"
        ]
      }
    },
    "arguments": {
      "host": {
        "description": "The host address that the server will bind to. This can be configured to allow access from different IP addresses or set it to 'localhost' for local access only.",
        "required": false,
        "example": "0.0.0.0"
      },
      "port": {
        "description": "The port number on which the server will listen for incoming connections. Changing this can help to avoid port conflicts with other services on the same machine.",
        "required": false,
        "example": "8080"
      }
    }
  },
  "slack": {
    "name": "slack",
    "display_name": "Slack",
    "description": "Channel management and messaging capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "slack",
      "api",
      "bot"
    ],
    "examples": [
      {
        "title": "Post a message to a channel",
        "description": "Send a message to a specified Slack channel.",
        "prompt": "Include the channel ID and the message text."
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-slack"
        ],
        "env": {
          "SLACK_BOT_TOKEN": "${SLACK_BOT_TOKEN}",
          "SLACK_TEAM_ID": "${SLACK_TEAM_ID}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "SLACK_BOT_TOKEN",
          "-e",
          "SLACK_TEAM_ID",
          "mcp/slack"
        ],
        "env": {
          "SLACK_BOT_TOKEN": "${SLACK_BOT_TOKEN}",
          "SLACK_TEAM_ID": "${SLACK_TEAM_ID}"
        }
      }
    },
    "author": {
      "name": "modelcontextprotocol"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/slack",
    "arguments": {
      "SLACK_BOT_TOKEN": {
        "description": "The OAuth token for the bot user in the Slack workspace, used for authenticating API requests.",
        "required": true,
        "example": "xoxb-your-bot-token"
      },
      "SLACK_TEAM_ID": {
        "description": "The unique identifier of the Slack workspace, required for operations within the workspace.",
        "required": true,
        "example": "T01234567"
      }
    },
    "tools": [
      {
        "name": "slack_list_channels",
        "description": "List public channels in the workspace with pagination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of channels to return (default 100, max 200)",
              "default": 100
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page of results"
            }
          }
        }
      },
      {
        "name": "slack_post_message",
        "description": "Post a new message to a Slack channel",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel to post to"
            },
            "text": {
              "type": "string",
              "description": "The message text to post"
            }
          },
          "required": [
            "channel_id",
            "text"
          ]
        }
      },
      {
        "name": "slack_reply_to_thread",
        "description": "Reply to a specific message thread in Slack",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the thread"
            },
            "thread_ts": {
              "type": "string",
              "description": "The timestamp of the parent message in the format '1234567890.123456'. Timestamps in the format without the period can be converted by adding the period such that 6 numbers come after it."
            },
            "text": {
              "type": "string",
              "description": "The reply text"
            }
          },
          "required": [
            "channel_id",
            "thread_ts",
            "text"
          ]
        }
      },
      {
        "name": "slack_add_reaction",
        "description": "Add a reaction emoji to a message",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the message"
            },
            "timestamp": {
              "type": "string",
              "description": "The timestamp of the message to react to"
            },
            "reaction": {
              "type": "string",
              "description": "The name of the emoji reaction (without ::)"
            }
          },
          "required": [
            "channel_id",
            "timestamp",
            "reaction"
          ]
        }
      },
      {
        "name": "slack_get_channel_history",
        "description": "Get recent messages from a channel",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel"
            },
            "limit": {
              "type": "number",
              "description": "Number of messages to retrieve (default 10)",
              "default": 10
            }
          },
          "required": [
            "channel_id"
          ]
        }
      },
      {
        "name": "slack_get_thread_replies",
        "description": "Get all replies in a message thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "type": "string",
              "description": "The ID of the channel containing the thread"
            },
            "thread_ts": {
              "type": "string",
              "description": "The timestamp of the parent message in the format '1234567890.123456'. Timestamps in the format without the period can be converted by adding the period such that 6 numbers come after it."
            }
          },
          "required": [
            "channel_id",
            "thread_ts"
          ]
        }
      },
      {
        "name": "slack_get_users",
        "description": "Get a list of all users in the workspace with their basic profile information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page of results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of users to return (default 100, max 200)",
              "default": 100
            }
          }
        }
      },
      {
        "name": "slack_get_user_profile",
        "description": "Get detailed profile information for a specific user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "string",
              "description": "The ID of the user"
            }
          },
          "required": [
            "user_id"
          ]
        }
      }
    ]
  },
  "openai-websearch-mcp": {
    "name": "openai-websearch-mcp",
    "display_name": "OpenAI WebSearch",
    "description": "This is a Python-based MCP server that provides OpenAI `web_search` build-in tool.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ConechoAI/openai-websearch-mcp"
    },
    "homepage": "https://github.com/ConechoAI/openai-websearch-mcp",
    "author": {
      "name": "ConechoAI"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "openai",
      "websearch",
      "AI assistant"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "openai-websearch-mcp"
        ],
        "env": {
          "OPENAI_API_KEY": "${OPENAI_API_KEY}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "openai_websearch_mcp"
        ],
        "env": {
          "OPENAI_API_KEY": "${OPENAI_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Using web search",
        "description": "Perform a web search using the OpenAI WebSearch MCP server.",
        "prompt": "search('latest news on AI')"
      }
    ],
    "arguments": {
      "OPENAI_API_KEY": {
        "description": "Your OpenAI API key to authenticate requests to the OpenAI API.",
        "required": true,
        "example": "sk-xxxx"
      }
    },
    "tools": [
      {
        "name": "web_search",
        "description": " It allows AI assistants to search the web during conversations with users",
        "inputSchema": {
          "$defs": {
            "UserLocation": {
              "properties": {
                "type": {
                  "const": "approximate",
                  "default": "approximate",
                  "title": "Type",
                  "type": "string"
                },
                "city": {
                  "title": "City",
                  "type": "string"
                },
                "country": {
                  "default": null,
                  "title": "Country",
                  "type": "string"
                },
                "region": {
                  "default": null,
                  "title": "Region",
                  "type": "string"
                },
                "timezone": {
                  "enum": [
                    "Africa/Abidjan",
                    "Africa/Accra",
                    "Africa/Addis_Ababa",
                    "Africa/Algiers",
                    "Africa/Asmara",
                    "Africa/Asmera",
                    "Africa/Bamako",
                    "Africa/Bangui",
                    "Africa/Banjul",
                    "Africa/Bissau",
                    "Africa/Blantyre",
                    "Africa/Brazzaville",
                    "Africa/Bujumbura",
                    "Africa/Cairo",
                    "Africa/Casablanca",
                    "Africa/Ceuta",
                    "Africa/Conakry",
                    "Africa/Dakar",
                    "Africa/Dar_es_Salaam",
                    "Africa/Djibouti",
                    "Africa/Douala",
                    "Africa/El_Aaiun",
                    "Africa/Freetown",
                    "Africa/Gaborone",
                    "Africa/Harare",
                    "Africa/Johannesburg",
                    "Africa/Juba",
                    "Africa/Kampala",
                    "Africa/Khartoum",
                    "Africa/Kigali",
                    "Africa/Kinshasa",
                    "Africa/Lagos",
                    "Africa/Libreville",
                    "Africa/Lome",
                    "Africa/Luanda",
                    "Africa/Lubumbashi",
                    "Africa/Lusaka",
                    "Africa/Malabo",
                    "Africa/Maputo",
                    "Africa/Maseru",
                    "Africa/Mbabane",
                    "Africa/Mogadishu",
                    "Africa/Monrovia",
                    "Africa/Nairobi",
                    "Africa/Ndjamena",
                    "Africa/Niamey",
                    "Africa/Nouakchott",
                    "Africa/Ouagadougou",
                    "Africa/Porto-Novo",
                    "Africa/Sao_Tome",
                    "Africa/Timbuktu",
                    "Africa/Tripoli",
                    "Africa/Tunis",
                    "Africa/Windhoek",
                    "America/Adak",
                    "America/Anchorage",
                    "America/Anguilla",
                    "America/Antigua",
                    "America/Araguaina",
                    "America/Argentina/Buenos_Aires",
                    "America/Argentina/Catamarca",
                    "America/Argentina/ComodRivadavia",
                    "America/Argentina/Cordoba",
                    "America/Argentina/Jujuy",
                    "America/Argentina/La_Rioja",
                    "America/Argentina/Mendoza",
                    "America/Argentina/Rio_Gallegos",
                    "America/Argentina/Salta",
                    "America/Argentina/San_Juan",
                    "America/Argentina/San_Luis",
                    "America/Argentina/Tucuman",
                    "America/Argentina/Ushuaia",
                    "America/Aruba",
                    "America/Asuncion",
                    "America/Atikokan",
                    "America/Atka",
                    "America/Bahia",
                    "America/Bahia_Banderas",
                    "America/Barbados",
                    "America/Belem",
                    "America/Belize",
                    "America/Blanc-Sablon",
                    "America/Boa_Vista",
                    "America/Bogota",
                    "America/Boise",
                    "America/Buenos_Aires",
                    "America/Cambridge_Bay",
                    "America/Campo_Grande",
                    "America/Cancun",
                    "America/Caracas",
                    "America/Catamarca",
                    "America/Cayenne",
                    "America/Cayman",
                    "America/Chicago",
                    "America/Chihuahua",
                    "America/Ciudad_Juarez",
                    "America/Coral_Harbour",
                    "America/Cordoba",
                    "America/Costa_Rica",
                    "America/Creston",
                    "America/Cuiaba",
                    "America/Curacao",
                    "America/Danmarkshavn",
                    "America/Dawson",
                    "America/Dawson_Creek",
                    "America/Denver",
                    "America/Detroit",
                    "America/Dominica",
                    "America/Edmonton",
                    "America/Eirunepe",
                    "America/El_Salvador",
                    "America/Ensenada",
                    "America/Fort_Nelson",
                    "America/Fort_Wayne",
                    "America/Fortaleza",
                    "America/Glace_Bay",
                    "America/Godthab",
                    "America/Goose_Bay",
                    "America/Grand_Turk",
                    "America/Grenada",
                    "America/Guadeloupe",
                    "America/Guatemala",
                    "America/Guayaquil",
                    "America/Guyana",
                    "America/Halifax",
                    "America/Havana",
                    "America/Hermosillo",
                    "America/Indiana/Indianapolis",
                    "America/Indiana/Knox",
                    "America/Indiana/Marengo",
                    "America/Indiana/Petersburg",
                    "America/Indiana/Tell_City",
                    "America/Indiana/Vevay",
                    "America/Indiana/Vincennes",
                    "America/Indiana/Winamac",
                    "America/Indianapolis",
                    "America/Inuvik",
                    "America/Iqaluit",
                    "America/Jamaica",
                    "America/Jujuy",
                    "America/Juneau",
                    "America/Kentucky/Louisville",
                    "America/Kentucky/Monticello",
                    "America/Knox_IN",
                    "America/Kralendijk",
                    "America/La_Paz",
                    "America/Lima",
                    "America/Los_Angeles",
                    "America/Louisville",
                    "America/Lower_Princes",
                    "America/Maceio",
                    "America/Managua",
                    "America/Manaus",
                    "America/Marigot",
                    "America/Martinique",
                    "America/Matamoros",
                    "America/Mazatlan",
                    "America/Mendoza",
                    "America/Menominee",
                    "America/Merida",
                    "America/Metlakatla",
                    "America/Mexico_City",
                    "America/Miquelon",
                    "America/Moncton",
                    "America/Monterrey",
                    "America/Montevideo",
                    "America/Montreal",
                    "America/Montserrat",
                    "America/Nassau",
                    "America/New_York",
                    "America/Nipigon",
                    "America/Nome",
                    "America/Noronha",
                    "America/North_Dakota/Beulah",
                    "America/North_Dakota/Center",
                    "America/North_Dakota/New_Salem",
                    "America/Nuuk",
                    "America/Ojinaga",
                    "America/Panama",
                    "America/Pangnirtung",
                    "America/Paramaribo",
                    "America/Phoenix",
                    "America/Port-au-Prince",
                    "America/Port_of_Spain",
                    "America/Porto_Acre",
                    "America/Porto_Velho",
                    "America/Puerto_Rico",
                    "America/Punta_Arenas",
                    "America/Rainy_River",
                    "America/Rankin_Inlet",
                    "America/Recife",
                    "America/Regina",
                    "America/Resolute",
                    "America/Rio_Branco",
                    "America/Rosario",
                    "America/Santa_Isabel",
                    "America/Santarem",
                    "America/Santiago",
                    "America/Santo_Domingo",
                    "America/Sao_Paulo",
                    "America/Scoresbysund",
                    "America/Shiprock",
                    "America/Sitka",
                    "America/St_Barthelemy",
                    "America/St_Johns",
                    "America/St_Kitts",
                    "America/St_Lucia",
                    "America/St_Thomas",
                    "America/St_Vincent",
                    "America/Swift_Current",
                    "America/Tegucigalpa",
                    "America/Thule",
                    "America/Thunder_Bay",
                    "America/Tijuana",
                    "America/Toronto",
                    "America/Tortola",
                    "America/Vancouver",
                    "America/Virgin",
                    "America/Whitehorse",
                    "America/Winnipeg",
                    "America/Yakutat",
                    "America/Yellowknife",
                    "Antarctica/Casey",
                    "Antarctica/Davis",
                    "Antarctica/DumontDUrville",
                    "Antarctica/Macquarie",
                    "Antarctica/Mawson",
                    "Antarctica/McMurdo",
                    "Antarctica/Palmer",
                    "Antarctica/Rothera",
                    "Antarctica/South_Pole",
                    "Antarctica/Syowa",
                    "Antarctica/Troll",
                    "Antarctica/Vostok",
                    "Arctic/Longyearbyen",
                    "Asia/Aden",
                    "Asia/Almaty",
                    "Asia/Amman",
                    "Asia/Anadyr",
                    "Asia/Aqtau",
                    "Asia/Aqtobe",
                    "Asia/Ashgabat",
                    "Asia/Ashkhabad",
                    "Asia/Atyrau",
                    "Asia/Baghdad",
                    "Asia/Bahrain",
                    "Asia/Baku",
                    "Asia/Bangkok",
                    "Asia/Barnaul",
                    "Asia/Beirut",
                    "Asia/Bishkek",
                    "Asia/Brunei",
                    "Asia/Calcutta",
                    "Asia/Chita",
                    "Asia/Choibalsan",
                    "Asia/Chongqing",
                    "Asia/Chungking",
                    "Asia/Colombo",
                    "Asia/Dacca",
                    "Asia/Damascus",
                    "Asia/Dhaka",
                    "Asia/Dili",
                    "Asia/Dubai",
                    "Asia/Dushanbe",
                    "Asia/Famagusta",
                    "Asia/Gaza",
                    "Asia/Harbin",
                    "Asia/Hebron",
                    "Asia/Ho_Chi_Minh",
                    "Asia/Hong_Kong",
                    "Asia/Hovd",
                    "Asia/Irkutsk",
                    "Asia/Istanbul",
                    "Asia/Jakarta",
                    "Asia/Jayapura",
                    "Asia/Jerusalem",
                    "Asia/Kabul",
                    "Asia/Kamchatka",
                    "Asia/Karachi",
                    "Asia/Kashgar",
                    "Asia/Kathmandu",
                    "Asia/Katmandu",
                    "Asia/Khandyga",
                    "Asia/Kolkata",
                    "Asia/Krasnoyarsk",
                    "Asia/Kuala_Lumpur",
                    "Asia/Kuching",
                    "Asia/Kuwait",
                    "Asia/Macao",
                    "Asia/Macau",
                    "Asia/Magadan",
                    "Asia/Makassar",
                    "Asia/Manila",
                    "Asia/Muscat",
                    "Asia/Nicosia",
                    "Asia/Novokuznetsk",
                    "Asia/Novosibirsk",
                    "Asia/Omsk",
                    "Asia/Oral",
                    "Asia/Phnom_Penh",
                    "Asia/Pontianak",
                    "Asia/Pyongyang",
                    "Asia/Qatar",
                    "Asia/Qostanay",
                    "Asia/Qyzylorda",
                    "Asia/Rangoon",
                    "Asia/Riyadh",
                    "Asia/Saigon",
                    "Asia/Sakhalin",
                    "Asia/Samarkand",
                    "Asia/Seoul",
                    "Asia/Shanghai",
                    "Asia/Singapore",
                    "Asia/Srednekolymsk",
                    "Asia/Taipei",
                    "Asia/Tashkent",
                    "Asia/Tbilisi",
                    "Asia/Tehran",
                    "Asia/Tel_Aviv",
                    "Asia/Thimbu",
                    "Asia/Thimphu",
                    "Asia/Tokyo",
                    "Asia/Tomsk",
                    "Asia/Ujung_Pandang",
                    "Asia/Ulaanbaatar",
                    "Asia/Ulan_Bator",
                    "Asia/Urumqi",
                    "Asia/Ust-Nera",
                    "Asia/Vientiane",
                    "Asia/Vladivostok",
                    "Asia/Yakutsk",
                    "Asia/Yangon",
                    "Asia/Yekaterinburg",
                    "Asia/Yerevan",
                    "Atlantic/Azores",
                    "Atlantic/Bermuda",
                    "Atlantic/Canary",
                    "Atlantic/Cape_Verde",
                    "Atlantic/Faeroe",
                    "Atlantic/Faroe",
                    "Atlantic/Jan_Mayen",
                    "Atlantic/Madeira",
                    "Atlantic/Reykjavik",
                    "Atlantic/South_Georgia",
                    "Atlantic/St_Helena",
                    "Atlantic/Stanley",
                    "Australia/ACT",
                    "Australia/Adelaide",
                    "Australia/Brisbane",
                    "Australia/Broken_Hill",
                    "Australia/Canberra",
                    "Australia/Currie",
                    "Australia/Darwin",
                    "Australia/Eucla",
                    "Australia/Hobart",
                    "Australia/LHI",
                    "Australia/Lindeman",
                    "Australia/Lord_Howe",
                    "Australia/Melbourne",
                    "Australia/NSW",
                    "Australia/North",
                    "Australia/Perth",
                    "Australia/Queensland",
                    "Australia/South",
                    "Australia/Sydney",
                    "Australia/Tasmania",
                    "Australia/Victoria",
                    "Australia/West",
                    "Australia/Yancowinna",
                    "Brazil/Acre",
                    "Brazil/DeNoronha",
                    "Brazil/East",
                    "Brazil/West",
                    "CET",
                    "CST6CDT",
                    "Canada/Atlantic",
                    "Canada/Central",
                    "Canada/Eastern",
                    "Canada/Mountain",
                    "Canada/Newfoundland",
                    "Canada/Pacific",
                    "Canada/Saskatchewan",
                    "Canada/Yukon",
                    "Chile/Continental",
                    "Chile/EasterIsland",
                    "Cuba",
                    "EET",
                    "EST",
                    "EST5EDT",
                    "Egypt",
                    "Eire",
                    "Etc/GMT",
                    "Etc/GMT+0",
                    "Etc/GMT+1",
                    "Etc/GMT+10",
                    "Etc/GMT+11",
                    "Etc/GMT+12",
                    "Etc/GMT+2",
                    "Etc/GMT+3",
                    "Etc/GMT+4",
                    "Etc/GMT+5",
                    "Etc/GMT+6",
                    "Etc/GMT+7",
                    "Etc/GMT+8",
                    "Etc/GMT+9",
                    "Etc/GMT-0",
                    "Etc/GMT-1",
                    "Etc/GMT-10",
                    "Etc/GMT-11",
                    "Etc/GMT-12",
                    "Etc/GMT-13",
                    "Etc/GMT-14",
                    "Etc/GMT-2",
                    "Etc/GMT-3",
                    "Etc/GMT-4",
                    "Etc/GMT-5",
                    "Etc/GMT-6",
                    "Etc/GMT-7",
                    "Etc/GMT-8",
                    "Etc/GMT-9",
                    "Etc/GMT0",
                    "Etc/Greenwich",
                    "Etc/UCT",
                    "Etc/UTC",
                    "Etc/Universal",
                    "Etc/Zulu",
                    "Europe/Amsterdam",
                    "Europe/Andorra",
                    "Europe/Astrakhan",
                    "Europe/Athens",
                    "Europe/Belfast",
                    "Europe/Belgrade",
                    "Europe/Berlin",
                    "Europe/Bratislava",
                    "Europe/Brussels",
                    "Europe/Bucharest",
                    "Europe/Budapest",
                    "Europe/Busingen",
                    "Europe/Chisinau",
                    "Europe/Copenhagen",
                    "Europe/Dublin",
                    "Europe/Gibraltar",
                    "Europe/Guernsey",
                    "Europe/Helsinki",
                    "Europe/Isle_of_Man",
                    "Europe/Istanbul",
                    "Europe/Jersey",
                    "Europe/Kaliningrad",
                    "Europe/Kiev",
                    "Europe/Kirov",
                    "Europe/Kyiv",
                    "Europe/Lisbon",
                    "Europe/Ljubljana",
                    "Europe/London",
                    "Europe/Luxembourg",
                    "Europe/Madrid",
                    "Europe/Malta",
                    "Europe/Mariehamn",
                    "Europe/Minsk",
                    "Europe/Monaco",
                    "Europe/Moscow",
                    "Europe/Nicosia",
                    "Europe/Oslo",
                    "Europe/Paris",
                    "Europe/Podgorica",
                    "Europe/Prague",
                    "Europe/Riga",
                    "Europe/Rome",
                    "Europe/Samara",
                    "Europe/San_Marino",
                    "Europe/Sarajevo",
                    "Europe/Saratov",
                    "Europe/Simferopol",
                    "Europe/Skopje",
                    "Europe/Sofia",
                    "Europe/Stockholm",
                    "Europe/Tallinn",
                    "Europe/Tirane",
                    "Europe/Tiraspol",
                    "Europe/Ulyanovsk",
                    "Europe/Uzhgorod",
                    "Europe/Vaduz",
                    "Europe/Vatican",
                    "Europe/Vienna",
                    "Europe/Vilnius",
                    "Europe/Volgograd",
                    "Europe/Warsaw",
                    "Europe/Zagreb",
                    "Europe/Zaporozhye",
                    "Europe/Zurich",
                    "Factory",
                    "GB",
                    "GB-Eire",
                    "GMT",
                    "GMT+0",
                    "GMT-0",
                    "GMT0",
                    "Greenwich",
                    "HST",
                    "Hongkong",
                    "Iceland",
                    "Indian/Antananarivo",
                    "Indian/Chagos",
                    "Indian/Christmas",
                    "Indian/Cocos",
                    "Indian/Comoro",
                    "Indian/Kerguelen",
                    "Indian/Mahe",
                    "Indian/Maldives",
                    "Indian/Mauritius",
                    "Indian/Mayotte",
                    "Indian/Reunion",
                    "Iran",
                    "Israel",
                    "Jamaica",
                    "Japan",
                    "Kwajalein",
                    "Libya",
                    "MET",
                    "MST",
                    "MST7MDT",
                    "Mexico/BajaNorte",
                    "Mexico/BajaSur",
                    "Mexico/General",
                    "NZ",
                    "NZ-CHAT",
                    "Navajo",
                    "PRC",
                    "PST8PDT",
                    "Pacific/Apia",
                    "Pacific/Auckland",
                    "Pacific/Bougainville",
                    "Pacific/Chatham",
                    "Pacific/Chuuk",
                    "Pacific/Easter",
                    "Pacific/Efate",
                    "Pacific/Enderbury",
                    "Pacific/Fakaofo",
                    "Pacific/Fiji",
                    "Pacific/Funafuti",
                    "Pacific/Galapagos",
                    "Pacific/Gambier",
                    "Pacific/Guadalcanal",
                    "Pacific/Guam",
                    "Pacific/Honolulu",
                    "Pacific/Johnston",
                    "Pacific/Kanton",
                    "Pacific/Kiritimati",
                    "Pacific/Kosrae",
                    "Pacific/Kwajalein",
                    "Pacific/Majuro",
                    "Pacific/Marquesas",
                    "Pacific/Midway",
                    "Pacific/Nauru",
                    "Pacific/Niue",
                    "Pacific/Norfolk",
                    "Pacific/Noumea",
                    "Pacific/Pago_Pago",
                    "Pacific/Palau",
                    "Pacific/Pitcairn",
                    "Pacific/Pohnpei",
                    "Pacific/Ponape",
                    "Pacific/Port_Moresby",
                    "Pacific/Rarotonga",
                    "Pacific/Saipan",
                    "Pacific/Samoa",
                    "Pacific/Tahiti",
                    "Pacific/Tarawa",
                    "Pacific/Tongatapu",
                    "Pacific/Truk",
                    "Pacific/Wake",
                    "Pacific/Wallis",
                    "Pacific/Yap",
                    "Poland",
                    "Portugal",
                    "ROC",
                    "ROK",
                    "Singapore",
                    "Turkey",
                    "UCT",
                    "US/Alaska",
                    "US/Aleutian",
                    "US/Arizona",
                    "US/Central",
                    "US/East-Indiana",
                    "US/Eastern",
                    "US/Hawaii",
                    "US/Indiana-Starke",
                    "US/Michigan",
                    "US/Mountain",
                    "US/Pacific",
                    "US/Samoa",
                    "UTC",
                    "Universal",
                    "W-SU",
                    "WET",
                    "Zulu"
                  ],
                  "minLength": 1,
                  "title": "Timezone",
                  "type": "string"
                }
              },
              "required": [
                "city",
                "timezone"
              ],
              "title": "UserLocation",
              "type": "object"
            }
          },
          "properties": {
            "input": {
              "title": "Input",
              "type": "string"
            },
            "model": {
              "default": "gpt-4o-mini",
              "enum": [
                "gpt-4o",
                "gpt-4o-mini"
              ],
              "title": "Model",
              "type": "string"
            },
            "type": {
              "default": "web_search_preview",
              "enum": [
                "web_search_preview",
                "web_search_preview_2025_03_11"
              ],
              "title": "Type",
              "type": "string"
            },
            "search_context_size": {
              "default": "medium",
              "enum": [
                "low",
                "medium",
                "high"
              ],
              "title": "Search Context Size",
              "type": "string"
            },
            "user_location": {
              "$ref": "#/$defs/UserLocation",
              "default": null
            }
          },
          "required": [
            "input"
          ],
          "title": "web_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "linear": {
    "name": "linear",
    "display_name": "Linear",
    "description": "Allows LLM to interact with Linear's API for project management, including searching, creating, and updating issues.",
    "repository": {
      "type": "git",
      "url": "https://github.com/jerhadf/linear-mcp-server"
    },
    "homepage": "https://github.com/jerhadf/linear-mcp-server",
    "author": {
      "name": "jerhadf"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "linear",
      "issue tracking",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "linear-mcp-server"
        ],
        "env": {
          "LINEAR_API_KEY": "${LINEAR_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Show me all my high-priority issues",
        "description": "Execute the search_issues tool and/or linear-user:///{userId}/assigned to find issues assigned to the user with priority 1",
        "prompt": "Show me all my high-priority issues"
      },
      {
        "title": "Create a bug report",
        "description": "Use create_issue to create a new high-priority issue with appropriate details and status tracking.",
        "prompt": "Based on what I've told you about this bug already, make a bug report for the authentication system"
      },
      {
        "title": "Find all in-progress frontend tasks",
        "description": "Use search_issues to locate frontend-related issues with in progress status.",
        "prompt": "Find all in progress frontend tasks"
      },
      {
        "title": "Get summary of recent updates",
        "description": "Use search_issues to identify relevant issue(s) and fetch the issue details.",
        "prompt": "Give me a summary of recent updates on the issues for mobile app development"
      },
      {
        "title": "Analyze current workload for the mobile team",
        "description": "Combine linear-team:///{teamId}/issues and search_issues to analyze issue distribution and priorities across the mobile team.",
        "prompt": "What's the current workload for the mobile team?"
      }
    ],
    "arguments": {
      "LINEAR_API_KEY": {
        "description": "Your Linear API key to authenticate requests to the Linear API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "linear_create_issue",
        "description": "Creates a new Linear issue with specified details. Use this to create tickets for tasks, bugs, or feature requests. Returns the created issue's identifier and URL. Required fields are title and teamId, with optional description, priority (0-4, where 0 is no priority and 1 is urgent), and status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "teamId": {
              "type": "string",
              "description": "Team ID"
            },
            "description": {
              "type": "string",
              "description": "Issue description"
            },
            "priority": {
              "type": "number",
              "description": "Priority (0-4)"
            },
            "status": {
              "type": "string",
              "description": "Issue status"
            }
          },
          "required": [
            "title",
            "teamId"
          ]
        }
      },
      {
        "name": "linear_update_issue",
        "description": "Updates an existing Linear issue's properties. Use this to modify issue details like title, description, priority, or status. Requires the issue ID and accepts any combination of updatable fields. Returns the updated issue's identifier and URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Issue ID"
            },
            "title": {
              "type": "string",
              "description": "New title"
            },
            "description": {
              "type": "string",
              "description": "New description"
            },
            "priority": {
              "type": "number",
              "description": "New priority (0-4)"
            },
            "status": {
              "type": "string",
              "description": "New status"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "linear_search_issues",
        "description": "Searches Linear issues using flexible criteria. Supports filtering by any combination of: title/description text, team, status, assignee, labels, priority (1=urgent, 2=high, 3=normal, 4=low), and estimate. Returns up to 10 issues by default (configurable via limit).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Optional text to search in title and description"
            },
            "teamId": {
              "type": "string",
              "description": "Filter by team ID"
            },
            "status": {
              "type": "string",
              "description": "Filter by status name (e.g., 'In Progress', 'Done')"
            },
            "assigneeId": {
              "type": "string",
              "description": "Filter by assignee's user ID"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter by label names"
            },
            "priority": {
              "type": "number",
              "description": "Filter by priority (1=urgent, 2=high, 3=normal, 4=low)"
            },
            "estimate": {
              "type": "number",
              "description": "Filter by estimate points"
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Include archived issues in results (default: false)"
            },
            "limit": {
              "type": "number",
              "description": "Max results to return (default: 10)"
            }
          }
        }
      },
      {
        "name": "linear_get_user_issues",
        "description": "Retrieves issues assigned to a specific user or the authenticated user if no userId is provided. Returns issues sorted by last updated, including priority, status, and other metadata. Useful for finding a user's workload or tracking assigned tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userId": {
              "type": "string",
              "description": "Optional user ID. If not provided, returns authenticated user's issues"
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Include archived issues in results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of issues to return (default: 50)"
            }
          }
        }
      },
      {
        "name": "linear_add_comment",
        "description": "Adds a comment to an existing Linear issue. Supports markdown formatting in the comment body. Can optionally specify a custom user name and avatar for the comment. Returns the created comment's details including its URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID of the issue to comment on"
            },
            "body": {
              "type": "string",
              "description": "Comment text in markdown format"
            },
            "createAsUser": {
              "type": "string",
              "description": "Optional custom username to show for the comment"
            },
            "displayIconUrl": {
              "type": "string",
              "description": "Optional avatar URL for the comment"
            }
          },
          "required": [
            "issueId",
            "body"
          ]
        }
      }
    ]
  },
  "mcp-create": {
    "name": "mcp-create",
    "display_name": "Create Server",
    "description": "A dynamic MCP server management service that creates, runs, and manages Model Context Protocol servers on-the-fly.",
    "repository": {
      "type": "git",
      "url": "https://github.com/tesla0225/mcp-create"
    },
    "homepage": "https://github.com/tesla0225/mcp-create",
    "author": {
      "name": "tesla0225"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "dynamic",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/tesla0225/mcp-create"
        ]
      }
    },
    "examples": [
      {
        "title": "Creating a New Server",
        "description": "Example of creating a new server using TypeScript.",
        "prompt": "{\"name\":\"create-server-from-template\",\"arguments\":{\"language\":\"typescript\"}}"
      },
      {
        "title": "Executing a Tool",
        "description": "Example of executing a tool on a server.",
        "prompt": "{\"name\":\"execute-tool\",\"arguments\":{\"serverId\":\"ba7c9a4f-6ba8-4cad-8ec8-a41a08c19fac\",\"toolName\":\"echo\",\"args\":{\"message\":\"Hello, dynamic MCP server!\"}}}"
      }
    ]
  },
  "okta": {
    "name": "okta",
    "display_name": "Okta",
    "description": "Interact with Okta API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kapilduraphe/okta-mcp-server"
    },
    "homepage": "https://github.com/kapilduraphe/okta-mcp-server",
    "author": {
      "name": "kapilduraphe"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Okta",
      "user management",
      "group management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kapilduraphe/okta-mcp-server"
        ],
        "env": {
          "OKTA_ORG_URL": "${OKTA_ORG_URL}",
          "OKTA_API_TOKEN": "${OKTA_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Show user details",
        "description": "Retrieve details for a specific user.",
        "prompt": "Show me details for user with userId XXXX"
      },
      {
        "title": "Check user status",
        "description": "Get the status of a specific user.",
        "prompt": "What's the status of user john.doe@company.com"
      },
      {
        "title": "Last login info",
        "description": "Find out when a user last logged in.",
        "prompt": "When was the last login for user jane.smith@organization.com"
      },
      {
        "title": "List users by department",
        "description": "Get a list of all users in the marketing department.",
        "prompt": "List all users in the marketing department"
      },
      {
        "title": "Find recent users",
        "description": "Retrieve users created in the last month.",
        "prompt": "Find users created in the last month"
      },
      {
        "title": "Show user groups",
        "description": "List all groups in the Okta organization.",
        "prompt": "Show me all the groups in my Okta organization"
      },
      {
        "title": "Admin groups",
        "description": "List groups that contain the word 'admin'.",
        "prompt": "List groups containing the word 'admin'"
      }
    ],
    "arguments": {
      "OKTA_ORG_URL": {
        "description": "The base URL for your Okta organization, should include 'https://'.",
        "required": true,
        "example": "https://dev-123456.okta.com"
      },
      "OKTA_API_TOKEN": {
        "description": "A valid API token used to authenticate API requests to Okta.",
        "required": true
      }
    }
  },
  "base-free-usdc-transfer": {
    "name": "base-free-usdc-transfer",
    "display_name": "Free USDC Transfer",
    "description": "Send USDC on [Base](https://base.org/) for free using Claude AI! Built with [Coinbase CDP](https://docs.cdp.coinbase.com/mpc-wallet/docs/welcome).",
    "repository": {
      "type": "git",
      "url": "https://github.com/magnetai/mcp-free-usdc-transfer"
    },
    "homepage": "https://github.com/magnetai/mcp-free-usdc-transfer",
    "author": {
      "name": "magnetai"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "USDC",
      "Base",
      "Coinbase",
      "MPC Wallet"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@magnetai/free-usdc-transfer"
        ],
        "env": {
          "COINBASE_CDP_API_KEY_NAME": "${COINBASE_CDP_API_KEY_NAME}",
          "COINBASE_CDP_PRIVATE_KEY": "${COINBASE_CDP_PRIVATE_KEY}"
        }
      }
    },
    "arguments": {
      "COINBASE_CDP_API_KEY_NAME": {
        "description": "The name of your Coinbase CDP API key, which is required for authenticating API requests.",
        "required": true,
        "example": "my_api_key_name"
      }
    },
    "tools": [
      {
        "name": "tranfer-usdc",
        "description": "Analyze the value of the purchased items and transfer USDC to the recipient via the Base chain. Due to the uncertainty of blockchain transaction times, the transaction is only scheduled here and will not wait for the transaction to be completed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "usdc_amount": {
              "type": "number",
              "description": "USDC amount, greater than 0"
            },
            "recipient": {
              "type": "string",
              "description": "Recipient's on-chain address or ENS addresses ending in .eth"
            }
          },
          "required": [
            "usdc_amount",
            "recipient"
          ]
        }
      },
      {
        "name": "create_coinbase_mpc_wallet",
        "description": "Used to create your Coinbase MPC wallet address. The newly created wallet cannot be used directly; the user must first deposit USDC. The transfer after creation requires user confirmation",
        "inputSchema": {
          "type": "object"
        }
      }
    ]
  },
  "mariadb": {
    "name": "mariadb",
    "display_name": "MariaDB Database Integration",
    "description": "MariaDB database integration with configurable access controls in Python.",
    "repository": {
      "type": "git",
      "url": "https://github.com/abel9851/mcp-server-mariadb"
    },
    "homepage": "https://github.com/abel9851/mcp-server-mariadb",
    "author": {
      "name": "abel9851"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MariaDB",
      "Data Retrieval"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-mariadb",
          "--host",
          "${DB_HOST}",
          "--port",
          "${DB_PORT}",
          "--user",
          "${DB_USER}",
          "--password",
          "${DB_PASSWORD}",
          "--database",
          "${DB_NAME}"
        ]
      }
    },
    "examples": [
      {
        "title": "Query Database",
        "description": "Example of executing a read-only operation against MariaDB.",
        "prompt": "Execute read-only operations against your MariaDB database."
      }
    ],
    "arguments": {
      "DB_HOST": {
        "description": "The hostname of the MariaDB server to connect to.",
        "required": true,
        "example": "localhost"
      },
      "DB_PORT": {
        "description": "The port number on which the MariaDB server is listening.",
        "required": true,
        "example": "3306"
      },
      "DB_USER": {
        "description": "The username to connect to the MariaDB database.",
        "required": true,
        "example": "root"
      },
      "DB_PASSWORD": {
        "description": "The password for the MariaDB user.",
        "required": true
      },
      "DB_NAME": {
        "description": "The name of the database to connect to.",
        "required": true
      }
    },
    "tools": [
      {
        "name": "query_database",
        "description": "Execute a read-only operation against the MariaDB database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "servicenow": {
    "name": "servicenow",
    "display_name": "ServiceNow",
    "description": "A MCP server to interact with a ServiceNow instance",
    "repository": {
      "type": "git",
      "url": "https://github.com/osomai/servicenow-mcp"
    },
    "homepage": "https://github.com/osomai/servicenow-mcp",
    "author": {
      "name": "osomai"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "ServiceNow",
      "Automation"
    ],
    "examples": [
      {
        "title": "Incident Management - Creating an Incident",
        "description": "Create a new incident for a network outage in the east region.",
        "prompt": "Create a new incident for a network outage in the east region."
      },
      {
        "title": "Service Catalog - List Items",
        "description": "Show me all items in the service catalog.",
        "prompt": "Show me all items in the service catalog."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/osomai/servicenow-mcp",
          "servicenow-mcp"
        ],
        "env": {
          "SERVICENOW_INSTANCE_URL": "${SERVICENOW_INSTANCE_URL}",
          "SERVICENOW_USERNAME": "${SERVICENOW_USERNAME}",
          "SERVICENOW_PASSWORD": "${SERVICENOW_PASSWORD}",
          "SERVICENOW_AUTH_TYPE": "${SERVICENOW_AUTH_TYPE}"
        }
      }
    },
    "arguments": {
      "SERVICENOW_INSTANCE_URL": {
        "description": "URL of the ServiceNow instance to connect to.",
        "required": true,
        "example": "https://your-instance.service-now.com"
      },
      "SERVICENOW_USERNAME": {
        "description": "Username for accessing the ServiceNow instance.",
        "required": true,
        "example": "your-username"
      },
      "SERVICENOW_PASSWORD": {
        "description": "Password for the ServiceNow username.",
        "required": true,
        "example": "your-password"
      },
      "SERVICENOW_AUTH_TYPE": {
        "description": "Authentication type for connecting to ServiceNow. Options are 'basic', 'oauth', or 'api_key'.",
        "required": true,
        "example": "basic"
      }
    },
    "tools": [
      {
        "name": "create_incident",
        "description": "Create a new incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateIncidentParams": {
              "description": "Parameters for creating an incident.",
              "properties": {
                "short_description": {
                  "description": "Short description of the incident",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the incident",
                  "title": "Description"
                },
                "caller_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User who reported the incident",
                  "title": "Caller Id"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the incident",
                  "title": "Category"
                },
                "subcategory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Subcategory of the incident",
                  "title": "Subcategory"
                },
                "priority": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Priority of the incident",
                  "title": "Priority"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the incident",
                  "title": "Impact"
                },
                "urgency": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Urgency of the incident",
                  "title": "Urgency"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the incident",
                  "title": "Assigned To"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the incident",
                  "title": "Assignment Group"
                }
              },
              "required": [
                "short_description"
              ],
              "title": "CreateIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "update_incident",
        "description": "Update an existing incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateIncidentParams": {
              "description": "Parameters for updating an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Short description of the incident",
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the incident",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the incident",
                  "title": "State"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the incident",
                  "title": "Category"
                },
                "subcategory": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Subcategory of the incident",
                  "title": "Subcategory"
                },
                "priority": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Priority of the incident",
                  "title": "Priority"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the incident",
                  "title": "Impact"
                },
                "urgency": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Urgency of the incident",
                  "title": "Urgency"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the incident",
                  "title": "Assigned To"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the incident",
                  "title": "Assignment Group"
                },
                "work_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Work notes to add to the incident",
                  "title": "Work Notes"
                },
                "close_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Close notes to add to the incident",
                  "title": "Close Notes"
                },
                "close_code": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Close code for the incident",
                  "title": "Close Code"
                }
              },
              "required": [
                "incident_id"
              ],
              "title": "UpdateIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "add_comment",
        "description": "Add a comment to an incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddCommentParams": {
              "description": "Parameters for adding a comment to an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "comment": {
                  "description": "Comment to add to the incident",
                  "title": "Comment",
                  "type": "string"
                },
                "is_work_note": {
                  "default": false,
                  "description": "Whether the comment is a work note",
                  "title": "Is Work Note",
                  "type": "boolean"
                }
              },
              "required": [
                "incident_id",
                "comment"
              ],
              "title": "AddCommentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddCommentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_commentArguments",
          "type": "object"
        }
      },
      {
        "name": "resolve_incident",
        "description": "Resolve an incident in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ResolveIncidentParams": {
              "description": "Parameters for resolving an incident.",
              "properties": {
                "incident_id": {
                  "description": "Incident ID or sys_id",
                  "title": "Incident Id",
                  "type": "string"
                },
                "resolution_code": {
                  "description": "Resolution code for the incident",
                  "title": "Resolution Code",
                  "type": "string"
                },
                "resolution_notes": {
                  "description": "Resolution notes for the incident",
                  "title": "Resolution Notes",
                  "type": "string"
                }
              },
              "required": [
                "incident_id",
                "resolution_code",
                "resolution_notes"
              ],
              "title": "ResolveIncidentParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ResolveIncidentParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "resolve_incidentArguments",
          "type": "object"
        }
      },
      {
        "name": "list_incidents",
        "description": "List incidents from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListIncidentsParams": {
              "description": "Parameters for listing incidents.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of incidents to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by incident state",
                  "title": "State"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by assigned user",
                  "title": "Assigned To"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for incidents",
                  "title": "Query"
                }
              },
              "title": "ListIncidentsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListIncidentsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_incidentsArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_items",
        "description": "List service catalog items.",
        "inputSchema": {
          "$defs": {
            "ListCatalogItemsParams": {
              "description": "Parameters for listing service catalog items.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of catalog items to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for catalog items",
                  "title": "Query"
                },
                "active": {
                  "default": true,
                  "description": "Whether to only return active catalog items",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "title": "ListCatalogItemsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogItemsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_itemsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_catalog_item",
        "description": "Get a specific service catalog item.",
        "inputSchema": {
          "$defs": {
            "GetCatalogItemParams": {
              "description": "Parameters for getting a specific service catalog item.",
              "properties": {
                "item_id": {
                  "description": "Catalog item ID or sys_id",
                  "title": "Item Id",
                  "type": "string"
                }
              },
              "required": [
                "item_id"
              ],
              "title": "GetCatalogItemParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetCatalogItemParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_catalog_itemArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_categories",
        "description": "List service catalog categories.",
        "inputSchema": {
          "$defs": {
            "ListCatalogCategoriesParams": {
              "description": "Parameters for listing service catalog categories.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of categories to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for categories",
                  "title": "Query"
                },
                "active": {
                  "default": true,
                  "description": "Whether to only return active categories",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "title": "ListCatalogCategoriesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogCategoriesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_catalog_category",
        "description": "Create a new service catalog category.",
        "inputSchema": {
          "$defs": {
            "CreateCatalogCategoryParams": {
              "description": "Parameters for creating a new service catalog category.",
              "properties": {
                "title": {
                  "description": "Title of the category",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category sys_id",
                  "title": "Parent"
                },
                "icon": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Icon for the category",
                  "title": "Icon"
                },
                "active": {
                  "default": true,
                  "description": "Whether the category is active",
                  "title": "Active",
                  "type": "boolean"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Order of the category",
                  "title": "Order"
                }
              },
              "required": [
                "title"
              ],
              "title": "CreateCatalogCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCatalogCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_catalog_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_category",
        "description": "Update an existing service catalog category.",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogCategoryParams": {
              "description": "Parameters for updating a service catalog category.",
              "properties": {
                "category_id": {
                  "description": "Category ID or sys_id",
                  "title": "Category Id",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Title of the category",
                  "title": "Title"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category sys_id",
                  "title": "Parent"
                },
                "icon": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Icon for the category",
                  "title": "Icon"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the category is active",
                  "title": "Active"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Order of the category",
                  "title": "Order"
                }
              },
              "required": [
                "category_id"
              ],
              "title": "UpdateCatalogCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "move_catalog_items",
        "description": "Move catalog items to a different category.",
        "inputSchema": {
          "$defs": {
            "MoveCatalogItemsParams": {
              "description": "Parameters for moving catalog items between categories.",
              "properties": {
                "item_ids": {
                  "description": "List of catalog item IDs to move",
                  "items": {
                    "type": "string"
                  },
                  "title": "Item Ids",
                  "type": "array"
                },
                "target_category_id": {
                  "description": "Target category ID to move items to",
                  "title": "Target Category Id",
                  "type": "string"
                }
              },
              "required": [
                "item_ids",
                "target_category_id"
              ],
              "title": "MoveCatalogItemsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/MoveCatalogItemsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "move_catalog_itemsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_optimization_recommendations",
        "description": "Get optimization recommendations for the service catalog.",
        "inputSchema": {
          "$defs": {
            "OptimizationRecommendationsParams": {
              "properties": {
                "recommendation_types": {
                  "items": {
                    "type": "string"
                  },
                  "title": "Recommendation Types",
                  "type": "array"
                },
                "category_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Category Id"
                }
              },
              "required": [
                "recommendation_types"
              ],
              "title": "OptimizationRecommendationsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/OptimizationRecommendationsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_optimization_recommendationsArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_item",
        "description": "Update a service catalog item.",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogItemParams": {
              "properties": {
                "item_id": {
                  "title": "Item Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Name"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Description"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Category"
                },
                "price": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Price"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Active"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Order"
                }
              },
              "required": [
                "item_id"
              ],
              "title": "UpdateCatalogItemParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogItemParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_itemArguments",
          "type": "object"
        }
      },
      {
        "name": "create_catalog_item_variable",
        "description": "Create a new catalog item variable",
        "inputSchema": {
          "$defs": {
            "CreateCatalogItemVariableParams": {
              "description": "Parameters for creating a catalog item variable.",
              "properties": {
                "catalog_item_id": {
                  "description": "The sys_id of the catalog item",
                  "title": "Catalog Item Id",
                  "type": "string"
                },
                "name": {
                  "description": "The name of the variable (internal name)",
                  "title": "Name",
                  "type": "string"
                },
                "type": {
                  "description": "The type of variable (e.g., string, integer, boolean, reference)",
                  "title": "Type",
                  "type": "string"
                },
                "label": {
                  "description": "The display label for the variable",
                  "title": "Label",
                  "type": "string"
                },
                "mandatory": {
                  "default": false,
                  "description": "Whether the variable is required",
                  "title": "Mandatory",
                  "type": "boolean"
                },
                "help_text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Help text to display with the variable",
                  "title": "Help Text"
                },
                "default_value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Default value for the variable",
                  "title": "Default Value"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the variable",
                  "title": "Description"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Display order of the variable",
                  "title": "Order"
                },
                "reference_table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the table to reference",
                  "title": "Reference Table"
                },
                "reference_qualifier": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the query to filter reference options",
                  "title": "Reference Qualifier"
                },
                "max_length": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum length for string fields",
                  "title": "Max Length"
                },
                "min": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Minimum value for numeric fields",
                  "title": "Min"
                },
                "max": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum value for numeric fields",
                  "title": "Max"
                }
              },
              "required": [
                "catalog_item_id",
                "name",
                "type",
                "label"
              ],
              "title": "CreateCatalogItemVariableParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCatalogItemVariableParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_catalog_item_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "list_catalog_item_variables",
        "description": "List catalog item variables",
        "inputSchema": {
          "$defs": {
            "ListCatalogItemVariablesParams": {
              "description": "Parameters for listing catalog item variables.",
              "properties": {
                "catalog_item_id": {
                  "description": "The sys_id of the catalog item",
                  "title": "Catalog Item Id",
                  "type": "string"
                },
                "include_details": {
                  "default": true,
                  "description": "Whether to include detailed information about each variable",
                  "title": "Include Details",
                  "type": "boolean"
                },
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum number of variables to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Offset for pagination",
                  "title": "Offset"
                }
              },
              "required": [
                "catalog_item_id"
              ],
              "title": "ListCatalogItemVariablesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCatalogItemVariablesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_catalog_item_variablesArguments",
          "type": "object"
        }
      },
      {
        "name": "update_catalog_item_variable",
        "description": "Update a catalog item variable",
        "inputSchema": {
          "$defs": {
            "UpdateCatalogItemVariableParams": {
              "description": "Parameters for updating a catalog item variable.",
              "properties": {
                "variable_id": {
                  "description": "The sys_id of the variable to update",
                  "title": "Variable Id",
                  "type": "string"
                },
                "label": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The display label for the variable",
                  "title": "Label"
                },
                "mandatory": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the variable is required",
                  "title": "Mandatory"
                },
                "help_text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Help text to display with the variable",
                  "title": "Help Text"
                },
                "default_value": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Default value for the variable",
                  "title": "Default Value"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the variable",
                  "title": "Description"
                },
                "order": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Display order of the variable",
                  "title": "Order"
                },
                "reference_qualifier": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "For reference fields, the query to filter reference options",
                  "title": "Reference Qualifier"
                },
                "max_length": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum length for string fields",
                  "title": "Max Length"
                },
                "min": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Minimum value for numeric fields",
                  "title": "Min"
                },
                "max": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Maximum value for numeric fields",
                  "title": "Max"
                }
              },
              "required": [
                "variable_id"
              ],
              "title": "UpdateCatalogItemVariableParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateCatalogItemVariableParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_catalog_item_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "create_change_request",
        "description": "Create a new change request in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateChangeRequestParams": {
              "description": "Parameters for creating a change request.",
              "properties": {
                "short_description": {
                  "description": "Short description of the change request",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the change request",
                  "title": "Description"
                },
                "type": {
                  "description": "Type of change (normal, standard, emergency)",
                  "title": "Type",
                  "type": "string"
                },
                "risk": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Risk level of the change",
                  "title": "Risk"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the change",
                  "title": "Impact"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the change",
                  "title": "Category"
                },
                "requested_by": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User who requested the change",
                  "title": "Requested By"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the change",
                  "title": "Assignment Group"
                },
                "start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Start Date"
                },
                "end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "End Date"
                }
              },
              "required": [
                "short_description",
                "type"
              ],
              "title": "CreateChangeRequestParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateChangeRequestParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_change_requestArguments",
          "type": "object"
        }
      },
      {
        "name": "update_change_request",
        "description": "Update an existing change request in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateChangeRequestParams": {
              "description": "Parameters for updating a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Short description of the change request",
                  "title": "Short Description"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the change request",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the change request",
                  "title": "State"
                },
                "risk": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Risk level of the change",
                  "title": "Risk"
                },
                "impact": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Impact of the change",
                  "title": "Impact"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Category of the change",
                  "title": "Category"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Group assigned to the change",
                  "title": "Assignment Group"
                },
                "start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Start Date"
                },
                "end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "End Date"
                },
                "work_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Work notes to add to the change request",
                  "title": "Work Notes"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "UpdateChangeRequestParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateChangeRequestParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_change_requestArguments",
          "type": "object"
        }
      },
      {
        "name": "list_change_requests",
        "description": "List change requests from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListChangeRequestsParams": {
              "description": "Parameters for listing change requests.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by state",
                  "title": "State"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by type (normal, standard, emergency)",
                  "title": "Type"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "assignment_group": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by assignment group",
                  "title": "Assignment Group"
                },
                "timeframe": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by timeframe (upcoming, in-progress, completed)",
                  "title": "Timeframe"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListChangeRequestsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListChangeRequestsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_change_requestsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_change_request_details",
        "description": "Get detailed information about a specific change request",
        "inputSchema": {
          "$defs": {
            "GetChangeRequestDetailsParams": {
              "description": "Parameters for getting change request details.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "GetChangeRequestDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetChangeRequestDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_change_request_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "add_change_task",
        "description": "Add a task to a change request",
        "inputSchema": {
          "$defs": {
            "AddChangeTaskParams": {
              "description": "Parameters for adding a task to a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "short_description": {
                  "description": "Short description of the task",
                  "title": "Short Description",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Detailed description of the task",
                  "title": "Description"
                },
                "assigned_to": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User assigned to the task",
                  "title": "Assigned To"
                },
                "planned_start_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned start date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Planned Start Date"
                },
                "planned_end_date": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Planned end date (YYYY-MM-DD HH:MM:SS)",
                  "title": "Planned End Date"
                }
              },
              "required": [
                "change_id",
                "short_description"
              ],
              "title": "AddChangeTaskParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddChangeTaskParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_change_taskArguments",
          "type": "object"
        }
      },
      {
        "name": "submit_change_for_approval",
        "description": "Submit a change request for approval",
        "inputSchema": {
          "$defs": {
            "SubmitChangeForApprovalParams": {
              "description": "Parameters for submitting a change request for approval.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approval_comments": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Comments for the approval request",
                  "title": "Approval Comments"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "SubmitChangeForApprovalParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/SubmitChangeForApprovalParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "submit_change_for_approvalArguments",
          "type": "object"
        }
      },
      {
        "name": "approve_change",
        "description": "Approve a change request",
        "inputSchema": {
          "$defs": {
            "ApproveChangeParams": {
              "description": "Parameters for approving a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approver_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of the approver",
                  "title": "Approver Id"
                },
                "approval_comments": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Comments for the approval",
                  "title": "Approval Comments"
                }
              },
              "required": [
                "change_id"
              ],
              "title": "ApproveChangeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ApproveChangeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "approve_changeArguments",
          "type": "object"
        }
      },
      {
        "name": "reject_change",
        "description": "Reject a change request",
        "inputSchema": {
          "$defs": {
            "RejectChangeParams": {
              "description": "Parameters for rejecting a change request.",
              "properties": {
                "change_id": {
                  "description": "Change request ID or sys_id",
                  "title": "Change Id",
                  "type": "string"
                },
                "approver_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of the approver",
                  "title": "Approver Id"
                },
                "rejection_reason": {
                  "description": "Reason for rejection",
                  "title": "Rejection Reason",
                  "type": "string"
                }
              },
              "required": [
                "change_id",
                "rejection_reason"
              ],
              "title": "RejectChangeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/RejectChangeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "reject_changeArguments",
          "type": "object"
        }
      },
      {
        "name": "list_workflows",
        "description": "List workflows from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListWorkflowsParams": {
              "description": "Parameters for listing workflows.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by name (contains)",
                  "title": "Name"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListWorkflowsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListWorkflowsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_workflowsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_workflow_details",
        "description": "Get detailed information about a specific workflow",
        "inputSchema": {
          "$defs": {
            "GetWorkflowDetailsParams": {
              "description": "Parameters for getting workflow details.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "include_versions": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": false,
                  "description": "Include workflow versions",
                  "title": "Include Versions"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "GetWorkflowDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetWorkflowDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_workflow_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "list_workflow_versions",
        "description": "List workflow versions from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListWorkflowVersionsParams": {
              "description": "Parameters for listing workflow versions.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "ListWorkflowVersionsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListWorkflowVersionsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_workflow_versionsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_workflow_activities",
        "description": "Get activities for a specific workflow",
        "inputSchema": {
          "$defs": {
            "GetWorkflowActivitiesParams": {
              "description": "Parameters for getting workflow activities.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "version": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Specific version to get activities for",
                  "title": "Version"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "GetWorkflowActivitiesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetWorkflowActivitiesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_workflow_activitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_workflow",
        "description": "Create a new workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateWorkflowParams": {
              "description": "Parameters for creating a new workflow.",
              "properties": {
                "name": {
                  "description": "Name of the workflow",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the workflow",
                  "title": "Description"
                },
                "table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Table the workflow applies to",
                  "title": "Table"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the workflow is active",
                  "title": "Active"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the workflow",
                  "title": "Attributes"
                }
              },
              "required": [
                "name"
              ],
              "title": "CreateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "update_workflow",
        "description": "Update an existing workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateWorkflowParams": {
              "description": "Parameters for updating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the workflow",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the workflow",
                  "title": "Description"
                },
                "table": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Table the workflow applies to",
                  "title": "Table"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the workflow is active",
                  "title": "Active"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the workflow",
                  "title": "Attributes"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "UpdateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "activate_workflow",
        "description": "Activate a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ActivateWorkflowParams": {
              "description": "Parameters for activating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "ActivateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ActivateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "activate_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "deactivate_workflow",
        "description": "Deactivate a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "DeactivateWorkflowParams": {
              "description": "Parameters for deactivating a workflow.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                }
              },
              "required": [
                "workflow_id"
              ],
              "title": "DeactivateWorkflowParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeactivateWorkflowParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "deactivate_workflowArguments",
          "type": "object"
        }
      },
      {
        "name": "add_workflow_activity",
        "description": "Add a new activity to a workflow in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddWorkflowActivityParams": {
              "description": "Parameters for adding an activity to a workflow.",
              "properties": {
                "workflow_version_id": {
                  "description": "Workflow version ID",
                  "title": "Workflow Version Id",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the activity",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the activity",
                  "title": "Description"
                },
                "activity_type": {
                  "description": "Type of activity (e.g., 'approval', 'task', 'notification')",
                  "title": "Activity Type",
                  "type": "string"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the activity",
                  "title": "Attributes"
                }
              },
              "required": [
                "workflow_version_id",
                "name",
                "activity_type"
              ],
              "title": "AddWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "update_workflow_activity",
        "description": "Update an existing activity in a workflow",
        "inputSchema": {
          "$defs": {
            "UpdateWorkflowActivityParams": {
              "description": "Parameters for updating a workflow activity.",
              "properties": {
                "activity_id": {
                  "description": "Activity ID or sys_id",
                  "title": "Activity Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the activity",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the activity",
                  "title": "Description"
                },
                "attributes": {
                  "anyOf": [
                    {
                      "additionalProperties": true,
                      "type": "object"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional attributes for the activity",
                  "title": "Attributes"
                }
              },
              "required": [
                "activity_id"
              ],
              "title": "UpdateWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_workflow_activity",
        "description": "Delete an activity from a workflow",
        "inputSchema": {
          "$defs": {
            "DeleteWorkflowActivityParams": {
              "description": "Parameters for deleting a workflow activity.",
              "properties": {
                "activity_id": {
                  "description": "Activity ID or sys_id",
                  "title": "Activity Id",
                  "type": "string"
                }
              },
              "required": [
                "activity_id"
              ],
              "title": "DeleteWorkflowActivityParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeleteWorkflowActivityParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "delete_workflow_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "reorder_workflow_activities",
        "description": "Reorder activities in a workflow",
        "inputSchema": {
          "$defs": {
            "ReorderWorkflowActivitiesParams": {
              "description": "Parameters for reordering workflow activities.",
              "properties": {
                "workflow_id": {
                  "description": "Workflow ID or sys_id",
                  "title": "Workflow Id",
                  "type": "string"
                },
                "activity_ids": {
                  "description": "List of activity IDs in the desired order",
                  "items": {
                    "type": "string"
                  },
                  "title": "Activity Ids",
                  "type": "array"
                }
              },
              "required": [
                "workflow_id",
                "activity_ids"
              ],
              "title": "ReorderWorkflowActivitiesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ReorderWorkflowActivitiesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "reorder_workflow_activitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "list_changesets",
        "description": "List changesets from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListChangesetsParams": {
              "description": "Parameters for listing changesets.",
              "properties": {
                "limit": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 10,
                  "description": "Maximum number of records to return",
                  "title": "Limit"
                },
                "offset": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": 0,
                  "description": "Offset to start from",
                  "title": "Offset"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by state",
                  "title": "State"
                },
                "application": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by application",
                  "title": "Application"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by developer",
                  "title": "Developer"
                },
                "timeframe": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by timeframe (recent, last_week, last_month)",
                  "title": "Timeframe"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Additional query string",
                  "title": "Query"
                }
              },
              "title": "ListChangesetsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListChangesetsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_changesetsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_changeset_details",
        "description": "Get detailed information about a specific changeset",
        "inputSchema": {
          "$defs": {
            "GetChangesetDetailsParams": {
              "description": "Parameters for getting changeset details.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "GetChangesetDetailsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetChangesetDetailsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_changeset_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_changeset",
        "description": "Create a new changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateChangesetParams": {
              "description": "Parameters for creating a changeset.",
              "properties": {
                "name": {
                  "description": "Name of the changeset",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the changeset",
                  "title": "Description"
                },
                "application": {
                  "description": "Application the changeset belongs to",
                  "title": "Application",
                  "type": "string"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Developer responsible for the changeset",
                  "title": "Developer"
                }
              },
              "required": [
                "name",
                "application"
              ],
              "title": "CreateChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "update_changeset",
        "description": "Update an existing changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateChangesetParams": {
              "description": "Parameters for updating a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the changeset",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the changeset",
                  "title": "Description"
                },
                "state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "State of the changeset",
                  "title": "State"
                },
                "developer": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Developer responsible for the changeset",
                  "title": "Developer"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "UpdateChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "commit_changeset",
        "description": "Commit a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CommitChangesetParams": {
              "description": "Parameters for committing a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "commit_message": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Commit message",
                  "title": "Commit Message"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "CommitChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CommitChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "commit_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "publish_changeset",
        "description": "Publish a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "PublishChangesetParams": {
              "description": "Parameters for publishing a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "publish_notes": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Notes for publishing",
                  "title": "Publish Notes"
                }
              },
              "required": [
                "changeset_id"
              ],
              "title": "PublishChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/PublishChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "publish_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "add_file_to_changeset",
        "description": "Add a file to a changeset in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddFileToChangesetParams": {
              "description": "Parameters for adding a file to a changeset.",
              "properties": {
                "changeset_id": {
                  "description": "Changeset ID or sys_id",
                  "title": "Changeset Id",
                  "type": "string"
                },
                "file_path": {
                  "description": "Path of the file to add",
                  "title": "File Path",
                  "type": "string"
                },
                "file_content": {
                  "description": "Content of the file",
                  "title": "File Content",
                  "type": "string"
                }
              },
              "required": [
                "changeset_id",
                "file_path",
                "file_content"
              ],
              "title": "AddFileToChangesetParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddFileToChangesetParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_file_to_changesetArguments",
          "type": "object"
        }
      },
      {
        "name": "list_script_includes",
        "description": "List script includes from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListScriptIncludesParams": {
              "description": "Parameters for listing script includes.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of script includes to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "client_callable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by client callable status",
                  "title": "Client Callable"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for script includes",
                  "title": "Query"
                }
              },
              "title": "ListScriptIncludesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListScriptIncludesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_script_includesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_script_include",
        "description": "Get a specific script include from ServiceNow",
        "inputSchema": {
          "$defs": {
            "GetScriptIncludeParams": {
              "description": "Parameters for getting a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "GetScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "create_script_include",
        "description": "Create a new script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateScriptIncludeParams": {
              "description": "Parameters for creating a script include.",
              "properties": {
                "name": {
                  "description": "Name of the script include",
                  "title": "Name",
                  "type": "string"
                },
                "script": {
                  "description": "Script content",
                  "title": "Script",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the script include",
                  "title": "Description"
                },
                "api_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "API name of the script include",
                  "title": "Api Name"
                },
                "client_callable": {
                  "default": false,
                  "description": "Whether the script include is client callable",
                  "title": "Client Callable",
                  "type": "boolean"
                },
                "active": {
                  "default": true,
                  "description": "Whether the script include is active",
                  "title": "Active",
                  "type": "boolean"
                },
                "access": {
                  "default": "package_private",
                  "description": "Access level of the script include",
                  "title": "Access",
                  "type": "string"
                }
              },
              "required": [
                "name",
                "script"
              ],
              "title": "CreateScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "update_script_include",
        "description": "Update an existing script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateScriptIncludeParams": {
              "description": "Parameters for updating a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                },
                "script": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Script content",
                  "title": "Script"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the script include",
                  "title": "Description"
                },
                "api_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "API name of the script include",
                  "title": "Api Name"
                },
                "client_callable": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the script include is client callable",
                  "title": "Client Callable"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the script include is active",
                  "title": "Active"
                },
                "access": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Access level of the script include",
                  "title": "Access"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "UpdateScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_script_include",
        "description": "Delete a script include in ServiceNow",
        "inputSchema": {
          "$defs": {
            "DeleteScriptIncludeParams": {
              "description": "Parameters for deleting a script include.",
              "properties": {
                "script_include_id": {
                  "description": "Script include ID or name",
                  "title": "Script Include Id",
                  "type": "string"
                }
              },
              "required": [
                "script_include_id"
              ],
              "title": "DeleteScriptIncludeParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/DeleteScriptIncludeParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "delete_script_includeArguments",
          "type": "object"
        }
      },
      {
        "name": "create_knowledge_base",
        "description": "Create a new knowledge base in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateKnowledgeBaseParams": {
              "description": "Parameters for creating a knowledge base.",
              "properties": {
                "title": {
                  "description": "Title of the knowledge base",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the knowledge base",
                  "title": "Description"
                },
                "owner": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The specified admin user or group",
                  "title": "Owner"
                },
                "managers": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Users who can manage this knowledge base",
                  "title": "Managers"
                },
                "publish_workflow": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "Knowledge - Instant Publish",
                  "description": "Publication workflow",
                  "title": "Publish Workflow"
                },
                "retire_workflow": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "Knowledge - Instant Retire",
                  "description": "Retirement workflow",
                  "title": "Retire Workflow"
                }
              },
              "required": [
                "title"
              ],
              "title": "CreateKnowledgeBaseParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateKnowledgeBaseParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_knowledge_baseArguments",
          "type": "object"
        }
      },
      {
        "name": "list_knowledge_bases",
        "description": "List knowledge bases from ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListKnowledgeBasesParams": {
              "description": "Parameters for listing knowledge bases.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of knowledge bases to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for knowledge bases",
                  "title": "Query"
                }
              },
              "title": "ListKnowledgeBasesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListKnowledgeBasesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_knowledge_basesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_category",
        "description": "Create a new category in a knowledge base",
        "inputSchema": {
          "$defs": {
            "CreateCategoryParams": {
              "description": "Parameters for creating a category in a knowledge base.",
              "properties": {
                "title": {
                  "description": "Title of the category",
                  "title": "Title",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the category",
                  "title": "Description"
                },
                "knowledge_base": {
                  "description": "The knowledge base to create the category in",
                  "title": "Knowledge Base",
                  "type": "string"
                },
                "parent_category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent category (if creating a subcategory)",
                  "title": "Parent Category"
                },
                "active": {
                  "default": true,
                  "description": "Whether the category is active",
                  "title": "Active",
                  "type": "boolean"
                }
              },
              "required": [
                "title",
                "knowledge_base"
              ],
              "title": "CreateCategoryParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateCategoryParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_categoryArguments",
          "type": "object"
        }
      },
      {
        "name": "create_article",
        "description": "Create a new knowledge article",
        "inputSchema": {
          "$defs": {
            "CreateArticleParams": {
              "description": "Parameters for creating a knowledge article.",
              "properties": {
                "title": {
                  "description": "Title of the article",
                  "title": "Title",
                  "type": "string"
                },
                "text": {
                  "description": "The main body text for the article",
                  "title": "Text",
                  "type": "string"
                },
                "short_description": {
                  "description": "Short description of the article",
                  "title": "Short Description",
                  "type": "string"
                },
                "knowledge_base": {
                  "description": "The knowledge base to create the article in",
                  "title": "Knowledge Base",
                  "type": "string"
                },
                "category": {
                  "description": "Category for the article",
                  "title": "Category",
                  "type": "string"
                },
                "keywords": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Keywords for search",
                  "title": "Keywords"
                },
                "article_type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "text",
                  "description": "The type of article",
                  "title": "Article Type"
                }
              },
              "required": [
                "title",
                "text",
                "short_description",
                "knowledge_base",
                "category"
              ],
              "title": "CreateArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "update_article",
        "description": "Update an existing knowledge article",
        "inputSchema": {
          "$defs": {
            "UpdateArticleParams": {
              "description": "Parameters for updating a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to update",
                  "title": "Article Id",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated title of the article",
                  "title": "Title"
                },
                "text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated main body text for the article",
                  "title": "Text"
                },
                "short_description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated short description",
                  "title": "Short Description"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated category for the article",
                  "title": "Category"
                },
                "keywords": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Updated keywords for search",
                  "title": "Keywords"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "UpdateArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "publish_article",
        "description": "Publish a knowledge article",
        "inputSchema": {
          "$defs": {
            "PublishArticleParams": {
              "description": "Parameters for publishing a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to publish",
                  "title": "Article Id",
                  "type": "string"
                },
                "workflow_state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": "published",
                  "description": "The workflow state to set",
                  "title": "Workflow State"
                },
                "workflow_version": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The workflow version to use",
                  "title": "Workflow Version"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "PublishArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/PublishArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "publish_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "list_articles",
        "description": "List knowledge articles",
        "inputSchema": {
          "$defs": {
            "ListArticlesParams": {
              "description": "Parameters for listing knowledge articles.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of articles to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "knowledge_base": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by knowledge base",
                  "title": "Knowledge Base"
                },
                "category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by category",
                  "title": "Category"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for articles",
                  "title": "Query"
                },
                "workflow_state": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by workflow state",
                  "title": "Workflow State"
                }
              },
              "title": "ListArticlesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListArticlesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_articlesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_article",
        "description": "Get a specific knowledge article by ID",
        "inputSchema": {
          "$defs": {
            "GetArticleParams": {
              "description": "Parameters for getting a knowledge article.",
              "properties": {
                "article_id": {
                  "description": "ID of the article to get",
                  "title": "Article Id",
                  "type": "string"
                }
              },
              "required": [
                "article_id"
              ],
              "title": "GetArticleParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetArticleParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_articleArguments",
          "type": "object"
        }
      },
      {
        "name": "list_categories",
        "description": "List categories in a knowledge base",
        "inputSchema": {
          "$defs": {
            "ListCategoriesParams": {
              "description": "Parameters for listing categories in a knowledge base.",
              "properties": {
                "knowledge_base": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by knowledge base ID",
                  "title": "Knowledge Base"
                },
                "parent_category": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by parent category ID",
                  "title": "Parent Category"
                },
                "limit": {
                  "default": 10,
                  "description": "Maximum number of categories to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Search query for categories",
                  "title": "Query"
                }
              },
              "title": "ListCategoriesParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListCategoriesParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_user",
        "description": "Create a new user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateUserParams": {
              "description": "Parameters for creating a user.",
              "properties": {
                "user_name": {
                  "description": "Username for the user",
                  "title": "User Name",
                  "type": "string"
                },
                "first_name": {
                  "description": "First name of the user",
                  "title": "First Name",
                  "type": "string"
                },
                "last_name": {
                  "description": "Last name of the user",
                  "title": "Last Name",
                  "type": "string"
                },
                "email": {
                  "description": "Email address of the user",
                  "title": "Email",
                  "type": "string"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Job title of the user",
                  "title": "Title"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Department the user belongs to",
                  "title": "Department"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the user (sys_id or username)",
                  "title": "Manager"
                },
                "roles": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Roles to assign to the user",
                  "title": "Roles"
                },
                "phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Phone number of the user",
                  "title": "Phone"
                },
                "mobile_phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Mobile phone number of the user",
                  "title": "Mobile Phone"
                },
                "location": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Location of the user",
                  "title": "Location"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Password for the user account",
                  "title": "Password"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the user account is active",
                  "title": "Active"
                }
              },
              "required": [
                "user_name",
                "first_name",
                "last_name",
                "email"
              ],
              "title": "CreateUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_userArguments",
          "type": "object"
        }
      },
      {
        "name": "update_user",
        "description": "Update an existing user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateUserParams": {
              "description": "Parameters for updating a user.",
              "properties": {
                "user_id": {
                  "description": "User ID or sys_id to update",
                  "title": "User Id",
                  "type": "string"
                },
                "user_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Username for the user",
                  "title": "User Name"
                },
                "first_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "First name of the user",
                  "title": "First Name"
                },
                "last_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Last name of the user",
                  "title": "Last Name"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address of the user",
                  "title": "Email"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Job title of the user",
                  "title": "Title"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Department the user belongs to",
                  "title": "Department"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the user (sys_id or username)",
                  "title": "Manager"
                },
                "roles": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Roles to assign to the user",
                  "title": "Roles"
                },
                "phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Phone number of the user",
                  "title": "Phone"
                },
                "mobile_phone": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Mobile phone number of the user",
                  "title": "Mobile Phone"
                },
                "location": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Location of the user",
                  "title": "Location"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Password for the user account",
                  "title": "Password"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the user account is active",
                  "title": "Active"
                }
              },
              "required": [
                "user_id"
              ],
              "title": "UpdateUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_userArguments",
          "type": "object"
        }
      },
      {
        "name": "get_user",
        "description": "Get a specific user in ServiceNow",
        "inputSchema": {
          "$defs": {
            "GetUserParams": {
              "description": "Parameters for getting a user.",
              "properties": {
                "user_id": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "User ID or sys_id",
                  "title": "User Id"
                },
                "user_name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Username of the user",
                  "title": "User Name"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address of the user",
                  "title": "Email"
                }
              },
              "title": "GetUserParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/GetUserParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "get_userArguments",
          "type": "object"
        }
      },
      {
        "name": "list_users",
        "description": "List users in ServiceNow",
        "inputSchema": {
          "$defs": {
            "ListUsersParams": {
              "description": "Parameters for listing users.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of users to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "department": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by department",
                  "title": "Department"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Case-insensitive search term that matches against name, username, or email fields. Uses ServiceNow's LIKE operator for partial matching.",
                  "title": "Query"
                }
              },
              "title": "ListUsersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListUsersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_usersArguments",
          "type": "object"
        }
      },
      {
        "name": "create_group",
        "description": "Create a new group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "CreateGroupParams": {
              "description": "Parameters for creating a group.",
              "properties": {
                "name": {
                  "description": "Name of the group",
                  "title": "Name",
                  "type": "string"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the group",
                  "title": "Description"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the group (sys_id or username)",
                  "title": "Manager"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent group (sys_id or name)",
                  "title": "Parent"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Type of the group",
                  "title": "Type"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address for the group",
                  "title": "Email"
                },
                "members": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "List of user sys_ids or usernames to add as members",
                  "title": "Members"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": true,
                  "description": "Whether the group is active",
                  "title": "Active"
                }
              },
              "required": [
                "name"
              ],
              "title": "CreateGroupParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/CreateGroupParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "create_groupArguments",
          "type": "object"
        }
      },
      {
        "name": "update_group",
        "description": "Update an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "UpdateGroupParams": {
              "description": "Parameters for updating a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id to update",
                  "title": "Group Id",
                  "type": "string"
                },
                "name": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Name of the group",
                  "title": "Name"
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Description of the group",
                  "title": "Description"
                },
                "manager": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Manager of the group (sys_id or username)",
                  "title": "Manager"
                },
                "parent": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Parent group (sys_id or name)",
                  "title": "Parent"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Type of the group",
                  "title": "Type"
                },
                "email": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Email address for the group",
                  "title": "Email"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Whether the group is active",
                  "title": "Active"
                }
              },
              "required": [
                "group_id"
              ],
              "title": "UpdateGroupParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/UpdateGroupParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "update_groupArguments",
          "type": "object"
        }
      },
      {
        "name": "add_group_members",
        "description": "Add members to an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "AddGroupMembersParams": {
              "description": "Parameters for adding members to a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id",
                  "title": "Group Id",
                  "type": "string"
                },
                "members": {
                  "description": "List of user sys_ids or usernames to add as members",
                  "items": {
                    "type": "string"
                  },
                  "title": "Members",
                  "type": "array"
                }
              },
              "required": [
                "group_id",
                "members"
              ],
              "title": "AddGroupMembersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/AddGroupMembersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "add_group_membersArguments",
          "type": "object"
        }
      },
      {
        "name": "remove_group_members",
        "description": "Remove members from an existing group in ServiceNow",
        "inputSchema": {
          "$defs": {
            "RemoveGroupMembersParams": {
              "description": "Parameters for removing members from a group.",
              "properties": {
                "group_id": {
                  "description": "Group ID or sys_id",
                  "title": "Group Id",
                  "type": "string"
                },
                "members": {
                  "description": "List of user sys_ids or usernames to remove as members",
                  "items": {
                    "type": "string"
                  },
                  "title": "Members",
                  "type": "array"
                }
              },
              "required": [
                "group_id",
                "members"
              ],
              "title": "RemoveGroupMembersParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/RemoveGroupMembersParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "remove_group_membersArguments",
          "type": "object"
        }
      },
      {
        "name": "list_groups",
        "description": "List groups from ServiceNow with optional filtering",
        "inputSchema": {
          "$defs": {
            "ListGroupsParams": {
              "description": "Parameters for listing groups.",
              "properties": {
                "limit": {
                  "default": 10,
                  "description": "Maximum number of groups to return",
                  "title": "Limit",
                  "type": "integer"
                },
                "offset": {
                  "default": 0,
                  "description": "Offset for pagination",
                  "title": "Offset",
                  "type": "integer"
                },
                "active": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by active status",
                  "title": "Active"
                },
                "query": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Case-insensitive search term that matches against group name or description fields. Uses ServiceNow's LIKE operator for partial matching.",
                  "title": "Query"
                },
                "type": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by group type",
                  "title": "Type"
                }
              },
              "title": "ListGroupsParams",
              "type": "object"
            }
          },
          "properties": {
            "params": {
              "$ref": "#/$defs/ListGroupsParams"
            }
          },
          "required": [
            "params"
          ],
          "title": "list_groupsArguments",
          "type": "object"
        }
      }
    ]
  },
  "mcp-compass": {
    "name": "mcp-compass",
    "display_name": "Compass",
    "description": "Suggest the right MCP server for your needs",
    "repository": {
      "type": "git",
      "url": "https://github.com/liuyoshio/mcp-compass"
    },
    "homepage": "https://github.com/liuyoshio/mcp-compass",
    "author": {
      "name": "liuyoshio"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "compass",
      "service discovery"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@liuyoshio/mcp-compass"
        ]
      }
    },
    "tools": [
      {
        "name": "recommend-mcp-servers",
        "description": "\n          Use this tool when there is a need to findn external MCP tools.\n          It explores and recommends existing MCP servers from the \n          internet, based on the description of the MCP Server \n          needed. It returns a list of MCP servers with their IDs, \n          descriptions, GitHub URLs, and similarity scores.\n          ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\n                Description for the MCP Server needed. \n                It should be specific and actionable, e.g.:\n                GOOD:\n                - 'MCP Server for AWS Lambda Python3.9 deployment'\n                - 'MCP Server for United Airlines booking API'\n                - 'MCP Server for Stripe refund webhook handling'\n\n                BAD:\n                - 'MCP Server for cloud' (too vague)\n                - 'MCP Server for booking' (which booking system?)\n                - 'MCP Server for payment' (which payment provider?)\n\n                Query should explicitly specify:\n                1. Target platform/vendor (e.g. AWS, Stripe, MongoDB)\n                2. Exact operation/service (e.g. Lambda deployment, webhook handling)\n                3. Additional context if applicable (e.g. Python, refund events)\n                "
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "alphavantage": {
    "name": "alphavantage",
    "display_name": "Alphavantage",
    "description": "MCP server for stock market data API [AlphaVantage](https://www.alphavantage.co/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/calvernaz/alphavantage"
    },
    "homepage": "https://github.com/calvernaz/alphavantage",
    "author": {
      "name": "calvernaz"
    },
    "license": "Apache-2.0",
    "categories": [
      "Finance"
    ],
    "tags": [
      "alphavantage",
      "stock market"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/calvernaz/alphavantage.git",
          "alphavantage"
        ],
        "env": {
          "ALPHAVANTAGE_API_KEY": "${ALPHAVANTAGE_API_KEY}"
        }
      }
    },
    "arguments": {
      "ALPHAVANTAGE_API_KEY": {
        "description": "The API key to access the Alphavantage service.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "tools": [
      {
        "name": "stock_quote",
        "description": "Fetch a stock quote",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_intraday",
        "description": "Fetch a time series intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "adjusted": {
              "type": "boolean"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "monthly": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "time_series_daily",
        "description": "Fetch a time series daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_daily_adjusted",
        "description": "Fetch a time series daily adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_weekly",
        "description": "Fetch a time series weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_weekly_adjusted",
        "description": "Fetch a time series weekly adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_monthly",
        "description": "Fetch a time series monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "time_series_monthly_adjusted",
        "description": "Fetch a time series monthly adjusted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "realtime_bulk_quotes",
        "description": "Fetch real time bulk quotes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            }
          },
          "required": [
            "symbols"
          ]
        }
      },
      {
        "name": "symbol_search",
        "description": "Search endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "market_status",
        "description": "Fetch market status",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "realtime_options",
        "description": "Fetch realtime options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "contract": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "historical_options",
        "description": "Fetch historical options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "contract": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "news_sentiment",
        "description": "Fetch news sentiment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tickers": {
              "type": "array"
            },
            "topics": {
              "type": "string"
            },
            "time_from": {
              "type": "string"
            },
            "time_to": {
              "type": "string"
            },
            "sort": {
              "type": "string"
            },
            "limit": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "tickers"
          ]
        }
      },
      {
        "name": "top_gainers_losers",
        "description": "Fetch top gainers and losers",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "insider_transactions",
        "description": "Fetch insider transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "analytics_fixed_window",
        "description": "Fetch analytics fixed window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            },
            "interval": {
              "type": "string"
            },
            "series_range": {
              "type": "string"
            },
            "ohlc": {
              "type": "string"
            },
            "calculations": {
              "type": "array"
            }
          },
          "required": [
            "symbols",
            "series_range",
            "interval",
            "calculations"
          ]
        }
      },
      {
        "name": "analytics_sliding_window",
        "description": "Fetch analytics sliding window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array"
            },
            "interval": {
              "type": "string"
            },
            "series_range": {
              "type": "string"
            },
            "ohlc": {
              "type": "string"
            },
            "window_size": {
              "type": "number"
            },
            "calculations": {
              "type": "array"
            }
          },
          "required": [
            "symbols",
            "series_range",
            "interval",
            "calculations",
            "window_size"
          ]
        }
      },
      {
        "name": "company_overview",
        "description": "Fetch company overview",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "etf_profile",
        "description": "Fetch ETF profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "company_dividends",
        "description": "Fetch company dividends",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "company_splits",
        "description": "Fetch company splits",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "income_statement",
        "description": "Fetch company income statement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "balance_sheet",
        "description": "Fetch company balance sheet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "cash_flow",
        "description": "Fetch company cash flow",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "listing_status",
        "description": "Fetch listing status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "date": {
              "type": "string"
            },
            "state": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "earnings_calendar",
        "description": "Fetch company earnings calendar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "horizon": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "ipo_calendar",
        "description": "Fetch IPO calendar",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "exchange_rate",
        "description": "Fetch exchange rate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_currency": {
              "type": "string"
            },
            "to_currency": {
              "type": "string"
            }
          },
          "required": [
            "from_currency",
            "to_currency"
          ]
        }
      },
      {
        "name": "fx_intraday",
        "description": "Fetch FX intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol",
            "interval"
          ]
        }
      },
      {
        "name": "fx_daily",
        "description": "Fetch FX daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "fx_weekly",
        "description": "Fetch FX weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "fx_monthly",
        "description": "Fetch FX monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from_symbol": {
              "type": "string"
            },
            "to_symbol": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "from_symbol",
            "to_symbol"
          ]
        }
      },
      {
        "name": "crypto_intraday",
        "description": "Fetch crypto intraday",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "outputsize": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market",
            "interval"
          ]
        }
      },
      {
        "name": "digital_currency_daily",
        "description": "Fetch digital currency daily",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "digital_currency_weekly",
        "description": "Fetch digital currency weekly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "digital_currency_monthly",
        "description": "Fetch digital currency monthly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "market": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "market"
          ]
        }
      },
      {
        "name": "wti_crude_oil",
        "description": "Fetch WTI crude oil",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "brent_crude_oil",
        "description": "Fetch Brent crude oil",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "natural_gas",
        "description": "Fetch natural gas",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "copper",
        "description": "Fetch copper",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "aluminum",
        "description": "Fetch aluminum",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "wheat",
        "description": "Fetch wheat",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "corn",
        "description": "Fetch corn",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "cotton",
        "description": "Fetch cotton",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "sugar",
        "description": "Fetch sugar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "coffee",
        "description": "Fetch coffee",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "all_commodities",
        "description": "Fetch all commodities",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "real_gdp",
        "description": "Fetch real GDP",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "real_gdp_per_capita",
        "description": "Fetch real GDP per capita",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "treasury_yield",
        "description": "Fetch treasury yield",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "maturity": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "federal_funds_rate",
        "description": "Fetch federal funds rate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "cpi",
        "description": "Fetch consumer price index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "interval": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "inflation",
        "description": "Fetch inflation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "retail_sales",
        "description": "Fetch retail sales",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "durables",
        "description": "Fetch durables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "unemployment",
        "description": "Fetch unemployment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "nonfarm_payroll",
        "description": "Fetch nonfarm payroll",
        "inputSchema": {
          "type": "object",
          "properties": {
            "datatype": {
              "type": "string"
            }
          },
          "required": []
        }
      },
      {
        "name": "sma",
        "description": "Fetch simple moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "ema",
        "description": "Fetch exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "wma",
        "description": "Fetch weighted moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "dema",
        "description": "Fetch double exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "trima",
        "description": "Fetch triangular moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "kama",
        "description": "Fetch Kaufman adaptive moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "mama",
        "description": "Fetch MESA adaptive moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastlimit": {
              "type": "number"
            },
            "slowlimit": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastlimit",
            "slowlimit"
          ]
        }
      },
      {
        "name": "vwap",
        "description": "Fetch volume weighted average price",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "t3",
        "description": "Fetch triple exponential moving average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "macd",
        "description": "Fetch moving average convergence divergence",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "signalperiod": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "macdext",
        "description": "Fetch moving average convergence divergence next",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "signalperiod": {
              "type": "number"
            },
            "fastmatype": {
              "type": "number"
            },
            "slowmatype": {
              "type": "number"
            },
            "signalmatype": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "stoch",
        "description": "Fetch stochastic oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "slowkperiod": {
              "type": "number"
            },
            "slowdperiod": {
              "type": "number"
            },
            "slowkmatype": {
              "type": "string"
            },
            "slowdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "stochf",
        "description": "Fetch stochastic oscillator fast",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "fastdperiod": {
              "type": "number"
            },
            "fastdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "rsi",
        "description": "Fetch relative strength index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "stochrsi",
        "description": "Fetch stochastic relative strength index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "fastkperiod": {
              "type": "number"
            },
            "fastdperiod": {
              "type": "number"
            },
            "fastdmatype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "willr",
        "description": "Fetch williams percent range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "adx",
        "description": "Fetch average directional movement index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "adxr",
        "description": "Fetch average directional movement index rating",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "apo",
        "description": "Fetch absolute price oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "matype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "ppo",
        "description": "Fetch percentage price oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "matype": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "mom",
        "description": "Fetch momentum",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "bop",
        "description": "Fetch balance of power",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "cci",
        "description": "Fetch commodity channel index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "cmo",
        "description": "Fetch chande momentum oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "roc",
        "description": "Fetch rate of change",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "rocr",
        "description": "Fetch rate of change ratio",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "aroon",
        "description": "Fetch aroon",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "aroonosc",
        "description": "Fetch aroon oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "mfi",
        "description": "Fetch money flow index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "trix",
        "description": "Fetch triple exponential average",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "ultosc",
        "description": "Fetch ultimate oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "timeperiod1": {
              "type": "number"
            },
            "timeperiod2": {
              "type": "number"
            },
            "timeperiod3": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "timeperiod1",
            "timeperiod2",
            "timeperiod3"
          ]
        }
      },
      {
        "name": "dx",
        "description": "Fetch directional movement index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "minus_di",
        "description": "Fetch minus directional indicator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "plus_di",
        "description": "Fetch plus directional indicator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "minus_dm",
        "description": "Fetch minus directional movement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "plus_dm",
        "description": "Fetch plus directional movement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "bbands",
        "description": "Fetch bollinger bands",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "nbdevup": {
              "type": "number"
            },
            "nbdevdn": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type",
            "nbdevup",
            "nbdevdn"
          ]
        }
      },
      {
        "name": "midpoint",
        "description": "Fetch midpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period",
            "series_type"
          ]
        }
      },
      {
        "name": "midprice",
        "description": "Fetch midprice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "sar",
        "description": "Fetch parabolic sar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "acceleration": {
              "type": "number"
            },
            "maximum": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "trange",
        "description": "Fetch true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "atr",
        "description": "Fetch average true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "natr",
        "description": "Fetch normalized average true range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "time_period": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "time_period"
          ]
        }
      },
      {
        "name": "ad",
        "description": "Fetch accumulation/distribution line",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "adosc",
        "description": "Fetch accumulation/distribution oscillator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "fastperiod": {
              "type": "number"
            },
            "slowperiod": {
              "type": "number"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "fastperiod",
            "slowperiod"
          ]
        }
      },
      {
        "name": "obv",
        "description": "Fetch on balance volume",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_trendline",
        "description": "Fetch hilbert transform - trendline",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "ht_sine",
        "description": "Fetch hilbert transform - sine wave",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval",
            "series_type"
          ]
        }
      },
      {
        "name": "ht_trendmode",
        "description": "Fetch hilbert transform - trend mode",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_dcperiod",
        "description": "Fetch hilbert transform - dominant cycle period",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "series_type": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_dcphase",
        "description": "Fetch hilbert transform - dominant cycle phase",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "ht_phasor",
        "description": "Fetch hilbert transform - phasor components",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string"
            },
            "interval": {
              "type": "string"
            },
            "month": {
              "type": "string"
            },
            "datatype": {
              "type": "string"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      }
    ]
  },
  "drupal": {
    "name": "drupal",
    "display_name": "Drupal Server",
    "description": "Server for interacting with [Drupal](https://www.drupal.org/project/mcp) using STDIO transport layer.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Omedia/mcp-server-drupal"
    },
    "homepage": "https://github.com/Omedia/mcp-server-drupal",
    "author": {
      "name": "Omedia"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Drupal",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "deno",
          "run",
          "-A",
          "jsr:@omedia/mcp-server-drupal@${VERSION}",
          "--drupal-url",
          "${DRUPAL_BASE_URL}"
        ],
        "env": {}
      }
    },
    "arguments": {
      "VERSION": {
        "description": "The version of the MCP server to be used. This must be provided to ensure compatibility with the installed Drupal version.",
        "required": true,
        "example": "1.0.0"
      },
      "DRUPAL_BASE_URL": {
        "description": "The base URL of the Drupal site that the MCP server will interact with.",
        "required": true,
        "example": "https://example.com"
      }
    }
  },
  "placid-app": {
    "name": "placid-app",
    "display_name": "Placid.app",
    "description": "Generate image and video creatives using Placid.app templates",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/placid-mcp-server"
    },
    "homepage": "https://github.com/felores/placid-mcp-server",
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Placid",
      "Templates",
      "Image Generation",
      "Video Generation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@felores/placid-mcp-server"
        ],
        "env": {
          "PLACID_API_TOKEN": "${PLACID_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Generate Video Example",
        "description": "Example usage for generating a video using Placid templates.",
        "prompt": "{\"template_id\":\"template-uuid\",\"layers\":{\"MEDIA\":{\"video\":\"https://example.com/video.mp4\"},\"PHOTO\":{\"image\":\"https://example.com/photo.jpg\"},\"LOGO\":{\"image\":\"https://example.com/logo.png\"},\"HEADLINE\":{\"text\":\"My Video Title\"}},\"audio\":\"https://example.com/background.mp3\",\"audio_duration\":\"auto\"}"
      },
      {
        "title": "Generate Image Example",
        "description": "Example usage for generating an image using Placid templates.",
        "prompt": "{\"template_id\":\"template-uuid\",\"layers\":{\"headline\":{\"text\":\"Welcome to My App\"},\"background\":{\"image\":\"https://example.com/bg.jpg\"}}}"
      }
    ],
    "arguments": {
      "PLACID_API_TOKEN": {
        "description": "Your Placid API token used for authenticating requests to the Placid API.",
        "required": true,
        "example": "my-secret-api-token"
      }
    },
    "tools": [
      {
        "name": "placid_list_templates",
        "description": "Get a list of available Placid templates with optional filtering. Each template includes its title, ID, preview image URL, available layers, and tags.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection_id": {
              "type": "string",
              "description": "Optional: Filter templates by collection ID"
            },
            "custom_data": {
              "type": "string",
              "description": "Optional: Filter by custom reference data"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Filter templates by tags"
            }
          }
        }
      },
      {
        "name": "placid_generate_image",
        "description": "Generate an image using a template and provided assets",
        "inputSchema": {
          "type": "object",
          "required": [
            "template_id",
            "layers"
          ],
          "properties": {
            "template_id": {
              "type": "string",
              "description": "UUID of the template to use"
            },
            "layers": {
              "type": "object",
              "description": "Key-value pairs for dynamic content. Keys must match template layer names.",
              "additionalProperties": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "text": {
                        "type": "string",
                        "description": "Content for text layers"
                      }
                    },
                    "required": [
                      "text"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "image": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for image/video layers"
                      }
                    },
                    "required": [
                      "image"
                    ]
                  }
                ]
              }
            }
          }
        }
      },
      {
        "name": "placid_generate_video",
        "description": "Generate a video using one or more templates and provided assets. Every 10 seconds of video uses 10 credits.",
        "inputSchema": {
          "type": "object",
          "required": [
            "template_id",
            "layers"
          ],
          "properties": {
            "template_id": {
              "type": "string",
              "description": "UUID of the template to use"
            },
            "layers": {
              "type": "object",
              "description": "Key-value pairs for dynamic content. Keys must match template layer names.",
              "additionalProperties": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "text": {
                        "type": "string",
                        "description": "Content for text layers"
                      }
                    },
                    "required": [
                      "text"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "image": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for image layers"
                      }
                    },
                    "required": [
                      "image"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "video": {
                        "type": "string",
                        "format": "uri",
                        "description": "URL for video layers (.mp4)"
                      }
                    },
                    "required": [
                      "video"
                    ]
                  }
                ]
              }
            },
            "audio": {
              "type": "string",
              "description": "URL of mp3 audio file for this video"
            },
            "audio_duration": {
              "type": "string",
              "description": "Set to 'auto' to trim audio to video length"
            },
            "audio_trim_start": {
              "type": "string",
              "description": "Timestamp of the trim start point (e.g. '00:00:45' or '00:00:45.25')"
            },
            "audio_trim_end": {
              "type": "string",
              "description": "Timestamp of the trim end point (e.g. '00:00:55' or '00:00:55.25')"
            }
          }
        }
      }
    ]
  },
  "siri-shortcuts": {
    "name": "siri-shortcuts",
    "display_name": "Siri Shortcuts",
    "description": "MCP to interact with Siri Shortcuts on macOS. Exposes all Shortcuts as MCP tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dvcrn/mcp-server-siri-shortcuts"
    },
    "homepage": "https://github.com/dvcrn/mcp-server-siri-shortcuts",
    "author": {
      "name": "dvcrn"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "siri",
      "shortcuts",
      "automation"
    ],
    "examples": [
      {
        "title": "List all shortcuts",
        "description": "Fetches all available Siri shortcuts",
        "prompt": "list_shortcuts"
      },
      {
        "title": "Run a specific shortcut",
        "description": "Execute a shortcut with optional input",
        "prompt": "run_shortcut_My_Shortcut_1"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "mcp-server-siri-shortcuts"
        ]
      }
    },
    "tools": [
      {
        "name": "list_shortcuts",
        "description": "List all available Siri shortcuts",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "open_shortcut",
        "description": "Open a shortcut in the Shortcuts app",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the shortcut to open"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "run_shortcut",
        "description": "Run a shortcut with optional input and output parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name or identifier of the shortcut to run"
            },
            "input": {
              "type": "string",
              "description": "The input to pass to the shortcut. Can be text, or a filepath"
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  "windows-cli": {
    "name": "windows-cli",
    "display_name": "Windows CLI",
    "description": "MCP server for secure command-line interactions on Windows systems, enabling controlled access to PowerShell, CMD, and Git Bash shells.",
    "repository": {
      "type": "git",
      "url": "https://github.com/SimonB97/win-cli-mcp-server"
    },
    "homepage": "https://github.com/SimonB97/win-cli-mcp-server",
    "author": {
      "name": "SimonB97"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "CLI",
      "Windows",
      "Security",
      "SSH"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@simonb97/server-win-cli",
          "--config",
          "${config}"
        ]
      }
    },
    "examples": [
      {
        "title": "Usage with Claude Desktop",
        "description": "Add MCP server configuration to Claude Desktop.",
        "prompt": "\n{\n  \"mcpServers\": {\n    \"windows-cli\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@simonb97/server-win-cli\"]\n    }\n  }\n}\n"
      }
    ],
    "arguments": {
      "config": {
        "description": "The path to your configuration file, which customizes the server behavior.",
        "required": true,
        "example": "path/to/your/config.json"
      }
    },
    "tools": [
      {
        "name": "execute_command",
        "description": "Execute a command in the specified shell (powershell, cmd, or gitbash)\n\nExample usage (PowerShell):\n```json\n{\n  \"shell\": \"powershell\",\n  \"command\": \"Get-Process | Select-Object -First 5\",\n  \"workingDir\": \"C:\\Users\\username\"\n}\n```\n\nExample usage (CMD):\n```json\n{\n  \"shell\": \"cmd\",\n  \"command\": \"dir /b\",\n  \"workingDir\": \"C:\\Projects\"\n}\n```\n\nExample usage (Git Bash):\n```json\n{\n  \"shell\": \"gitbash\",\n  \"command\": \"ls -la\",\n  \"workingDir\": \"/c/Users/username\"\n}\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "shell": {
              "type": "string",
              "enum": [
                "powershell",
                "cmd",
                "gitbash"
              ],
              "description": "Shell to use for command execution"
            },
            "command": {
              "type": "string",
              "description": "Command to execute"
            },
            "workingDir": {
              "type": "string",
              "description": "Working directory for command execution (optional)"
            }
          },
          "required": [
            "shell",
            "command"
          ]
        }
      },
      {
        "name": "get_command_history",
        "description": "Get the history of executed commands\n\nExample usage:\n```json\n{\n  \"limit\": 5\n}\n```\n\nExample response:\n```json\n[\n  {\n    \"command\": \"Get-Process\",\n    \"output\": \"...\",\n    \"timestamp\": \"2024-03-20T10:30:00Z\",\n    \"exitCode\": 0\n  }\n]\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of history entries to return (default: 10, max: 1000)"
            }
          }
        }
      },
      {
        "name": "ssh_execute",
        "description": "Execute a command on a remote host via SSH\n\nExample usage:\n```json\n{\n  \"connectionId\": \"raspberry-pi\",\n  \"command\": \"uname -a\"\n}\n```\n\nConfiguration required in config.json:\n```json\n{\n  \"ssh\": {\n    \"enabled\": true,\n    \"connections\": {\n      \"raspberry-pi\": {\n        \"host\": \"raspberrypi.local\",\n        \"port\": 22,\n        \"username\": \"pi\",\n        \"password\": \"raspberry\"\n      }\n    }\n  }\n}\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to use",
              "enum": []
            },
            "command": {
              "type": "string",
              "description": "Command to execute"
            }
          },
          "required": [
            "connectionId",
            "command"
          ]
        }
      },
      {
        "name": "ssh_disconnect",
        "description": "Disconnect from an SSH server\n\nExample usage:\n```json\n{\n  \"connectionId\": \"raspberry-pi\"\n}\n```\n\nUse this to cleanly close SSH connections when they're no longer needed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to disconnect",
              "enum": []
            }
          },
          "required": [
            "connectionId"
          ]
        }
      },
      {
        "name": "create_ssh_connection",
        "description": "Create a new SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection"
            },
            "connectionConfig": {
              "type": "object",
              "properties": {
                "host": {
                  "type": "string",
                  "description": "Host of the SSH connection"
                },
                "port": {
                  "type": "number",
                  "description": "Port of the SSH connection"
                },
                "username": {
                  "type": "string",
                  "description": "Username for the SSH connection"
                },
                "password": {
                  "type": "string",
                  "description": "Password for the SSH connection"
                },
                "privateKeyPath": {
                  "type": "string",
                  "description": "Path to the private key for the SSH connection"
                }
              },
              "required": [
                "connectionId",
                "connectionConfig"
              ]
            }
          }
        }
      },
      {
        "name": "read_ssh_connections",
        "description": "Read all SSH connections",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update_ssh_connection",
        "description": "Update an existing SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to update"
            },
            "connectionConfig": {
              "type": "object",
              "properties": {
                "host": {
                  "type": "string",
                  "description": "Host of the SSH connection"
                },
                "port": {
                  "type": "number",
                  "description": "Port of the SSH connection"
                },
                "username": {
                  "type": "string",
                  "description": "Username for the SSH connection"
                },
                "password": {
                  "type": "string",
                  "description": "Password for the SSH connection"
                },
                "privateKeyPath": {
                  "type": "string",
                  "description": "Path to the private key for the SSH connection"
                }
              },
              "required": [
                "connectionId",
                "connectionConfig"
              ]
            }
          }
        }
      },
      {
        "name": "delete_ssh_connection",
        "description": "Delete an existing SSH connection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connectionId": {
              "type": "string",
              "description": "ID of the SSH connection to delete"
            }
          },
          "required": [
            "connectionId"
          ]
        }
      },
      {
        "name": "get_current_directory",
        "description": "Get the current working directory",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "x-twitter": {
    "name": "x-twitter",
    "display_name": "X (Twitter)",
    "description": "Create, manage and publish X/Twitter posts directly through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/vidhupv/x-mcp"
    },
    "homepage": "https://github.com/vidhupv/x-mcp",
    "author": {
      "name": "vidhupv"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Twitter",
      "X"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/vidhupv/x-mcp",
          "x-mcp"
        ],
        "env": {
          "TWITTER_API_KEY": "${TWITTER_API_KEY}",
          "TWITTER_API_SECRET": "${TWITTER_API_SECRET}",
          "TWITTER_ACCESS_TOKEN": "${TWITTER_ACCESS_TOKEN}",
          "TWITTER_ACCESS_TOKEN_SECRET": "${TWITTER_ACCESS_TOKEN_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Tweet",
        "description": "Example of sending a tweet through Claude chat.",
        "prompt": "Tweet 'Just learned how to tweet through AI - mind blown! \ud83e\udd16\u2728'"
      },
      {
        "title": "Create Thread",
        "description": "Create a thread about a specific topic.",
        "prompt": "Create a thread about the history of pizza"
      },
      {
        "title": "Show Drafts",
        "description": "Request to see draft tweets.",
        "prompt": "Show me my draft tweets"
      },
      {
        "title": "Publish Draft",
        "description": "Publish an existing draft.",
        "prompt": "Publish this draft!"
      },
      {
        "title": "Delete Draft",
        "description": "Delete a specific draft.",
        "prompt": "Delete that draft"
      }
    ],
    "arguments": {
      "TWITTER_API_KEY": {
        "description": "The API key for accessing Twitter's API.",
        "required": true,
        "example": "your_api_key"
      },
      "TWITTER_API_SECRET": {
        "description": "The API secret key for accessing Twitter's API.",
        "required": true,
        "example": "your_api_secret"
      },
      "TWITTER_ACCESS_TOKEN": {
        "description": "The access token for authorizing the application to access Twitter on behalf of the user.",
        "required": true,
        "example": "your_access_token"
      },
      "TWITTER_ACCESS_TOKEN_SECRET": {
        "description": "The access token secret for authorizing the application to access Twitter on behalf of the user.",
        "required": true,
        "example": "your_access_token_secret"
      }
    },
    "tools": [
      {
        "name": "create_draft_tweet",
        "description": "Create a draft tweet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the tweet"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "create_draft_thread",
        "description": "Create a draft tweet thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of tweet contents for the thread"
            }
          },
          "required": [
            "contents"
          ]
        }
      },
      {
        "name": "list_drafts",
        "description": "List all draft tweets and threads",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "publish_draft",
        "description": "Publish a draft tweet or thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draft_id": {
              "type": "string",
              "description": "ID of the draft to publish"
            }
          },
          "required": [
            "draft_id"
          ]
        }
      },
      {
        "name": "delete_draft",
        "description": "Delete a draft tweet or thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draft_id": {
              "type": "string",
              "description": "ID of the draft to delete"
            }
          },
          "required": [
            "draft_id"
          ]
        }
      }
    ]
  },
  "chatmcp": {
    "name": "chatmcp",
    "display_name": "Chat Desktop App",
    "description": "\u2013 An Open Source Cross-platform GUI Desktop application compatible with Linux, macOS, and Windows, enabling seamless interaction with MCP servers across dynamically selectable LLMs, by **[AIQL](https://github.com/AI-QL/chat-mcp)**",
    "repository": {
      "type": "git",
      "url": "https://github.com/AI-QL/chat-mcp"
    },
    "homepage": "https://github.com/AI-QL/chat-mcp",
    "author": {
      "name": "AIQL"
    },
    "license": "Apache-2.0",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "LLM",
      "Electron",
      "cross-platform"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/AI-QL/chat-mcp"
        ],
        "env": {
          "SEARCH_PATH": "${SEARCH_PATH}"
        }
      }
    },
    "arguments": {
      "SEARCH_PATH": {
        "description": "This environment variable specifies the system's executable search path, which determines where the operating system looks for executable files when running commands.",
        "required": false,
        "example": "C:\\Program Files\\nodejs;C:\\Windows\\System32"
      }
    }
  },
  "monday-com": {
    "name": "monday-com",
    "display_name": "Monday.com",
    "description": "MCP Server to interact with Monday.com boards and items.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sakce/mcp-server-monday"
    },
    "homepage": "https://github.com/sakce/mcp-server-monday",
    "author": {
      "name": "sakce"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "monday.com",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-monday"
        ],
        "env": {
          "MONDAY_API_KEY": "${MONDAY_API_KEY}",
          "MONDAY_WORKSPACE_NAME": "${MONDAY_WORKSPACE_NAME}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-e",
          "MONDAY_API_KEY=${MONDAY_API_KEY}",
          "-e",
          "MONDAY_WORKSPACE_NAME=${MONDAY_WORKSPACE_NAME}",
          "sakce/mcp-server-monday"
        ]
      }
    },
    "arguments": {
      "MONDAY_API_KEY": {
        "description": "API key for authenticating with the Monday.com API.",
        "required": true,
        "example": "your-monday-api-key"
      },
      "MONDAY_WORKSPACE_NAME": {
        "description": "The name of the Monday.com workspace you are working with.",
        "required": true,
        "example": "myworkspace"
      }
    },
    "tools": [
      {
        "name": "monday-create-item",
        "description": "Create a new item in a Monday.com Board. Optionally, specify the parent Item ID to create a Sub-item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "itemTitle": {
              "type": "string",
              "description": "Name of the Monday.com Item or Sub-item that will be created."
            },
            "groupId": {
              "type": "string",
              "description": "Monday.com Board's Group ID to create the Item in. If set, parentItemId should not be set."
            },
            "parentItemId": {
              "type": "string",
              "description": "Monday.com Item ID to create the Sub-item under. If set, groupId should not be set."
            },
            "columnValues": {
              "type": "object",
              "description": "Dictionary of column values to set {column_id: value}"
            }
          },
          "required": [
            "boardId",
            "itemTitle"
          ]
        }
      },
      {
        "name": "monday-get-items-by-id",
        "description": "Fetch specific Monday.com item by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to fetch."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-update-item",
        "description": "Update a Monday.com item's or sub-item's column values.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "itemId": {
              "type": "string",
              "description": "Monday.com Item or Sub-item ID to update the columns of."
            },
            "columnValues": {
              "type": "object",
              "description": "Dictionary of column values to update the Monday.com Item or Sub-item with. ({column_id: value})"
            }
          },
          "required": [
            "boardId",
            "itemId",
            "columnValues"
          ]
        }
      },
      {
        "name": "monday-get-board-columns",
        "description": "Get the Columns of a Monday.com Board.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "monday-get-board-groups",
        "description": "Get the Groups of a Monday.com Board.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "monday-create-update",
        "description": "Create an update (comment) on a Monday.com Item or Sub-item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string"
            },
            "updateText": {
              "type": "string",
              "description": "Content to update the Item or Sub-item with."
            }
          },
          "required": [
            "itemId",
            "updateText"
          ]
        }
      },
      {
        "name": "monday-list-boards",
        "description": "Get all Boards from Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of Monday.com Boards to return."
            }
          }
        }
      },
      {
        "name": "monday-list-items-in-groups",
        "description": "List all items in the specified groups of a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the Item or Sub-item is on."
            },
            "groupIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "limit": {
              "type": "integer"
            },
            "cursor": {
              "type": "string"
            }
          },
          "required": [
            "boardId",
            "groupIds",
            "limit"
          ]
        }
      },
      {
        "name": "monday-list-subitems-in-items",
        "description": "List all Sub-items of a list of Monday.com Items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "itemIds"
          ]
        }
      },
      {
        "name": "monday-create-board",
        "description": "Create a new Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "board_name": {
              "type": "string",
              "description": "Name of the Monday.com board to create"
            },
            "board_kind": {
              "type": "string",
              "description": "Kind of the Monday.com board to create (public, private, shareable). Default is public."
            }
          },
          "required": [
            "board_name"
          ]
        }
      },
      {
        "name": "monday-create-board-group",
        "description": "Create a new group in a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Monday.com Board ID that the group will be created in."
            },
            "groupName": {
              "type": "string",
              "description": "Name of the group to create."
            }
          },
          "required": [
            "boardId",
            "groupName"
          ]
        }
      },
      {
        "name": "monday-move-item-to-group",
        "description": "Move an item to a group in a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to move."
            },
            "groupId": {
              "type": "string",
              "description": "Monday.com Group ID to move the Item to."
            }
          },
          "required": [
            "itemId",
            "groupId"
          ]
        }
      },
      {
        "name": "monday-delete-item",
        "description": "Delete an item from a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to delete."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-archive-item",
        "description": "Archive an item from a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Monday.com Item ID to archive."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-item-updates",
        "description": "Get updates for a specific item in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to get updates for."
            },
            "limit": {
              "type": "integer",
              "description": "Maximum number of updates to retrieve. Default is 25."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-docs",
        "description": "Get a list of documents from Monday.com, optionally filtered by folder",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of documents to retrieve. Default is 25."
            },
            "folder_id": {
              "type": "string",
              "description": "Optional folder ID to filter documents by."
            }
          }
        }
      },
      {
        "name": "monday-get-doc-content",
        "description": "Get the content of a specific document by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "doc_id": {
              "type": "string",
              "description": "ID of the Monday.com document to retrieve."
            }
          },
          "required": [
            "doc_id"
          ]
        }
      },
      {
        "name": "monday-create-doc",
        "description": "Create a new document in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title of the document to create."
            },
            "content": {
              "type": "string",
              "description": "Content of the document to create."
            },
            "folder_id": {
              "type": "string",
              "description": "Optional folder ID to create the document in."
            }
          },
          "required": [
            "title",
            "content"
          ]
        }
      },
      {
        "name": "monday-add-doc-block",
        "description": "Add a block to a document",
        "inputSchema": {
          "type": "object",
          "properties": {
            "doc_id": {
              "type": "string",
              "description": "ID of the Monday.com document to add a block to."
            },
            "block_type": {
              "type": "string",
              "description": "Type of block to add (normal_text, bullet_list, numbered_list, heading, divider, etc.)."
            },
            "content": {
              "type": "string",
              "description": "Content of the block to add."
            },
            "after_block_id": {
              "type": "string",
              "description": "Optional ID of the block to add this block after."
            }
          },
          "required": [
            "doc_id",
            "block_type",
            "content"
          ]
        }
      },
      {
        "name": "monday-get-item-files",
        "description": "Get files (PDFs, documents, images, etc.) attached to a Monday.com item",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "ID of the Monday.com item to get files from."
            }
          },
          "required": [
            "itemId"
          ]
        }
      },
      {
        "name": "monday-get-update-files",
        "description": "Get files (PDFs, documents, images, etc.) attached to a specific update in Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "updateId": {
              "type": "string",
              "description": "ID of the Monday.com update to get files from."
            }
          },
          "required": [
            "updateId"
          ]
        }
      }
    ]
  },
  "crypto-feargreed-mcp": {
    "name": "crypto-feargreed-mcp",
    "display_name": "Crypto Fear & Greed Index",
    "description": "Providing real-time and historical Crypto Fear & Greed Index data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/crypto-feargreed-mcp"
    },
    "homepage": "https://github.com/kukapay/crypto-feargreed-mcp",
    "author": {
      "name": "KukaPay",
      "url": "https://github.com/kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Fear & Greed",
      "Crypto Index",
      "Analytics"
    ],
    "examples": [
      {
        "title": "Get Current Index",
        "description": "What is the current Crypto Fear & Greed Index?",
        "prompt": "What's the current Crypto Fear & Greed Index?"
      },
      {
        "title": "Analyze Trend",
        "description": "Show the Fear & Greed Index trend for a specific number of days.",
        "prompt": "Show me the Crypto Fear & Greed Index trend for the last 30 days."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/crypto-feargreed-mcp",
          "main.py"
        ]
      }
    },
    "tools": [
      {
        "name": "get_current_fng_tool",
        "description": "Get the current Fear and Greed Index value.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "get_historical_fng_tool",
        "description": "Get historical Fear and Greed Index data for the specified number of days.",
        "inputSchema": {
          "days": {
            "type": "integer",
            "description": "Number of days for historical data"
          }
        },
        "required": [
          "days"
        ]
      },
      {
        "name": "analyze_fng_trend",
        "description": "Analyze the Fear and Greed Index trend over the specified number of days.",
        "inputSchema": {
          "days": {
            "type": "integer",
            "description": "Number of days for trend analysis"
          }
        },
        "required": [
          "days"
        ]
      }
    ]
  },
  "mcp-local-rag": {
    "name": "mcp-local-rag",
    "display_name": "Local RAG",
    "description": "\"primitive\" RAG-like web search model context protocol (MCP) server that runs locally using Google's MediaPipe Text Embedder and DuckDuckGo Search. \u2728 no APIs required \u2728.",
    "repository": {
      "type": "git",
      "url": "https://github.com/nkapila6/mcp-local-rag"
    },
    "license": "MIT",
    "author": {
      "name": "nkapila6"
    },
    "homepage": "https://github.com/nkapila6/mcp-local-rag",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "RAG",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--python=3.10",
          "--from",
          "git+https://github.com/nkapila6/mcp-local-rag",
          "mcp-local-rag"
        ]
      }
    },
    "tools": [
      {
        "name": "rag_search",
        "description": "\n    Search the web for a given query. Give back context to the LLM\n    with a RAG-like similarity sort.\n\n    Args:\n        query (str): The query to search for.\n        num_results (int): Number of results to return.\n        top_k (int): Use top \"k\" results for content.\n\n    Returns:\n        Dict of strings containing best search based on input query. Formatted in markdown.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "num_results": {
              "default": 10,
              "title": "Num Results",
              "type": "integer"
            },
            "top_k": {
              "default": 5,
              "title": "Top K",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "rag_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "rememberizer-ai": {
    "name": "rememberizer-ai",
    "display_name": "Rememberizer",
    "description": "An MCP server designed for interacting with the Rememberizer data source, facilitating enhanced knowledge retrieval.",
    "repository": {
      "type": "git",
      "url": "https://github.com/skydeckai/mcp-server-rememberizer"
    },
    "homepage": "https://github.com/skydeckai/mcp-server-rememberizer",
    "author": {
      "name": "skydeckai"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Rememberizer",
      "Document Management",
      "Knowledge Management",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-rememberizer"
        ],
        "env": {
          "REMEMBERIZER_API_TOKEN": "${REMEMBERIZER_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "REMEMBERIZER_API_TOKEN": {
        "description": "Your Rememberizer API token, required for accessing the Rememberizer API.",
        "required": true,
        "example": "your_rememberizer_api_token"
      }
    },
    "tools": [
      {
        "name": "rememberizer_account_information",
        "description": "Get information about your Rememberizer.ai personal/team knowledge repository account. This includes account holder name and email address.",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "retrieve_semantically_similar_internal_knowledge",
        "description": "Send a block of text and retrieve cosine similar matches from your connected Rememberizer personal/team internal knowledge and memory repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "match_this": {
              "type": "string",
              "description": "Up to a 400-word sentence for which you wish to find semantically similar chunks of knowledge."
            },
            "n_results": {
              "type": "integer",
              "description": "Number of semantically similar chunks of text to return. Use 'n_results=3' for up to 5, and 'n_results=10' for more information. If you do not receive enough information, consider trying again with a larger 'n_results' value."
            },
            "from_datetime_ISO8601": {
              "type": "string",
              "description": "Start date in ISO 8601 format with timezone (e.g., 2023-01-01T00:00:00Z). Use this to filter results from a specific date."
            },
            "to_datetime_ISO8601": {
              "type": "string",
              "description": "End date in ISO 8601 format with timezone (e.g., 2024-01-01T00:00:00Z). Use this to filter results until a specific date."
            }
          },
          "required": [
            "match_this"
          ]
        }
      },
      {
        "name": "smart_search_internal_knowledge",
        "description": "Search for documents in Rememberizer in its personal/team internal knowledge and memory repository using a simple query that returns the results of an agentic search. The search may include sources such as Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files. Consider using the tool list_internal_knowledge_systems to find out which are available. Use the tool list_internal_knowledge_systems to find out which sources are available. \n\nYou can specify a from_datetime_ISO8601 and a to_datetime_ISO8601, and you should look at the context of your request to make sure you put reasonable parameters around this by, for example, converting a reference to recently to a start date two weeks before today, or converting yesterday to a timeframe during the last day. But do be aware of the effect of time zone differences in the source data and for the requestor.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Up to a 400-word sentence for which you wish to find semantically similar chunks of knowledge."
            },
            "user_context": {
              "type": "string",
              "description": "The additional context for the query. You might need to summarize the conversation up to this point for better context-awared results."
            },
            "n_results": {
              "type": "integer",
              "description": "Number of semantically similar chunks of text to return. Use 'n_results=3' for up to 5, and 'n_results=10' for more information. If you do not receive enough information, consider trying again with a larger 'n_results' value."
            },
            "from_datetime_ISO8601": {
              "type": "string",
              "description": "Start date in ISO 8601 format with timezone (e.g., 2023-01-01T00:00:00Z). Use this to filter results from a specific date."
            },
            "to_datetime_ISO8601": {
              "type": "string",
              "description": "End date in ISO 8601 format with timezone (e.g., 2024-01-01T00:00:00Z). Use this to filter results until a specific date."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_internal_knowledge_systems",
        "description": "List the sources of personal/team internal knowledge. These may include Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files.",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "list_personal_team_knowledge_documents",
        "description": "Retrieves a paginated list of all documents in your personal/team knowledge system. Sources could include Slack discussions, Gmail, Dropbox documents, Google Drive documents, and uploaded files. Consider using the tool list_internal_knowledge_systems to find out which are available. \n\nUse this tool to browse through available documents and their metadata.\n\nExamples:\n- List first 100 documents: {\"page\": 1, \"page_size\": 100}\n- Get next page: {\"page\": 2, \"page_size\": 100}\n- Get maximum allowed documents: {\"page\": 1, \"page_size\": 1000}\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number for pagination (starts at 1)",
              "minimum": 1,
              "default": 1
            },
            "page_size": {
              "type": "integer",
              "description": "Number of documents per page (1-1000)",
              "minimum": 1,
              "maximum": 1000,
              "default": 100
            }
          }
        }
      },
      {
        "name": "remember_this",
        "description": "Save a piece of text information in your Rememberizer.ai knowledge system so that it may be recalled in future through tools retrieve_semantically_similar_internal_knowledge or smart_search_internal_knowledge.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the information. This is used to identify the information in the future."
            },
            "content": {
              "type": "string",
              "description": "The information you wish to memorize."
            }
          }
        }
      }
    ]
  },
  "langflow-doc-qa-server": {
    "name": "langflow-doc-qa-server",
    "display_name": "Langflow Document Q&A",
    "description": "A Model Context Protocol server for document Q&A powered by Langflow. It demonstrates core MCP concepts by providing a simple interface to query documents through a Langflow backend.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER"
    },
    "homepage": "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Langflow",
      "Document Q&A"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/GongRzhe/Langflow-DOC-QA-SERVER"
        ],
        "env": {
          "API_ENDPOINT": "${API_ENDPOINT}"
        }
      }
    },
    "arguments": {
      "API_ENDPOINT": {
        "description": "The endpoint URL for the Langflow API service.",
        "required": false,
        "example": "http://127.0.0.1:7860/api/v1/run/<flow-id>?stream=false"
      }
    },
    "tools": [
      {
        "name": "query_docs",
        "description": "Query the document Q&A system with a prompt",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query prompt to search for in the documents"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "github": {
    "name": "github",
    "display_name": "GitHub",
    "description": "MCP Server for the GitHub API, enabling file operations, repository management, search functionality, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/github#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "github",
      "code",
      "repository",
      "git"
    ],
    "arguments": {
      "GITHUB_PERSONAL_ACCESS_TOKEN": {
        "description": "Personal Access Token for GitHub to authenticate API requests",
        "required": true,
        "example": "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-github"
        ],
        "package": "@modelcontextprotocol/server-github",
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        },
        "description": "Install and run using NPX",
        "recommended": true
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "GITHUB_PERSONAL_ACCESS_TOKEN",
          "mcp/github"
        ],
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        },
        "description": "Run with Docker"
      }
    },
    "examples": [
      {
        "title": "Search GitHub repositories",
        "description": "Find repositories related to machine learning",
        "prompt": "Find GitHub repositories about machine learning with more than 1000 stars."
      },
      {
        "title": "View repository contents",
        "description": "Browse files in a GitHub repository",
        "prompt": "Show me the main Python files in the Hugging Face transformers repository."
      }
    ],
    "tools": [
      {
        "name": "create_or_update_file",
        "description": "Create or update a single file in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "path": {
              "type": "string",
              "description": "Path where to create/update the file"
            },
            "content": {
              "type": "string",
              "description": "Content of the file"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            },
            "branch": {
              "type": "string",
              "description": "Branch to create/update the file in"
            },
            "sha": {
              "type": "string",
              "description": "SHA of the file being replaced (required when updating existing files)"
            }
          },
          "required": [
            "owner",
            "repo",
            "path",
            "content",
            "message",
            "branch"
          ]
        }
      },
      {
        "name": "search_repositories",
        "description": "Search for GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query (see GitHub search syntax)"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination (default: 1)"
            },
            "perPage": {
              "type": "number",
              "description": "Number of results per page (default: 30, max: 100)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_repository",
        "description": "Create a new GitHub repository in your account",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Repository name"
            },
            "description": {
              "type": "string",
              "description": "Repository description"
            },
            "private": {
              "type": "boolean",
              "description": "Whether the repository should be private"
            },
            "autoInit": {
              "type": "boolean",
              "description": "Initialize with README.md"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_file_contents",
        "description": "Get the contents of a file or directory from a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "path": {
              "type": "string",
              "description": "Path to the file or directory"
            },
            "branch": {
              "type": "string",
              "description": "Branch to get contents from"
            }
          },
          "required": [
            "owner",
            "repo",
            "path"
          ]
        }
      },
      {
        "name": "push_files",
        "description": "Push multiple files to a GitHub repository in a single commit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "branch": {
              "type": "string",
              "description": "Branch to push to (e.g., 'main' or 'master')"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string"
                  },
                  "content": {
                    "type": "string"
                  }
                },
                "required": [
                  "path",
                  "content"
                ],
                "additionalProperties": false
              },
              "description": "Array of files to push"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch",
            "files",
            "message"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "Create a new issue in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "body": {
              "type": "string"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "milestone": {
              "type": "number"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "owner",
            "repo",
            "title"
          ]
        }
      },
      {
        "name": "create_pull_request",
        "description": "Create a new pull request in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "title": {
              "type": "string",
              "description": "Pull request title"
            },
            "body": {
              "type": "string",
              "description": "Pull request body/description"
            },
            "head": {
              "type": "string",
              "description": "The name of the branch where your changes are implemented"
            },
            "base": {
              "type": "string",
              "description": "The name of the branch you want the changes pulled into"
            },
            "draft": {
              "type": "boolean",
              "description": "Whether to create the pull request as a draft"
            },
            "maintainer_can_modify": {
              "type": "boolean",
              "description": "Whether maintainers can modify the pull request"
            }
          },
          "required": [
            "owner",
            "repo",
            "title",
            "head",
            "base"
          ]
        }
      },
      {
        "name": "fork_repository",
        "description": "Fork a GitHub repository to your account or specified organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "organization": {
              "type": "string",
              "description": "Optional: organization to fork to (defaults to your personal account)"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "create_branch",
        "description": "Create a new branch in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "branch": {
              "type": "string",
              "description": "Name for the new branch"
            },
            "from_branch": {
              "type": "string",
              "description": "Optional: source branch to create from (defaults to the repository's default branch)"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch"
          ]
        }
      },
      {
        "name": "list_commits",
        "description": "Get list of commits of a branch in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "sha": {
              "type": "string"
            },
            "page": {
              "type": "number"
            },
            "perPage": {
              "type": "number"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "list_issues",
        "description": "List issues in a GitHub repository with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "direction": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "page": {
              "type": "number"
            },
            "per_page": {
              "type": "number"
            },
            "since": {
              "type": "string"
            },
            "sort": {
              "type": "string",
              "enum": [
                "created",
                "updated",
                "comments"
              ]
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed",
                "all"
              ]
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "update_issue",
        "description": "Update an existing issue in a GitHub repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            },
            "title": {
              "type": "string"
            },
            "body": {
              "type": "string"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "milestone": {
              "type": "number"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed"
              ]
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "add_issue_comment",
        "description": "Add a comment to an existing issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            },
            "body": {
              "type": "string"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number",
            "body"
          ]
        }
      },
      {
        "name": "search_code",
        "description": "Search for code across GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "search_issues",
        "description": "Search for issues and pull requests across GitHub repositories",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            },
            "sort": {
              "type": "string",
              "enum": [
                "comments",
                "reactions",
                "reactions-+1",
                "reactions--1",
                "reactions-smile",
                "reactions-thinking_face",
                "reactions-heart",
                "reactions-tada",
                "interactions",
                "created",
                "updated"
              ]
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "search_users",
        "description": "Search for users on GitHub",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "order": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "page": {
              "type": "number",
              "minimum": 1
            },
            "per_page": {
              "type": "number",
              "minimum": 1,
              "maximum": 100
            },
            "sort": {
              "type": "string",
              "enum": [
                "followers",
                "repositories",
                "joined"
              ]
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "get_issue",
        "description": "Get details of a specific issue in a GitHub repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string"
            },
            "repo": {
              "type": "string"
            },
            "issue_number": {
              "type": "number"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "get_pull_request",
        "description": "Get details of a specific pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "list_pull_requests",
        "description": "List and filter repository pull requests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "state": {
              "type": "string",
              "enum": [
                "open",
                "closed",
                "all"
              ],
              "description": "State of the pull requests to return"
            },
            "head": {
              "type": "string",
              "description": "Filter by head user or head organization and branch name"
            },
            "base": {
              "type": "string",
              "description": "Filter by base branch name"
            },
            "sort": {
              "type": "string",
              "enum": [
                "created",
                "updated",
                "popularity",
                "long-running"
              ],
              "description": "What to sort results by"
            },
            "direction": {
              "type": "string",
              "enum": [
                "asc",
                "desc"
              ],
              "description": "The direction of the sort"
            },
            "per_page": {
              "type": "number",
              "description": "Results per page (max 100)"
            },
            "page": {
              "type": "number",
              "description": "Page number of the results"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "create_pull_request_review",
        "description": "Create a review on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "commit_id": {
              "type": "string",
              "description": "The SHA of the commit that needs a review"
            },
            "body": {
              "type": "string",
              "description": "The body text of the review"
            },
            "event": {
              "type": "string",
              "enum": [
                "APPROVE",
                "REQUEST_CHANGES",
                "COMMENT"
              ],
              "description": "The review action to perform"
            },
            "comments": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "The relative path to the file being commented on"
                  },
                  "position": {
                    "type": "number",
                    "description": "The position in the diff where you want to add a review comment"
                  },
                  "body": {
                    "type": "string",
                    "description": "Text of the review comment"
                  }
                },
                "required": [
                  "path",
                  "position",
                  "body"
                ],
                "additionalProperties": false
              },
              "description": "Comments to post as part of the review"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number",
            "body",
            "event"
          ]
        }
      },
      {
        "name": "merge_pull_request",
        "description": "Merge a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "commit_title": {
              "type": "string",
              "description": "Title for the automatic commit message"
            },
            "commit_message": {
              "type": "string",
              "description": "Extra detail to append to automatic commit message"
            },
            "merge_method": {
              "type": "string",
              "enum": [
                "merge",
                "squash",
                "rebase"
              ],
              "description": "Merge method to use"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_files",
        "description": "Get the list of files changed in a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_status",
        "description": "Get the combined status of all status checks for a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "update_pull_request_branch",
        "description": "Update a pull request branch with the latest changes from the base branch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            },
            "expected_head_sha": {
              "type": "string",
              "description": "The expected SHA of the pull request's HEAD ref"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_comments",
        "description": "Get the review comments on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_pull_request_reviews",
        "description": "Get the reviews on a pull request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Repository owner (username or organization)"
            },
            "repo": {
              "type": "string",
              "description": "Repository name"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      }
    ]
  },
  "qgis": {
    "name": "qgis",
    "display_name": "QGIS Model Context Protocol Integration",
    "description": "connects QGIS to Claude AI through the MCP. This integration enables prompt-assisted project creation, layer loading, code execution, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/jjsantos01/qgis_mcp"
    },
    "homepage": "https://github.com/jjsantos01/qgis_mcp",
    "author": {
      "name": "jjsantos01"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "QGIS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/jjsantos01/qgis_mcp",
          "src/qgis_mcp/qgis_mcp_server.py"
        ]
      }
    },
    "examples": [
      {
        "title": "Demo Command Sequence",
        "description": "A series of commands to demonstrate the QGIS MCP integration.",
        "prompt": "1. Ping to check the connection. If it works, continue with the following steps.\n2. Create a new project and save it at: \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx.qgz\"\n3. Load the vector layer: \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx/mgpc_2019.shp\" and name it \"Colonias\".\n4. Load the raster layer: \"C:/Users/USER/GitHub/qgis_mcp/data/09014.tif\" and name it \"BJ\".\n5. Zoom to the \"BJ\" layer.\n6. Execute the centroid algorithm on the \"Colonias\" layer. Skip the geometry check. Save the output to \"colonias_centroids.geojson\".\n7. Execute code to create a choropleth map using the \"POB2010\" field in the \"Colonias\" layer. Use the quantile classification method with 5 classes and the Spectral color ramp.\n8. Render the map to \"C:/Users/USER/GitHub/qgis_mcp/data/cdmx.png\"\n9. Save the project."
      }
    ]
  },
  "openapi": {
    "name": "openapi",
    "display_name": "OpenAPI",
    "description": "Interact with [OpenAPI](https://www.openapis.org/) APIs.",
    "repository": {
      "type": "git",
      "url": "https://github.com/snaggle-ai/openapi-mcp-server"
    },
    "homepage": "https://github.com/snaggle-ai/openapi-mcp-server",
    "author": {
      "name": "snaggle-ai"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "openapi",
      "api exploration"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "openapi-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "Finding information about an API",
        "description": "Ask Claude to find information about specific APIs.",
        "prompt": "Find information about the Stripe API."
      },
      {
        "title": "Explaining API usage",
        "description": "Request explanations on using specific endpoints.",
        "prompt": "Explain how to use the GitHub API's repository endpoints."
      }
    ]
  },
  "salesforce-mcp": {
    "name": "salesforce-mcp",
    "display_name": "Salesforce Connector",
    "description": "Interact with Salesforce Data and Metadata",
    "repository": {
      "type": "git",
      "url": "https://github.com/smn2gnt/MCP-Salesforce"
    },
    "license": "[NOT GIVEN]",
    "author": {
      "name": "smn2gnt"
    },
    "homepage": "https://github.com/smn2gnt/MCP-Salesforce",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "salesforce"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "mcp-salesforce-connector",
          "salesforce"
        ],
        "env": {
          "SALESFORCE_USERNAME": "${SALESFORCE_USERNAME}",
          "SALESFORCE_PASSWORD": "${SALESFORCE_PASSWORD}",
          "SALESFORCE_SECURITY_TOKEN": "${SALESFORCE_SECURITY_TOKEN}"
        }
      }
    },
    "arguments": {
      "SALESFORCE_USERNAME": {
        "description": "Your Salesforce username for authentication",
        "required": true,
        "example": "myemail@example.com"
      },
      "SALESFORCE_PASSWORD": {
        "description": "Your Salesforce password for authentication",
        "required": true
      },
      "SALESFORCE_SECURITY_TOKEN": {
        "description": "Your Salesforce security token for additional security measures",
        "required": true
      }
    },
    "tools": [
      {
        "name": "run_soql_query",
        "description": "Executes a SOQL query against Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SOQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "run_sosl_search",
        "description": "Executes a SOSL search against Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string",
              "description": "The SOSL search to execute (e.g., 'FIND {John Smith} IN ALL FIELDS')"
            }
          },
          "required": [
            "search"
          ]
        }
      },
      {
        "name": "get_object_fields",
        "description": "Retrieves field Names, labels and types for a specific Salesforce object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            }
          },
          "required": [
            "object_name"
          ]
        }
      },
      {
        "name": "get_record",
        "description": "Retrieves a specific record by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to retrieve"
            }
          },
          "required": [
            "object_name",
            "record_id"
          ]
        }
      },
      {
        "name": "create_record",
        "description": "Creates a new record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "data": {
              "type": "object",
              "description": "The data for the new record",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "object_name",
            "data"
          ]
        }
      },
      {
        "name": "update_record",
        "description": "Updates an existing record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to update"
            },
            "data": {
              "type": "object",
              "description": "The updated data for the record",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "object_name",
            "record_id",
            "data"
          ]
        }
      },
      {
        "name": "delete_record",
        "description": "Deletes a record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "object_name": {
              "type": "string",
              "description": "The name of the Salesforce object (e.g., 'Account', 'Contact')"
            },
            "record_id": {
              "type": "string",
              "description": "The ID of the record to delete"
            }
          },
          "required": [
            "object_name",
            "record_id"
          ]
        }
      },
      {
        "name": "tooling_execute",
        "description": "Executes a Tooling API request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The Tooling API endpoint to call (e.g., 'sobjects/ApexClass')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "apex_execute",
        "description": "Executes an Apex REST request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The Apex REST endpoint to call (e.g., '/MyApexClass')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "restful",
        "description": "Makes a direct REST API call to Salesforce",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path of the REST API endpoint (e.g., 'sobjects/Account/describe')"
            },
            "method": {
              "type": "string",
              "description": "The HTTP method (default: 'GET')",
              "enum": [
                "GET",
                "POST",
                "PATCH",
                "DELETE"
              ],
              "default": "GET"
            },
            "params": {
              "type": "object",
              "description": "Query parameters for the request",
              "properties": {},
              "additionalProperties": true
            },
            "data": {
              "type": "object",
              "description": "Data for POST/PATCH requests",
              "properties": {},
              "additionalProperties": true
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "youtube": {
    "name": "youtube",
    "display_name": "YouTube",
    "description": "Comprehensive YouTube API integration for video management, Shorts creation, and analytics.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ZubeidHendricks/youtube-mcp-server"
    },
    "homepage": "https://github.com/ZubeidHendricks/youtube-mcp-server",
    "author": {
      "name": "ZubeidHendricks"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "youtube",
      "video",
      "transcripts",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-youtube"
        ],
        "env": {
          "YOUTUBE_API_KEY": "${YOUTUBE_API_KEY}"
        }
      }
    },
    "arguments": {
      "YOUTUBE_API_KEY": {
        "description": "Your YouTube Data API key, needed for authentication when making requests to the YouTube API.",
        "required": true,
        "example": "AIzaSyD4-1234abcdEFGHijklmnop"
      }
    }
  },
  "scrapling-fetch": {
    "name": "scrapling-fetch",
    "display_name": "Scrapling Fetch",
    "description": "Access text content from bot-protected websites. Fetches HTML/markdown from sites with anti-automation measures using Scrapling.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cyberchitta/scrapling-fetch-mcp"
    },
    "license": "Apache 2",
    "author": {
      "name": "cyberchitta"
    },
    "homepage": "https://github.com/cyberchitta/scrapling-fetch-mcp",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "scrapling",
      "fetch"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "scrapling-fetch-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "s-fetch-page",
        "description": "Fetches a complete web page with pagination support. Retrieves content from websites with bot-detection avoidance. For best performance, start with 'basic' mode (fastest), then only escalate to 'stealth' or 'max-stealth' modes if basic mode fails. Content is returned as 'METADATA: {json}\\n\\n[content]' where metadata includes length information and truncation status.",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "URL to fetch",
              "title": "Url",
              "type": "string"
            },
            "mode": {
              "default": "basic",
              "description": "Fetching mode (basic, stealth, or max-stealth)",
              "title": "Mode",
              "type": "string"
            },
            "format": {
              "default": "markdown",
              "description": "Output format (html or markdown)",
              "title": "Format",
              "type": "string"
            },
            "max_length": {
              "default": 5000,
              "description": "Maximum number of characters to return.",
              "exclusiveMaximum": 1000000,
              "exclusiveMinimum": 0,
              "title": "Max Length",
              "type": "integer"
            },
            "start_index": {
              "default": 0,
              "description": "On return output starting at this character index, useful if a previous fetch was truncated and more content is required.",
              "minimum": 0,
              "title": "Start Index",
              "type": "integer"
            }
          },
          "required": [
            "url"
          ],
          "title": "PageFetchRequest",
          "type": "object"
        }
      },
      {
        "name": "s-fetch-pattern",
        "description": "Extracts content matching regex patterns from web pages. Retrieves specific content from websites with bot-detection avoidance. For best performance, start with 'basic' mode (fastest), then only escalate to 'stealth' or 'max-stealth' modes if basic mode fails. Returns matched content as 'METADATA: {json}\\n\\n[content]' where metadata includes match statistics and truncation information. Each matched content chunk is delimited with '\u0965\u0e5b\u0965' and prefixed with '[Position: start-end]' indicating its byte position in the original document, allowing targeted follow-up requests with s-fetch-page using specific start_index values.",
        "inputSchema": {
          "properties": {
            "url": {
              "description": "URL to fetch",
              "title": "Url",
              "type": "string"
            },
            "mode": {
              "default": "basic",
              "description": "Fetching mode (basic, stealth, or max-stealth)",
              "title": "Mode",
              "type": "string"
            },
            "format": {
              "default": "markdown",
              "description": "Output format (html or markdown)",
              "title": "Format",
              "type": "string"
            },
            "max_length": {
              "default": 5000,
              "description": "Maximum number of characters to return.",
              "exclusiveMaximum": 1000000,
              "exclusiveMinimum": 0,
              "title": "Max Length",
              "type": "integer"
            },
            "search_pattern": {
              "description": "Regular expression pattern to search for in the content",
              "title": "Search Pattern",
              "type": "string"
            },
            "context_chars": {
              "default": 200,
              "description": "Number of characters to include before and after each match",
              "minimum": 0,
              "title": "Context Chars",
              "type": "integer"
            }
          },
          "required": [
            "url",
            "search_pattern"
          ],
          "title": "PatternFetchRequest",
          "type": "object"
        }
      }
    ]
  },
  "holaspirit": {
    "name": "holaspirit",
    "display_name": "Holaspirit",
    "description": "Interact with [Holaspirit](https://www.holaspirit.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/syucream/holaspirit-mcp-server"
    },
    "homepage": "https://github.com/syucream/holaspirit-mcp-server",
    "author": {
      "name": "syucream"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Holaspirit",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "holaspirit-mcp-server"
        ],
        "env": {
          "HOLASPIRIT_API_TOKEN": "${HOLASPIRIT_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "HOLASPIRIT_API_TOKEN": {
        "description": "Your Holaspirit API token",
        "required": true,
        "example": "<your token>"
      }
    },
    "tools": [
      {
        "name": "holaspirit_list_tasks",
        "description": "List all tasks in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_metrics",
        "description": "List all metrics in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_circles",
        "description": "List all circles in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_circle",
        "description": "Get details of a specific circle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "circleId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the circle"
            }
          },
          "required": [
            "organizationId",
            "circleId"
          ]
        }
      },
      {
        "name": "holaspirit_list_roles",
        "description": "List all roles in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_role",
        "description": "Get details of a specific role",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "roleId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the role"
            }
          },
          "required": [
            "organizationId",
            "roleId"
          ]
        }
      },
      {
        "name": "holaspirit_list_domains",
        "description": "List all domains in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_policies",
        "description": "List all policies in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_list_meetings",
        "description": "List all meetings in the organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "page": {
              "type": "number",
              "minimum": 1,
              "description": "Page number"
            },
            "count": {
              "type": "number",
              "minimum": 1,
              "description": "Number of elements per page"
            },
            "circle": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the circle"
            },
            "member": {
              "type": "string",
              "description": "Comma-separated unique identifiers for the member"
            }
          },
          "required": [
            "organizationId"
          ]
        }
      },
      {
        "name": "holaspirit_get_meeting",
        "description": "Get details of a specific meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the organization"
            },
            "meetingId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9-]+$",
              "description": "Unique identifier for the meeting"
            }
          },
          "required": [
            "organizationId",
            "meetingId"
          ]
        }
      }
    ]
  },
  "rag-web-browser": {
    "name": "rag-web-browser",
    "display_name": "RAG Web Browser Server",
    "description": "An MCP server for Apify's open-source RAG Web Browser [Actor](https://apify.com/apify/rag-web-browser) to perform web searches, scrape URLs, and return content in Markdown.",
    "repository": {
      "type": "git",
      "url": "https://github.com/apify/mcp-server-rag-web-browser"
    },
    "homepage": "https://github.com/apify/mcp-server-rag-web-browser",
    "author": {
      "name": "apify"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "RAG",
      "Web Browser",
      "AI Agents"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@apify/mcp-server-rag-web-browser"
        ],
        "env": {
          "APIFY_TOKEN": "${APIFY_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Ask the server to perform a web search for a specific query.",
        "prompt": "What is an MCP server and how can it be used?"
      },
      {
        "title": "Research Papers Query",
        "description": "Find and analyze recent research papers about LLMs.",
        "prompt": "Find and analyze recent research papers about LLMs."
      }
    ],
    "arguments": {
      "APIFY_TOKEN": {
        "description": "Environment variable for your Apify API token to authenticate requests.",
        "required": true,
        "example": "your-apify-api-token"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search phrase or a URL at Google and return crawled web pages as text or Markdown. Prefer HTTP raw client for speed and browser-playwright for reliability.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "pattern": "[^\\s]+",
              "description": "Enter Google Search keywords or a URL of a specific web page. The keywords might include theadvanced search operators. Examples: \"san francisco weather\", \"https://www.cnn.com\", \"function calling site:openai.com\""
            },
            "maxResults": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "minimum": 1,
              "maximum": 100,
              "default": 1,
              "description": "The maximum number of top organic Google Search results whose web pages will be extracted. If query is a URL, then this field is ignored and the Actor only fetches the specific web page."
            },
            "scrapingTool": {
              "type": "string",
              "enum": [
                "browser-playwright",
                "raw-http"
              ],
              "description": "Select a scraping tool for extracting the target web pages. The Browser tool is more powerful and can handle JavaScript heavy websites, while the Plain HTML tool can not handle JavaScript but is about two times faster.",
              "default": "raw-http"
            },
            "outputFormats": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "text",
                  "markdown",
                  "html"
                ]
              },
              "description": "Select one or more formats to which the target web pages will be extracted.",
              "default": [
                "markdown"
              ]
            },
            "requestTimeoutSecs": {
              "type": "integer",
              "minimum": 1,
              "maximum": 300,
              "default": 40,
              "description": "The maximum time in seconds available for the request, including querying Google Search and scraping the target web pages."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "aws-kb-retrieval": {
    "name": "aws-kb-retrieval",
    "display_name": "AWS Knowledge Base Retrieval",
    "description": "Retrieval from AWS Knowledge Base using Bedrock Agent Runtime",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/aws-kb-retrieval-server",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Knowledge Base",
      "Retrieval",
      "AWS",
      "Bedrock Agent Runtime"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-aws-kb-retrieval"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID",
          "-e",
          "AWS_SECRET_ACCESS_KEY",
          "-e",
          "AWS_REGION",
          "mcp/aws-kb-retrieval-server"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_REGION": "${AWS_REGION}"
        }
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "The access key ID for your AWS account used for authentication.",
        "required": true,
        "example": "YOUR_ACCESS_KEY_HERE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "The secret access key for your AWS account used for authentication.",
        "required": true,
        "example": "YOUR_SECRET_ACCESS_KEY_HERE"
      },
      "AWS_REGION": {
        "description": "The AWS region where your resources are located.",
        "required": true,
        "example": "us-east-1"
      }
    },
    "tools": [
      {
        "name": "retrieve_from_aws_kb",
        "description": "Performs retrieval from the AWS Knowledge Base using the provided query and Knowledge Base ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to perform retrieval on"
            },
            "knowledgeBaseId": {
              "type": "string",
              "description": "The ID of the AWS Knowledge Base"
            },
            "n": {
              "type": "number",
              "default": 3,
              "description": "Number of results to retrieve"
            }
          },
          "required": [
            "query",
            "knowledgeBaseId"
          ]
        }
      }
    ]
  },
  "xiyan-mcp-server": {
    "name": "xiyan-mcp-server",
    "display_name": "XiYan MCP Server",
    "description": "An MCP server that supports fetching data from a database using natural language queries, powered by XiyanSQL as the text-to-SQL LLM.",
    "repository": {
      "type": "git",
      "url": "https://github.com/XGenerationLab/xiyan_mcp_server"
    },
    "homepage": "https://github.com/XGenerationLab/xiyan_mcp_server",
    "author": {
      "name": "XGenerationLab"
    },
    "license": "Apache-2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "database",
      "sql",
      "database"
    ],
    "installations": {
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "xiyan_mcp_server"
        ],
        "env": {
          "YML": "${YML}"
        }
      }
    },
    "arguments": {
      "YML": {
        "description": "The path to the YAML configuration file required for setting up the server environment variables.",
        "required": true,
        "example": "path/to/yml"
      }
    },
    "tools": [
      {
        "name": "get_data",
        "description": "Fetch the data from database through a natural language query\n\n    Args:\n        query: The query in natual language\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "get_dataArguments",
          "type": "object"
        }
      }
    ]
  },
  "terminal-control": {
    "name": "terminal-control",
    "display_name": "Terminal Controller",
    "description": "A MCP server that enables secure terminal command execution, directory navigation, and file system operations through a standardized interface.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/terminal-controller-mcp"
    },
    "homepage": "https://github.com/GongRzhe/terminal-controller-mcp",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "terminal",
      "command execution",
      "file management",
      "cross-platform"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "terminal-controller"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "terminal_controller"
        ]
      }
    },
    "examples": [
      {
        "title": "Run Command Example",
        "description": "Run the command `ls -la` in the current directory",
        "prompt": "Run the command `ls -la` in the current directory"
      },
      {
        "title": "Navigate Directory Example",
        "description": "Navigate to my Documents folder",
        "prompt": "Navigate to my Documents folder"
      },
      {
        "title": "Show Downloads Example",
        "description": "Show me the contents of my Downloads directory",
        "prompt": "Show me the contents of my Downloads directory"
      },
      {
        "title": "Recent Commands Example",
        "description": "Show me my recent command history",
        "prompt": "Show me my recent command history"
      }
    ],
    "arguments": {
      "terminal_controller": {
        "description": "The Python module that contains the implementation of the Terminal Controller's functionalities.",
        "required": true,
        "example": "terminal_controller"
      }
    },
    "tools": [
      {
        "name": "execute_command",
        "description": "\n    Execute terminal command and return results\n    \n    Args:\n        command: Command line command to execute\n        timeout: Command timeout in seconds, default is 30 seconds\n    \n    Returns:\n        Output of the command execution\n    ",
        "inputSchema": {
          "properties": {
            "command": {
              "title": "Command",
              "type": "string"
            },
            "timeout": {
              "default": 30,
              "title": "Timeout",
              "type": "integer"
            }
          },
          "required": [
            "command"
          ],
          "title": "execute_commandArguments",
          "type": "object"
        }
      },
      {
        "name": "get_command_history",
        "description": "\n    Get recent command execution history\n    \n    Args:\n        count: Number of recent commands to return\n    \n    Returns:\n        Formatted command history record\n    ",
        "inputSchema": {
          "properties": {
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            }
          },
          "title": "get_command_historyArguments",
          "type": "object"
        }
      },
      {
        "name": "get_current_directory",
        "description": "\n    Get current working directory\n    \n    Returns:\n        Path of current working directory\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_current_directoryArguments",
          "type": "object"
        }
      },
      {
        "name": "change_directory",
        "description": "\n    Change current working directory\n    \n    Args:\n        path: Directory path to switch to\n    \n    Returns:\n        Operation result information\n    ",
        "inputSchema": {
          "properties": {
            "path": {
              "title": "Path",
              "type": "string"
            }
          },
          "required": [
            "path"
          ],
          "title": "change_directoryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_directory",
        "description": "\n    List files and subdirectories in the specified directory\n    \n    Args:\n        path: Directory path to list contents, default is current directory\n    \n    Returns:\n        List of directory contents\n    ",
        "inputSchema": {
          "properties": {
            "path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Path"
            }
          },
          "title": "list_directoryArguments",
          "type": "object"
        }
      }
    ]
  },
  "tavily-search": {
    "name": "tavily-search",
    "display_name": "Tavily Search",
    "description": "An MCP server for Tavily's search & news API, with explicit site inclusions/exclusions",
    "repository": {
      "type": "git",
      "url": "https://github.com/RamXX/mcp-tavily"
    },
    "homepage": "https://github.com/RamXX/mcp-tavily",
    "author": {
      "name": "RamXX"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "AI",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-tavily"
        ],
        "env": {
          "TAVILY_API_KEY": "your_api_key_here"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-tavily"
        ],
        "env": {
          "TAVILY_API_KEY": "your_api_key_here"
        }
      }
    },
    "examples": [
      {
        "title": "Regular Web Search",
        "description": "Perform a standard web search using Tavily's capabilities.",
        "prompt": "Tell me about Anthropic's newly released MCP protocol"
      },
      {
        "title": "Domain Filtering Report",
        "description": "Generate a report filtering specific domains.",
        "prompt": "Tell me about redwood trees. Please use MLA format in markdown syntax and include the URLs in the citations. Exclude Wikipedia sources."
      },
      {
        "title": "Direct Answer Search",
        "description": "Use answer search mode for getting direct answers.",
        "prompt": "I want a concrete answer backed by current web sources: What is the average lifespan of redwood trees?"
      },
      {
        "title": "News Search",
        "description": "Retrieve recent news articles on specific topics.",
        "prompt": "Give me the top 10 AI-related news in the last 5 days."
      }
    ],
    "arguments": {
      "TAVILY_API_KEY": {
        "description": "Your Tavily API key for accessing Tavily's search API functionalities.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "gmail": {
    "name": "gmail",
    "display_name": "Gmail AutoAuth",
    "description": "A Model Context Protocol (MCP) server for Gmail integration in Claude Desktop with auto authentication support.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Gmail-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Gmail-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "gmail",
      "autoauth",
      "claude"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-gmail-autoauth-mcp"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-v",
          "mcp-gmail:/gmail-server",
          "-e",
          "${GMAIL_CREDENTIALS_PATH}=/gmail-server/credentials.json",
          "mcp/gmail"
        ]
      }
    },
    "arguments": {
      "GMAIL_CREDENTIALS_PATH": {
        "description": "The path to the Gmail credentials file that the server will use for OAuth authentication.",
        "required": true,
        "example": "/gmail-server/credentials.json"
      }
    },
    "tools": [
      {
        "name": "send_email",
        "description": "Sends a new email.",
        "inputSchema": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of recipient email addresses"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content"
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of CC recipients",
            "optional": true
          },
          "bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of BCC recipients",
            "optional": true
          }
        },
        "required": [
          "to",
          "subject",
          "body"
        ]
      },
      {
        "name": "draft_email",
        "description": "Draft a new email.",
        "inputSchema": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of recipient email addresses"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content"
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of CC recipients",
            "optional": true
          },
          "bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of BCC recipients",
            "optional": true
          }
        },
        "required": [
          "to",
          "subject",
          "body"
        ]
      },
      {
        "name": "read_email",
        "description": "Retrieves the content of a specific email.",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to retrieve"
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "search_emails",
        "description": "Searches for emails using Gmail search syntax.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Gmail search query (e.g., 'from:example@gmail.com')"
          },
          "maxResults": {
            "type": "number",
            "description": "Maximum number of results to return",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "modify_email",
        "description": "Modifies email labels (move to different folders).",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to modify"
          },
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to apply",
            "optional": true
          },
          "addLabelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to add to the message",
            "optional": true
          },
          "removeLabelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of label IDs to remove from the message",
            "optional": true
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "delete_email",
        "description": "Permanently deletes an email.",
        "inputSchema": {
          "messageId": {
            "type": "string",
            "description": "ID of the email message to delete"
          }
        },
        "required": [
          "messageId"
        ]
      },
      {
        "name": "list_email_labels",
        "description": "Retrieves all available Gmail labels.",
        "inputSchema": {},
        "required": []
      }
    ]
  },
  "kubernetes-and-openshift": {
    "name": "kubernetes-and-openshift",
    "display_name": "Kubernetes and OpenShift",
    "description": "A powerful Kubernetes MCP server with additional support for OpenShift. Besides providing CRUD operations for any Kubernetes resource, this server provides specialized tools to interact with your cluster.",
    "repository": {
      "type": "git",
      "url": "https://github.com/manusa/kubernetes-mcp-server"
    },
    "homepage": "https://github.com/manusa/kubernetes-mcp-server",
    "author": {
      "name": "manusa"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Kubernetes",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "kubernetes-mcp-server@latest"
        ]
      }
    }
  },
  "mysql": {
    "name": "mysql",
    "display_name": "MySQL Database Integration",
    "description": "MySQL database integration in Python with configurable access controls and schema inspection",
    "repository": {
      "type": "git",
      "url": "https://github.com/designcomputer/mysql_mcp_server"
    },
    "homepage": "https://github.com/designcomputer/mysql_mcp_server",
    "author": {
      "name": "designcomputer"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MySQL",
      "Database Access"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mysql_mcp_server"
        ],
        "env": {
          "MYSQL_HOST": "${MYSQL_HOST}",
          "MYSQL_PORT": "${MYSQL_PORT}",
          "MYSQL_USER": "${MYSQL_USER}",
          "MYSQL_PASSWORD": "${MYSQL_PASSWORD}",
          "MYSQL_DATABASE": "${MYSQL_DATABASE}"
        }
      }
    },
    "arguments": {
      "MYSQL_HOST": {
        "description": "Database host",
        "required": true,
        "example": "localhost"
      },
      "MYSQL_PORT": {
        "description": "Database port (defaults to 3306 if not specified)",
        "required": false,
        "example": "3306"
      },
      "MYSQL_USER": {
        "description": "Username for database access",
        "required": true,
        "example": "your_username"
      },
      "MYSQL_PASSWORD": {
        "description": "Password for the database user",
        "required": true,
        "example": "your_password"
      },
      "MYSQL_DATABASE": {
        "description": "Database name to connect to",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the MySQL server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "mindmap": {
    "name": "mindmap",
    "display_name": "Mindmap",
    "description": "A server that generates mindmaps from input containing markdown code.",
    "repository": {
      "type": "git",
      "url": "https://github.com/YuChenSSR/mindmap-mcp-server"
    },
    "homepage": "https://github.com/YuChenSSR/mindmap-mcp-server",
    "author": {
      "name": "YuChenSSR"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "mindmap",
      "markdown",
      "interactive"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mindmap-mcp-server",
          "--return-type",
          "html"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-v",
          "/path/to/output/folder:/output",
          "ychen94/mindmap-converter-mcp:latest"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic Mindmap Generation",
        "description": "Generate a mindmap from Markdown input.",
        "prompt": "give a mindmap for the following markdown code, using a mindmap tool:\n```\n# Project Planning\n## Research\n### Market Analysis\n### Competitor Review\n## Design\n### Wireframes\n### Mockups\n## Development\n### Frontend\n### Backend\n## Testing\n### Unit Tests\n### User Testing\n```\n"
      },
      {
        "title": "Save Mindmap to File",
        "description": "Save the generated mindmap as an HTML file and open it in the browser.",
        "prompt": "give a mindmap for the following markdown input_code using a mindmap tool,\nafter that,use iterm to open the generated html file.\ninput_code:\n```\nmarkdown content\n```\n"
      },
      {
        "title": "Elephant in Refrigerator Mindmap",
        "description": "Create a mindmap about the process of putting an elephant into a refrigerator.",
        "prompt": "Think about the process of putting an elephant into a refrigerator, and provide a mind map. Open it with a terminal."
      }
    ],
    "tools": [
      {
        "name": "convert_markdown_to_mindmap",
        "description": "Convert Markdown content to a mindmap mind map.\n    \n    Args:\n        markdown_content: The Markdown content to convert\n    \n    Returns:\n        Either the HTML content or the file path to the generated HTML, \n        depending on the --return-type server argument\n    ",
        "inputSchema": {
          "properties": {
            "markdown_content": {
              "title": "Markdown Content",
              "type": "string"
            }
          },
          "required": [
            "markdown_content"
          ],
          "title": "convert_markdown_to_mindmapArguments",
          "type": "object"
        }
      }
    ]
  },
  "travel-planner": {
    "name": "travel-planner",
    "display_name": "Travel Planner",
    "description": "Travel planning and itinerary management server integrating with Google Maps API for location search, place details, and route calculations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/TRAVEL-PLANNER-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/TRAVEL-PLANNER-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "google-maps",
      "travel-planning"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-travelplanner-mcp"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Places",
        "description": "Search for places using Google Places API",
        "prompt": "searchPlaces({ query: 'restaurants', location: '34.0522,-118.2437', radius: 5000 });"
      },
      {
        "title": "Get Place Details",
        "description": "Get detailed information about a specific place",
        "prompt": "getPlaceDetails({ placeId: 'ChIJN1t_tDeuEmsRUcIa02j2sDE' });"
      },
      {
        "title": "Calculate Route",
        "description": "Calculate route between two locations",
        "prompt": "calculateRoute({ origin: 'Los Angeles, CA', destination: 'San Francisco, CA', mode: 'driving' });"
      },
      {
        "title": "Get Time Zone",
        "description": "Get timezone information for a location",
        "prompt": "getTimeZone({ location: '34.0522,-118.2437' });"
      }
    ],
    "arguments": {
      "GOOGLE_MAPS_API_KEY": {
        "description": "Your Google Maps API key with the following APIs enabled: Places API, Directions API, Geocoding API, Time Zone API",
        "required": true,
        "example": "your_google_maps_api_key"
      }
    },
    "tools": [
      {
        "name": "create_itinerary",
        "description": "Creates a personalized travel itinerary based on user preferences",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting location"
            },
            "destination": {
              "type": "string",
              "description": "Destination location"
            },
            "startDate": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "endDate": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            },
            "budget": {
              "type": "number",
              "description": "Budget in USD"
            },
            "preferences": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Travel preferences"
            }
          },
          "required": [
            "origin",
            "destination",
            "startDate",
            "endDate"
          ]
        }
      },
      {
        "name": "optimize_itinerary",
        "description": "Optimizes an existing itinerary based on specified criteria",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itineraryId": {
              "type": "string",
              "description": "ID of the itinerary to optimize"
            },
            "optimizationCriteria": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Criteria for optimization (time, cost, etc.)"
            }
          },
          "required": [
            "itineraryId",
            "optimizationCriteria"
          ]
        }
      },
      {
        "name": "search_attractions",
        "description": "Searches for attractions and points of interest in a specified location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search attractions"
            },
            "radius": {
              "type": "number",
              "description": "Search radius in meters"
            },
            "categories": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Categories of attractions"
            }
          },
          "required": [
            "location"
          ]
        }
      },
      {
        "name": "get_transport_options",
        "description": "Retrieves available transportation options between two points",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting point"
            },
            "destination": {
              "type": "string",
              "description": "Destination point"
            },
            "date": {
              "type": "string",
              "description": "Travel date (YYYY-MM-DD)"
            }
          },
          "required": [
            "origin",
            "destination",
            "date"
          ]
        }
      },
      {
        "name": "get_accommodations",
        "description": "Searches for accommodation options in a specified location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search"
            },
            "checkIn": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkOut": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "budget": {
              "type": "number",
              "description": "Maximum price per night"
            }
          },
          "required": [
            "location",
            "checkIn",
            "checkOut"
          ]
        }
      }
    ]
  },
  "postgresql": {
    "name": "postgresql",
    "display_name": "PostgreSQL",
    "description": "Read-only database access with schema inspection",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "PostgreSQL",
      "Database",
      "Read-Only"
    ],
    "author": {
      "name": "modelcontextprotocol"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/postgres",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-postgres",
          "postgresql://localhost/mydb"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/postgres",
          "postgresql://host.docker.internal:5432/mydb"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Run a read-only SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sql": {
              "type": "string"
            }
          }
        }
      }
    ]
  },
  "todoist": {
    "name": "todoist",
    "display_name": "Todoist",
    "description": "Interact with Todoist to manage your tasks.",
    "repository": {
      "type": "git",
      "url": "https://github.com/abhiz123/todoist-mcp-server"
    },
    "homepage": "https://github.com/abhiz123/todoist-mcp-server",
    "author": {
      "name": "abhiz123"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@abhiz123/todoist-mcp-server"
        ],
        "env": {
          "TODOIST_API_TOKEN": "${TODOIST_API_TOKEN}"
        }
      }
    },
    "tags": [
      "task management",
      "todoist",
      "natural language processing"
    ],
    "examples": [
      {
        "title": "Creating Tasks",
        "description": "Example commands for creating tasks",
        "prompt": "\"Create task 'Team Meeting'\""
      },
      {
        "title": "Getting Tasks",
        "description": "Example commands for retrieving tasks",
        "prompt": "\"Show all my tasks\""
      },
      {
        "title": "Updating Tasks",
        "description": "Example commands for updating tasks",
        "prompt": "\"Update documentation task to be due next week\""
      },
      {
        "title": "Completing Tasks",
        "description": "Example commands for completing tasks",
        "prompt": "\"Mark the PR review task as complete\""
      },
      {
        "title": "Deleting Tasks",
        "description": "Example commands for deleting tasks",
        "prompt": "\"Delete the PR review task\""
      }
    ],
    "arguments": {
      "TODOIST_API_TOKEN": {
        "description": "API token to authenticate with the Todoist service",
        "required": true,
        "example": "your_api_token_here"
      }
    },
    "tools": [
      {
        "name": "todoist_create_task",
        "description": "Create a new task in Todoist with optional description, due date, and priority",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content/title of the task"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the task (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "Natural language due date like 'tomorrow', 'next Monday', 'Jan 23' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "Task priority from 1 (normal) to 4 (urgent) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_get_tasks",
        "description": "Get a list of tasks from Todoist with various filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Filter tasks by project ID (optional)"
            },
            "filter": {
              "type": "string",
              "description": "Natural language filter like 'today', 'tomorrow', 'next week', 'priority 1', 'overdue' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "Filter by priority level (1-4) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of tasks to return (optional)",
              "default": 10
            }
          }
        }
      },
      {
        "name": "todoist_update_task",
        "description": "Update an existing task in Todoist by searching for it by name and then updating it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and update"
            },
            "content": {
              "type": "string",
              "description": "New content/title for the task (optional)"
            },
            "description": {
              "type": "string",
              "description": "New description for the task (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "New due date in natural language like 'tomorrow', 'next Monday' (optional)"
            },
            "priority": {
              "type": "number",
              "description": "New priority level from 1 (normal) to 4 (urgent) (optional)",
              "enum": [
                1,
                2,
                3,
                4
              ]
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_delete_task",
        "description": "Delete a task from Todoist by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and delete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_complete_task",
        "description": "Mark a task as complete by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and complete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      }
    ]
  },
  "ntfy-mcp": {
    "name": "ntfy-mcp",
    "display_name": "Your Friendly Task Completion Notifier",
    "description": "The MCP server that keeps you informed by sending the notification on phone using ntfy",
    "repository": {
      "type": "git",
      "url": "https://github.com/teddyzxcv/ntfy-mcp"
    },
    "homepage": "https://github.com/teddyzxcv/ntfy-mcp",
    "author": {
      "name": "teddyzxcv"
    },
    "license": "Apache License 2.0",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "ntfy",
      "notifications"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/teddyzxcv/ntfy-mcp"
        ],
        "env": {
          "NTFY_TOPIC": "${NTFY_TOPIC}"
        }
      }
    },
    "examples": [
      {
        "title": "Python Hello World",
        "description": "Write a prompt to execute a task and receive a notification upon completion.",
        "prompt": "Write me a hello world in python, notify me when the task is done"
      }
    ],
    "arguments": {
      "NTFY_TOPIC": {
        "description": "Environment variable representing the topic name for notifications to be sent to.",
        "required": true,
        "example": "your_topic_name"
      }
    }
  },
  "everart": {
    "name": "everart",
    "display_name": "EverArt",
    "description": "AI image generation using various models",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/everart",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "EverArt",
      "API",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-everart"
        ],
        "env": {
          "EVERART_API_KEY": "${EVERART_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "EVERART_API_KEY",
          "mcp/everart"
        ],
        "env": {
          "EVERART_API_KEY": "${EVERART_API_KEY}"
        }
      }
    },
    "arguments": {
      "EVERART_API_KEY": {
        "description": "API key to access the EverArt API",
        "required": true,
        "example": "your_key_here"
      }
    },
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate images using EverArt Models and returns a clickable link to view the generated image. The tool will return a URL that can be clicked to view the image in a browser. Available models:\n- 5000:FLUX1.1: Standard quality\n- 9000:FLUX1.1-ultra: Ultra high quality\n- 6000:SD3.5: Stable Diffusion 3.5\n- 7000:Recraft-Real: Photorealistic style\n- 8000:Recraft-Vector: Vector art style\n\nThe response will contain a direct link to view the generated image.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Text description of desired image"
            },
            "model": {
              "type": "string",
              "description": "Model ID (5000:FLUX1.1, 9000:FLUX1.1-ultra, 6000:SD3.5, 7000:Recraft-Real, 8000:Recraft-Vector)",
              "default": "5000"
            },
            "image_count": {
              "type": "number",
              "description": "Number of images to generate",
              "default": 1
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "pushover": {
    "name": "pushover",
    "display_name": "Pushover Notifications",
    "description": "Send instant notifications to your devices using [Pushover.net](https://pushover.net/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/ashiknesin/pushover-mcp"
    },
    "homepage": "https://github.com/ashiknesin/pushover-mcp",
    "author": {
      "name": "ashiknesin"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "pushover",
      "notifications"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "pushover-mcp@latest",
          "start",
          "--token",
          "${YOUR_TOKEN}",
          "--user",
          "${YOUR_USER}"
        ]
      }
    },
    "arguments": {
      "YOUR_TOKEN": {
        "description": "Application token required for authenticating with Pushover.net",
        "required": true,
        "example": "abcdef123456"
      },
      "YOUR_USER": {
        "description": "User key associated with your Pushover.net account",
        "required": true,
        "example": "1234567890:abcdef123456"
      }
    },
    "tools": [
      {
        "name": "send",
        "description": "Send a notification via Pushover",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "minLength": 1
            },
            "title": {
              "type": "string"
            },
            "priority": {
              "type": "number",
              "minimum": -2,
              "maximum": 2
            },
            "sound": {
              "type": "string"
            },
            "url": {
              "type": "string",
              "format": "uri"
            },
            "url_title": {
              "type": "string"
            },
            "device": {
              "type": "string"
            }
          },
          "required": [
            "message"
          ]
        }
      }
    ]
  },
  "memory": {
    "name": "memory",
    "display_name": "Knowledge Graph Memory",
    "description": "Knowledge graph-based persistent memory system",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/memory",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "knowledge graph",
      "memory",
      "persistent memory"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-memory"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "-v",
          "claude-memory:/app/dist",
          "--rm",
          "mcp/memory"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic Memory Interaction",
        "description": "A simple interaction with memory where user details are remembered.",
        "prompt": "Remembering..."
      }
    ],
    "arguments": {
      "MEMORY_FILE_PATH": {
        "description": "Path to the memory storage JSON file (default: memory.json in the server directory)",
        "required": false,
        "example": "/path/to/custom/memory.json"
      }
    },
    "tools": [
      {
        "name": "create_entities",
        "description": "Create multiple new entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entities": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The name of the entity"
                  },
                  "entityType": {
                    "type": "string",
                    "description": "The type of the entity"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents associated with the entity"
                  }
                },
                "required": [
                  "name",
                  "entityType",
                  "observations"
                ]
              }
            }
          },
          "required": [
            "entities"
          ]
        }
      },
      {
        "name": "create_relations",
        "description": "Create multiple new relations between entities in the knowledge graph. Relations should be in active voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                },
                "required": [
                  "from",
                  "to",
                  "relationType"
                ]
              }
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "add_observations",
        "description": "Add new observations to existing entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "observations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity to add the observations to"
                  },
                  "contents": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents to add"
                  }
                },
                "required": [
                  "entityName",
                  "contents"
                ]
              }
            }
          },
          "required": [
            "observations"
          ]
        }
      },
      {
        "name": "delete_entities",
        "description": "Delete multiple entities and their associated relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to delete"
            }
          },
          "required": [
            "entityNames"
          ]
        }
      },
      {
        "name": "delete_observations",
        "description": "Delete specific observations from entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deletions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity containing the observations"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observations to delete"
                  }
                },
                "required": [
                  "entityName",
                  "observations"
                ]
              }
            }
          },
          "required": [
            "deletions"
          ]
        }
      },
      {
        "name": "delete_relations",
        "description": "Delete multiple relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                },
                "required": [
                  "from",
                  "to",
                  "relationType"
                ]
              },
              "description": "An array of relations to delete"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "read_graph",
        "description": "Read the entire knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "search_nodes",
        "description": "Search for nodes in the knowledge graph based on a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to match against entity names, types, and observation content"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "open_nodes",
        "description": "Open specific nodes in the knowledge graph by their names",
        "inputSchema": {
          "type": "object",
          "properties": {
            "names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to retrieve"
            }
          },
          "required": [
            "names"
          ]
        }
      }
    ]
  },
  "elevenlabs": {
    "name": "elevenlabs",
    "display_name": "ElevenLabs",
    "description": "A server that integrates with ElevenLabs text-to-speech API capable of generating full voiceovers with multiple voices.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mamertofabian/elevenlabs-mcp-server"
    },
    "homepage": "https://github.com/mamertofabian/elevenlabs-mcp-server",
    "author": {
      "name": "mamertofabian"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "ElevenLabs",
      "Text-to-Speech",
      "SvelteKit",
      "TTS"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "elevenlabs-mcp-server"
        ],
        "env": {
          "ELEVENLABS_API_KEY": "${ELEVENLABS_API_KEY}",
          "ELEVENLABS_VOICE_ID": "${ELEVENLABS_VOICE_ID}",
          "ELEVENLABS_MODEL_ID": "${ELEVENLABS_MODEL_ID}",
          "ELEVENLABS_STABILITY": "${ELEVENLABS_STABILITY}",
          "ELEVENLABS_SIMILARITY_BOOST": "${ELEVENLABS_SIMILARITY_BOOST}",
          "ELEVENLABS_STYLE": "${ELEVENLABS_STYLE}",
          "ELEVENLABS_OUTPUT_DIR": "${ELEVENLABS_OUTPUT_DIR}"
        }
      }
    },
    "arguments": {
      "ELEVENLABS_API_KEY": {
        "description": "Your API key for ElevenLabs to access the text-to-speech services.",
        "required": true,
        "example": "sk-12345abcd"
      },
      "ELEVENLABS_VOICE_ID": {
        "description": "The ID of the voice you want to use for synthesis.",
        "required": true,
        "example": "voice-12345"
      },
      "ELEVENLABS_MODEL_ID": {
        "description": "The model ID to be used, indicating the version of the ElevenLabs API to utilize.",
        "required": false,
        "example": "eleven_flash_v2"
      },
      "ELEVENLABS_STABILITY": {
        "description": "Stability of the voice generation; controls variations in the output voice.",
        "required": false,
        "example": "0.5"
      },
      "ELEVENLABS_SIMILARITY_BOOST": {
        "description": "Boosting similarity for the voices; affects how closely the output mimics the selected voice.",
        "required": false,
        "example": "0.75"
      },
      "ELEVENLABS_STYLE": {
        "description": "Style parameter to adjust the expression in the generated speech.",
        "required": false,
        "example": "0.1"
      },
      "ELEVENLABS_OUTPUT_DIR": {
        "description": "Directory path where the generated audio files will be saved.",
        "required": false,
        "example": "output"
      }
    },
    "tools": [
      {
        "name": "generate_audio_simple",
        "description": "Generate audio from plain text using default voice settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Plain text to convert to audio"
            },
            "voice_id": {
              "type": "string",
              "description": "Optional voice ID to use for generation"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "generate_audio_script",
        "description": "Generate audio from a structured script with multiple voices and actors. \n                    Accepts either:\n                    1. Plain text string\n                    2. JSON string with format: {\n                        \"script\": [\n                            {\n                                \"text\": \"Text to speak\",\n                                \"voice_id\": \"optional-voice-id\",\n                                \"actor\": \"optional-actor-name\"\n                            },\n                            ...\n                        ]\n                    }",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JSON string containing script array or plain text. For JSON format, provide an object with a 'script' array containing objects with 'text' (required), 'voice_id' (optional), and 'actor' (optional) fields."
            }
          },
          "required": [
            "script"
          ]
        }
      },
      {
        "name": "delete_job",
        "description": "Delete a voiceover job and its associated files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "ID of the job to delete"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "get_audio_file",
        "description": "Get the audio file content for a specific job",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "ID of the job to get audio file for"
            }
          },
          "required": [
            "job_id"
          ]
        }
      },
      {
        "name": "list_voices",
        "description": "Get a list of all available ElevenLabs voices with metadata",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_voiceover_history",
        "description": "Get voiceover job history. Optionally specify a job ID for a specific job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "Optional job ID to get details for a specific job"
            }
          },
          "required": []
        }
      }
    ]
  },
  "airbnb": {
    "name": "airbnb",
    "display_name": "Airbnb",
    "description": "Provides tools to search Airbnb and get listing details.",
    "repository": {
      "type": "git",
      "url": "https://github.com/openbnb-org/mcp-server-airbnb"
    },
    "homepage": "https://github.com/openbnb-org/mcp-server-airbnb",
    "author": {
      "name": "openbnb-org"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Airbnb",
      "search",
      "listings"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@openbnb/mcp-server-airbnb"
        ],
        "description": "Run with npx (requires npm install)"
      }
    },
    "examples": [
      {
        "title": "Search for Airbnb Listings",
        "description": "Search for listings in a specified location.",
        "prompt": "Search for listings in New York"
      },
      {
        "title": "Get Listing Details",
        "description": "Retrieve details for a specific listing.",
        "prompt": "Get details for listing 12345"
      }
    ],
    "arguments": {
      "location": {
        "description": "The location where you want to search for Airbnb listings",
        "required": true,
        "example": "New York City"
      },
      "placeId": {
        "description": "The unique identifier for a specific place or location",
        "required": false,
        "example": "ChIJN1t_tDeuEmsRUsoyG83frY4"
      },
      "checkin": {
        "description": "The check-in date for your stay in YYYY-MM-DD format",
        "required": false,
        "example": "2023-10-01"
      },
      "checkout": {
        "description": "The check-out date for your stay in YYYY-MM-DD format",
        "required": false,
        "example": "2023-10-05"
      },
      "adults": {
        "description": "The number of adults staying",
        "required": false,
        "example": "2"
      },
      "children": {
        "description": "The number of children staying",
        "required": false,
        "example": "1"
      },
      "infants": {
        "description": "The number of infants staying",
        "required": false,
        "example": "1"
      },
      "pets": {
        "description": "The number of pets allowed in the listing",
        "required": false,
        "example": "2"
      },
      "minPrice": {
        "description": "The minimum price per night for the listings",
        "required": false,
        "example": "50"
      },
      "maxPrice": {
        "description": "The maximum price per night for the listings",
        "required": false,
        "example": "300"
      },
      "cursor": {
        "description": "A cursor for paginating through results",
        "required": false,
        "example": "next-page-token"
      },
      "ignoreRobotsText": {
        "description": "Set to true to disregard Airbnb's robots.txt rules for all requests",
        "required": false,
        "example": "true"
      }
    },
    "tools": [
      {
        "name": "airbnb_search",
        "description": "Search for Airbnb listings with various filters and pagination. Provide direct links to the user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "location": {
              "type": "string",
              "description": "Location to search for (city, state, etc.)"
            },
            "placeId": {
              "type": "string",
              "description": "Google Maps Place ID (overrides the location parameter)"
            },
            "checkin": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkout": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "adults": {
              "type": "number",
              "description": "Number of adults"
            },
            "children": {
              "type": "number",
              "description": "Number of children"
            },
            "infants": {
              "type": "number",
              "description": "Number of infants"
            },
            "pets": {
              "type": "number",
              "description": "Number of pets"
            },
            "minPrice": {
              "type": "number",
              "description": "Minimum price for the stay"
            },
            "maxPrice": {
              "type": "number",
              "description": "Maximum price for the stay"
            },
            "cursor": {
              "type": "string",
              "description": "Base64-encoded string used for Pagination"
            },
            "ignoreRobotsText": {
              "type": "boolean",
              "description": "Ignore robots.txt rules for this request"
            }
          },
          "required": [
            "location"
          ]
        }
      },
      {
        "name": "airbnb_listing_details",
        "description": "Get detailed information about a specific Airbnb listing. Provide direct links to the user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Airbnb listing ID"
            },
            "checkin": {
              "type": "string",
              "description": "Check-in date (YYYY-MM-DD)"
            },
            "checkout": {
              "type": "string",
              "description": "Check-out date (YYYY-MM-DD)"
            },
            "adults": {
              "type": "number",
              "description": "Number of adults"
            },
            "children": {
              "type": "number",
              "description": "Number of children"
            },
            "infants": {
              "type": "number",
              "description": "Number of infants"
            },
            "pets": {
              "type": "number",
              "description": "Number of pets"
            },
            "ignoreRobotsText": {
              "type": "boolean",
              "description": "Ignore robots.txt rules for this request"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "prometheus": {
    "name": "prometheus",
    "display_name": "Prometheus",
    "description": "Query and analyze Prometheus - open-source monitoring system.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pab1it0/prometheus-mcp-server"
    },
    "homepage": "https://github.com/pab1it0/prometheus-mcp-server",
    "author": {
      "name": "pab1it0"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Prometheus",
      "Metrics",
      "AI"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pab1it0/prometheus-mcp-server",
          "prometheus-mcp-server"
        ],
        "env": {
          "PROMETHEUS_URL": "${PROMETHEUS_URL}",
          "PROMETHEUS_USERNAME": "${PROMETHEUS_USERNAME}",
          "PROMETHEUS_PASSWORD": "${PROMETHEUS_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "Execute Query",
        "description": "Execute a PromQL instant query against Prometheus",
        "prompt": "execute_query({ query: \"up\" })"
      },
      {
        "title": "List Metrics",
        "description": "Get a list of metrics from Prometheus",
        "prompt": "list_metrics()"
      }
    ],
    "arguments": {
      "PROMETHEUS_URL": {
        "description": "The URL of the Prometheus server you want to connect to.",
        "required": true,
        "example": "http://your-prometheus-server:9090"
      },
      "PROMETHEUS_USERNAME": {
        "description": "The username for basic authentication when accessing the Prometheus server.",
        "required": false,
        "example": "your_username"
      },
      "PROMETHEUS_PASSWORD": {
        "description": "The password for basic authentication when accessing the Prometheus server.",
        "required": false,
        "example": "your_password"
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Execute a PromQL instant query against Prometheus",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "time": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Time"
            }
          },
          "required": [
            "query"
          ],
          "title": "execute_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "execute_range_query",
        "description": "Execute a PromQL range query with start time, end time, and step interval",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "start": {
              "title": "Start",
              "type": "string"
            },
            "end": {
              "title": "End",
              "type": "string"
            },
            "step": {
              "title": "Step",
              "type": "string"
            }
          },
          "required": [
            "query",
            "start",
            "end",
            "step"
          ],
          "title": "execute_range_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_metrics",
        "description": "List all available metrics in Prometheus",
        "inputSchema": {
          "properties": {},
          "title": "list_metricsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_metric_metadata",
        "description": "Get metadata for a specific metric",
        "inputSchema": {
          "properties": {
            "metric": {
              "title": "Metric",
              "type": "string"
            }
          },
          "required": [
            "metric"
          ],
          "title": "get_metric_metadataArguments",
          "type": "object"
        }
      },
      {
        "name": "get_targets",
        "description": "Get information about all scrape targets",
        "inputSchema": {
          "properties": {},
          "title": "get_targetsArguments",
          "type": "object"
        }
      }
    ]
  },
  "searxng": {
    "name": "searxng",
    "display_name": "SearXNG",
    "description": "A Model Context Protocol Server for [SearXNG](https://docs.searxng.org/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/ihor-sokoliuk/mcp-searxng"
    },
    "homepage": "https://github.com/ihor-sokoliuk/mcp-searxng",
    "author": {
      "name": "ihor-sokoliuk"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "search",
      "searxng",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ihor-sokoliuk/mcp-searxng"
        ],
        "env": {
          "SEARXNG_URL": "${SEARXNG_URL}"
        }
      }
    },
    "arguments": {
      "SEARXNG_URL": {
        "description": "Environment variable to set the URL of the SearXNG instance that will be used for search queries.",
        "required": true,
        "example": "http://localhost:8080"
      }
    },
    "tools": [
      {
        "name": "searxng_web_search",
        "description": "Execute web searches with pagination.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search terms"
          },
          "count": {
            "type": "number",
            "description": "Results per page (default: 20)",
            "optional": true
          },
          "offset": {
            "type": "number",
            "description": "Pagination offset (default: 0)",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "pinecone": {
    "name": "pinecone",
    "display_name": "Pinecone Model Context Protocol for Claude Desktop",
    "description": "MCP server for searching and uploading records to Pinecone. Allows for simple RAG features, leveraging Pinecone's Inference API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sirmews/mcp-pinecone"
    },
    "homepage": "https://github.com/sirmews/mcp-pinecone",
    "author": {
      "name": "sirmews"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "pinecone"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-pinecone",
          "--index-name",
          "${your-index-name}",
          "--api-key",
          "${your-secret-api-key}"
        ]
      }
    },
    "tools": [
      {
        "name": "semantic_search",
        "description": "Search Pinecone for documents.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "top_k": {
            "type": "integer",
            "description": "Number of top results to return (default: 10)",
            "default": 10
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to search in",
            "optional": true
          },
          "category": {
            "type": "string",
            "description": "Category for search"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags for search"
          },
          "date_range": {
            "type": "object",
            "properties": {
              "start": {
                "type": "string",
                "format": "date",
                "description": "Start date of the range"
              },
              "end": {
                "type": "string",
                "format": "date",
                "description": "End date of the range"
              }
            }
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "read_document",
        "description": "Read a document from Pinecone.",
        "inputSchema": {
          "document_id": {
            "type": "string",
            "description": "ID of the document to read"
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to read from",
            "optional": true
          }
        },
        "required": [
          "document_id"
        ]
      },
      {
        "name": "process_document",
        "description": "Process a document. This will optionally chunk, then embed, and upsert the document into Pinecone.",
        "inputSchema": {
          "document_id": {
            "type": "string",
            "description": "ID of the document to process"
          },
          "text": {
            "type": "string",
            "description": "Text content of the document"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata for the document"
          },
          "namespace": {
            "type": "string",
            "description": "Optional namespace to store the document in",
            "optional": true
          }
        },
        "required": [
          "document_id",
          "text",
          "metadata"
        ]
      },
      {
        "name": "list_documents",
        "description": "List all documents in the knowledge base by namespace.",
        "inputSchema": {
          "namespace": {
            "type": "string",
            "description": "Namespace to list documents in"
          }
        },
        "required": [
          "namespace"
        ]
      },
      {
        "name": "pinecone_stats",
        "description": "Get stats about the Pinecone index specified in this server.",
        "inputSchema": {},
        "required": []
      }
    ]
  },
  "atlassian": {
    "name": "atlassian",
    "display_name": "Atlassian",
    "description": "Interact with Atlassian Cloud products (Confluence and Jira) including searching/reading Confluence spaces/pages, accessing Jira issues, and project metadata.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sooperset/mcp-atlassian"
    },
    "homepage": "https://github.com/sooperset/mcp-atlassian",
    "author": {
      "name": "sooperset"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Atlassian",
      "Confluence",
      "Jira"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ],
        "description": "Run with uvx (requires uv install)"
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ],
        "description": "Run with Python module (requires pip install)"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/atlassian",
          "--confluence-url=${CONFLUENCE_URL}",
          "--confluence-username=${CONFLUENCE_USERNAME}",
          "--confluence-token=${CONFLUENCE_TOKEN}",
          "--jira-url=${JIRA_URL}",
          "--jira-username=${JIRA_USERNAME}",
          "--jira-token=${JIRA_TOKEN}"
        ]
      }
    },
    "arguments": {
      "CONFLUENCE_URL": {
        "description": "The URL of the Confluence site to connect to. Required for both Cloud and Server/Data Center deployments.",
        "required": true,
        "example": "https://your-company.atlassian.net/wiki or https://confluence.your-company.com"
      },
      "CONFLUENCE_USERNAME": {
        "description": "The username for the Confluence account (email for Cloud). Required to authenticate with Confluence.",
        "required": true,
        "example": "your.email@company.com"
      },
      "CONFLUENCE_TOKEN": {
        "description": "The API token or personal access token for the Confluence account. Required for authentication with Confluence.",
        "required": true,
        "example": "your_api_token or your_token"
      },
      "JIRA_URL": {
        "description": "The URL of the Jira site to connect to. Required for both Cloud and Server/Data Center deployments.",
        "required": true,
        "example": "https://your-company.atlassian.net or https://jira.your-company.com"
      },
      "JIRA_USERNAME": {
        "description": "The username for the Jira account (email for Cloud). Required to authenticate with Jira.",
        "required": true,
        "example": "your.email@company.com"
      },
      "JIRA_TOKEN": {
        "description": "The API token or personal access token for the Jira account. Required for authentication with Jira.",
        "required": true,
        "example": "your_api_token or your_token"
      }
    },
    "tools": []
  },
  "open-strategy-partners-marketing-tools": {
    "name": "open-strategy-partners-marketing-tools",
    "display_name": "Open Strategy Partners Marketing Tools",
    "description": "Content editing codes, value map, and positioning tools for product marketing.",
    "repository": {
      "type": "git",
      "url": "https://github.com/open-strategy-partners/osp_marketing_tools"
    },
    "homepage": "https://github.com/open-strategy-partners/osp_marketing_tools",
    "author": {
      "name": "open-strategy-partners"
    },
    "license": "CC-BY-SA-4.0",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "LLM",
      "Technical Writing",
      "Optimization"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/open-strategy-partners/osp_marketing_tools@main",
          "osp_marketing_tools"
        ]
      }
    },
    "examples": [
      {
        "title": "Value Map Generation",
        "description": "Generate an OSP value map for a product with specified features for a target audience.",
        "prompt": "Generate an OSP value map for CloudDeploy, focusing on DevOps engineers with these key features: - Automated deployment pipeline - Infrastructure as code support - Real-time monitoring - Multi-cloud compatibility."
      },
      {
        "title": "Meta Information Creation",
        "description": "Create optimized metadata for an article based on a specific topic and audience.",
        "prompt": "Use the OSP meta tool to generate metadata for an article about containerization best practices. Primary keyword: 'Docker containers', audience: system administrators, content type: technical guide."
      },
      {
        "title": "Content Editing",
        "description": "Review technical content using OSP editing codes for improvements.",
        "prompt": "Review this technical content using OSP editing codes: Kubernetes helps you manage containers. It's really good at what it does. You can use it to deploy your apps and make them run better."
      },
      {
        "title": "Technical Writing",
        "description": "Apply the OSP writing guide to create a document for a specific audience.",
        "prompt": "Apply the OSP writing guide to create a tutorial about setting up a CI/CD pipeline for junior developers."
      }
    ],
    "tools": [
      {
        "name": "health_check",
        "description": "Check if the server is running and can access its resources",
        "inputSchema": {
          "properties": {},
          "title": "health_checkArguments",
          "type": "object"
        }
      },
      {
        "name": "get_editing_codes",
        "description": "Get the Open Strategy Partners (OSP) editing codes documentation and usage protocol for editing texts.",
        "inputSchema": {
          "properties": {},
          "title": "get_editing_codesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_writing_guide",
        "description": "Get the Open Strategy Partners (OSP) writing guide and usage protocol for editing texts.",
        "inputSchema": {
          "properties": {},
          "title": "get_writing_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_meta_guide",
        "description": "Get the Open Strategy Partners (OSP) Web Content Meta Information Generation System (titles, meta-titles, slugs).",
        "inputSchema": {
          "properties": {},
          "title": "get_meta_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_value_map_positioning_guide",
        "description": "Get the Open Strategy Partners (OSP) Product Communications Value Map Generation System for Product Positioning (value cases, feature extraction, taglines).",
        "inputSchema": {
          "properties": {},
          "title": "get_value_map_positioning_guideArguments",
          "type": "object"
        }
      },
      {
        "name": "get_on_page_seo_guide",
        "description": "Get the Open Strategy Partners (OSP) On-Page SEO Optimization Guide.",
        "inputSchema": {
          "properties": {},
          "title": "get_on_page_seo_guideArguments",
          "type": "object"
        }
      }
    ]
  },
  "mongodb-lens": {
    "name": "mongodb-lens",
    "display_name": "MongoDB Lens",
    "description": "Full Featured MCP Server for MongoDB Databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/furey/mongodb-lens"
    },
    "homepage": "https://github.com/furey/mongodb-lens",
    "author": {
      "name": "furey"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "mongodb",
      "server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mongodb-lens@latest",
          "${MONGODB_URI}"
        ],
        "env": {
          "CONFIG_LOG_LEVEL": "${CONFIG_LOG_LEVEL}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "--network=host",
          "--pull=always",
          "-e",
          "CONFIG_LOG_LEVEL='verbose'",
          "furey/mongodb-lens",
          "${MONGODB_URI}"
        ],
        "env": {
          "CONFIG_LOG_LEVEL": "${CONFIG_LOG_LEVEL}"
        }
      }
    },
    "arguments": {
      "CONFIG_LOG_LEVEL": {
        "description": "Sets the logging level of MongoDB Lens, controlling the verbosity of log output.",
        "required": false,
        "example": "verbose"
      },
      "MONGODB_URI": {
        "description": "The connection string for the MongoDB database.",
        "required": true,
        "example": "mongodb://your-connection-string"
      }
    },
    "tools": [
      {
        "name": "connect-mongodb",
        "description": "Connect to a different MongoDB URI or alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uri": {
              "type": "string",
              "minLength": 1,
              "description": "MongoDB connection URI or alias to connect to"
            },
            "validateConnection": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate the connection"
            }
          },
          "required": [
            "uri"
          ]
        }
      },
      {
        "name": "connect-original",
        "description": "Connect back to the original MongoDB URI used at startup",
        "inputSchema": {
          "type": "object",
          "properties": {
            "validateConnection": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate the connection"
            }
          }
        }
      },
      {
        "name": "add-connection-alias",
        "description": "Add a new MongoDB connection alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "alias": {
              "type": "string",
              "minLength": 1,
              "description": "Alias name for the connection"
            },
            "uri": {
              "type": "string",
              "minLength": 1,
              "description": "MongoDB connection URI"
            }
          },
          "required": [
            "alias",
            "uri"
          ]
        }
      },
      {
        "name": "list-connections",
        "description": "List all configured MongoDB connection aliases",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "list-databases",
        "description": "List all accessible MongoDB databases",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "current-database",
        "description": "Get the name of the current database",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "create-database",
        "description": "Create a new MongoDB database with option to switch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to create"
            },
            "switch": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Whether to switch to the new database after creation"
            },
            "validateName": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether to validate database name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "use-database",
        "description": "Switch to a specific database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to use"
            }
          },
          "required": [
            "database"
          ]
        }
      },
      {
        "name": "drop-database",
        "description": "Drop a database (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Database name to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create-user",
        "description": "Create a new database user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1,
              "description": "Username"
            },
            "password": {
              "type": "string",
              "minLength": 1,
              "description": "Password"
            },
            "roles": {
              "type": "string",
              "description": "Roles as JSON array, e.g. [{\"role\": \"readWrite\", \"db\": \"mydb\"}]"
            }
          },
          "required": [
            "username",
            "password",
            "roles"
          ]
        }
      },
      {
        "name": "drop-user",
        "description": "Drop an existing database user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1,
              "description": "Username to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "list-collections",
        "description": "List collections in the current database",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "create-collection",
        "description": "Create a new collection with options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "options": {
              "type": "string",
              "default": "{}",
              "description": "Collection options as JSON string (capped, size, etc.)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "drop-collection",
        "description": "Drop a collection (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "rename-collection",
        "description": "Rename an existing collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "oldName": {
              "type": "string",
              "minLength": 1,
              "description": "Current collection name"
            },
            "newName": {
              "type": "string",
              "minLength": 1,
              "description": "New collection name"
            },
            "dropTarget": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Whether to drop target collection if it exists"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "oldName",
            "newName"
          ]
        }
      },
      {
        "name": "validate-collection",
        "description": "Run validation on a collection to check for inconsistencies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "full": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Perform full validation (slower but more thorough)"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "distinct-values",
        "description": "Get unique values for a field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "field": {
              "type": "string",
              "minLength": 1,
              "description": "Field name to get distinct values for"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Optional filter as JSON string"
            }
          },
          "required": [
            "collection",
            "field"
          ]
        }
      },
      {
        "name": "find-documents",
        "description": "Run queries with filters and projections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "MongoDB query filter (JSON string)"
            },
            "projection": {
              "type": "string",
              "description": "Fields to include/exclude (JSON string)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum number of documents to return"
            },
            "skip": {
              "type": "integer",
              "minimum": 0,
              "default": 0,
              "description": "Number of documents to skip"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification (JSON string)"
            },
            "streaming": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Enable streaming for large result sets"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "count-documents",
        "description": "Count documents with optional filter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "MongoDB query filter (JSON string)"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "insert-document",
        "description": "Insert one or multiple documents into a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "document": {
              "type": "string",
              "description": "Document as JSON string or array of documents"
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string (including \"ordered\" for multiple documents)"
            }
          },
          "required": [
            "collection",
            "document"
          ]
        }
      },
      {
        "name": "update-document",
        "description": "Update specific documents in a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "description": "Filter as JSON string"
            },
            "update": {
              "type": "string",
              "description": "Update operations as JSON string"
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string"
            }
          },
          "required": [
            "collection",
            "filter",
            "update"
          ]
        }
      },
      {
        "name": "delete-document",
        "description": "Delete document(s) (requires confirmation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "minLength": 1,
              "description": "Filter as JSON string"
            },
            "many": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Delete multiple documents if true"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "filter"
          ]
        }
      },
      {
        "name": "aggregate-data",
        "description": "Run aggregation pipelines",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "pipeline": {
              "type": "string",
              "description": "Aggregation pipeline as JSON string array"
            },
            "streaming": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Enable streaming results for large datasets"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 1000,
              "description": "Maximum number of results to return when streaming"
            }
          },
          "required": [
            "collection",
            "pipeline"
          ]
        }
      },
      {
        "name": "create-index",
        "description": "Create new index on collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "keys": {
              "type": "string",
              "description": "Index keys as JSON object"
            },
            "options": {
              "type": "string",
              "description": "Index options as JSON object"
            }
          },
          "required": [
            "collection",
            "keys"
          ]
        }
      },
      {
        "name": "drop-index",
        "description": "Drop an existing index from a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "indexName": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the index to drop"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "indexName"
          ]
        }
      },
      {
        "name": "get-stats",
        "description": "Get database or collection statistics",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "database",
                "collection"
              ],
              "description": "Target type"
            },
            "name": {
              "type": "string",
              "description": "Collection name (for collection stats)"
            }
          },
          "required": [
            "target"
          ]
        }
      },
      {
        "name": "analyze-schema",
        "description": "Automatically infer schema from collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "sampleSize": {
              "type": "integer",
              "minimum": 1,
              "default": 100,
              "description": "Number of documents to sample"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "generate-schema-validator",
        "description": "Generate a JSON Schema validator for a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "strictness": {
              "type": "string",
              "enum": [
                "strict",
                "moderate",
                "relaxed"
              ],
              "default": "moderate",
              "description": "Validation strictness level"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "compare-schemas",
        "description": "Compare schemas between two collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceCollection": {
              "type": "string",
              "minLength": 1,
              "description": "Source collection name"
            },
            "targetCollection": {
              "type": "string",
              "minLength": 1,
              "description": "Target collection name"
            },
            "sampleSize": {
              "type": "integer",
              "minimum": 1,
              "default": 100,
              "description": "Number of documents to sample"
            }
          },
          "required": [
            "sourceCollection",
            "targetCollection"
          ]
        }
      },
      {
        "name": "explain-query",
        "description": "Analyze query performance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "description": "MongoDB query filter (JSON string)"
            },
            "verbosity": {
              "type": "string",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ],
              "default": "executionStats",
              "description": "Explain verbosity level"
            }
          },
          "required": [
            "collection",
            "filter"
          ]
        }
      },
      {
        "name": "analyze-query-patterns",
        "description": "Analyze query patterns and suggest optimizations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name to analyze"
            },
            "duration": {
              "type": "integer",
              "minimum": 1,
              "maximum": 60,
              "default": 10,
              "description": "Duration to analyze in seconds"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "bulk-operations",
        "description": "Perform bulk inserts, updates, or deletes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operations": {
              "type": "string",
              "description": "Array of operations as JSON string"
            },
            "ordered": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "true",
              "description": "Whether operations should be performed in order"
            },
            "token": {
              "type": "string",
              "description": "Confirmation token from previous request"
            }
          },
          "required": [
            "collection",
            "operations"
          ]
        }
      },
      {
        "name": "create-timeseries",
        "description": "Create a time series collection for temporal data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "timeField": {
              "type": "string",
              "minLength": 1,
              "description": "Field that contains the time value"
            },
            "metaField": {
              "type": "string",
              "description": "Field that contains metadata for grouping"
            },
            "granularity": {
              "type": "string",
              "enum": [
                "seconds",
                "minutes",
                "hours"
              ],
              "default": "seconds",
              "description": "Time series granularity"
            },
            "expireAfterSeconds": {
              "type": "integer",
              "description": "Optional TTL in seconds"
            }
          },
          "required": [
            "name",
            "timeField"
          ]
        }
      },
      {
        "name": "collation-query",
        "description": "Find documents with language-specific collation rules",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Query filter as JSON string"
            },
            "locale": {
              "type": "string",
              "minLength": 2,
              "description": "Locale code (e.g., \"en\", \"fr\", \"de\")"
            },
            "strength": {
              "type": "integer",
              "minimum": 1,
              "maximum": 5,
              "default": 3,
              "description": "Collation strength (1-5)"
            },
            "caseLevel": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Consider case in first-level differences"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification as JSON string"
            }
          },
          "required": [
            "collection",
            "locale"
          ]
        }
      },
      {
        "name": "text-search",
        "description": "Perform full-text search across text-indexed fields",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "searchText": {
              "type": "string",
              "minLength": 1,
              "description": "Text to search for"
            },
            "language": {
              "type": "string",
              "description": "Optional language for text search"
            },
            "caseSensitive": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Case sensitive search"
            },
            "diacriticSensitive": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Diacritic sensitive search"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum results to return"
            }
          },
          "required": [
            "collection",
            "searchText"
          ]
        }
      },
      {
        "name": "geo-query",
        "description": "Run geospatial queries with various operators",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operator": {
              "type": "string",
              "enum": [
                "near",
                "geoWithin",
                "geoIntersects"
              ],
              "description": "Geospatial operator type"
            },
            "field": {
              "type": "string",
              "minLength": 1,
              "description": "Geospatial field name"
            },
            "geometry": {
              "type": "string",
              "description": "GeoJSON geometry as JSON string"
            },
            "maxDistance": {
              "type": "number",
              "description": "Maximum distance in meters (for near queries)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 10,
              "description": "Maximum number of documents to return"
            }
          },
          "required": [
            "collection",
            "operator",
            "field",
            "geometry"
          ]
        }
      },
      {
        "name": "transaction",
        "description": "Execute multiple operations in a single transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operations": {
              "type": "string",
              "description": "JSON array of operations with collection, operation type, and parameters"
            }
          },
          "required": [
            "operations"
          ]
        }
      },
      {
        "name": "map-reduce",
        "description": "Run Map-Reduce operations (note: Map-Reduce deprecated as of MongoDB 5.0)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "map": {
              "type": "string",
              "description": "Map function as string e.g. \"function() { emit(this.field, 1); }\""
            },
            "reduce": {
              "type": "string",
              "description": "Reduce function as string e.g. \"function(key, values) { return Array.sum(values); }\""
            },
            "options": {
              "type": "string",
              "description": "Options as JSON string (query, limit, etc.)"
            }
          },
          "required": [
            "collection",
            "map",
            "reduce"
          ]
        }
      },
      {
        "name": "watch-changes",
        "description": "Watch for changes in a collection using change streams",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "operations": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "insert",
                  "update",
                  "delete",
                  "replace"
                ]
              },
              "default": [
                "insert",
                "update",
                "delete"
              ],
              "description": "Operations to watch"
            },
            "duration": {
              "type": "integer",
              "minimum": 1,
              "maximum": 60,
              "default": 10,
              "description": "Duration to watch in seconds"
            },
            "fullDocument": {
              "allOf": [
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "enum": [
                    "true",
                    "false"
                  ]
                }
              ],
              "default": "false",
              "description": "Include full document in update events"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "gridfs-operation",
        "description": "Manage large files with GridFS",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "type": "string",
              "enum": [
                "list",
                "info",
                "delete"
              ],
              "description": "GridFS operation type"
            },
            "bucket": {
              "type": "string",
              "default": "fs",
              "description": "GridFS bucket name"
            },
            "filename": {
              "type": "string",
              "description": "Filename for info/delete operations"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 20,
              "description": "Maximum files to list"
            }
          },
          "required": [
            "operation"
          ]
        }
      },
      {
        "name": "clear-cache",
        "description": "Clear memory caches to ensure fresh data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "all",
                "collections",
                "schemas",
                "indexes",
                "stats",
                "fields",
                "serverStatus"
              ],
              "default": "all",
              "description": "Cache type to clear (default: all)"
            }
          }
        }
      },
      {
        "name": "shard-status",
        "description": "Get sharding status for database or collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "target": {
              "type": "string",
              "enum": [
                "database",
                "collection"
              ],
              "default": "database",
              "description": "Target type"
            },
            "collection": {
              "type": "string",
              "description": "Collection name (if target is collection)"
            }
          }
        }
      },
      {
        "name": "export-data",
        "description": "Export query results to formatted JSON or CSV",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "minLength": 1,
              "description": "Collection name"
            },
            "filter": {
              "type": "string",
              "default": "{}",
              "description": "Filter as JSON string"
            },
            "format": {
              "type": "string",
              "enum": [
                "json",
                "csv"
              ],
              "default": "json",
              "description": "Export format"
            },
            "fields": {
              "type": "string",
              "description": "Comma-separated list of fields to include (for CSV)"
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "default": 1000,
              "description": "Maximum documents to export"
            },
            "sort": {
              "type": "string",
              "description": "Sort specification as JSON string (e.g. {\"date\": -1} for descending)"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "devrev": {
    "name": "devrev",
    "display_name": "DevRev",
    "description": "An MCP server to integrate with DevRev APIs to search through your DevRev Knowledge Graph where objects can be imported from diff. sources listed [here](https://devrev.ai/docs/import#available-sources).",
    "repository": {
      "type": "git",
      "url": "https://github.com/kpsunil97/devrev-mcp-server"
    },
    "homepage": "https://github.com/kpsunil97/devrev-mcp-server",
    "author": {
      "name": "kpsunil97"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "devrev",
      "server",
      "search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "devrev-mcp"
        ],
        "env": {
          "DEVREV_API_KEY": "${DEVREV_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEVREV_API_KEY": {
        "description": "Your DevRev API key required to authenticate requests to the DevRev API.",
        "required": true,
        "example": "YOUR_DEVREV_API_KEY"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search DevRev using the provided query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "namespace": {
              "type": "string",
              "enum": [
                "article",
                "issue",
                "ticket"
              ]
            }
          },
          "required": [
            "query",
            "namespace"
          ]
        }
      },
      {
        "name": "get_object",
        "description": "Get all information about a DevRev object using its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "eunomia": {
    "name": "eunomia",
    "display_name": "Eunomia",
    "description": "Extension of the Eunomia framework that connects Eunomia instruments with MCP servers",
    "repository": {
      "type": "git",
      "url": "https://github.com/whataboutyou-ai/eunomia-MCP-server"
    },
    "homepage": "https://github.com/whataboutyou-ai/eunomia-MCP-server",
    "author": {
      "name": "whataboutyou-ai"
    },
    "license": "Apache-2.0",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Eunomia",
      "Data Governance"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/whataboutyou-ai/eunomia-MCP-server",
          "orchestra_server"
        ]
      }
    },
    "arguments": {
      "APP_NAME": {
        "description": "Name of the application",
        "required": true,
        "example": "mcp-server_orchestra"
      },
      "APP_VERSION": {
        "description": "Current version of the application",
        "required": true,
        "example": "0.1.0"
      },
      "LOG_LEVEL": {
        "description": "Logging level to control the verbosity of logs (default: 'info')",
        "required": false,
        "example": "info"
      },
      "REQUEST_TIMEOUT": {
        "description": "Environment variable that sets the request timeout duration in seconds",
        "required": false,
        "example": "30"
      }
    }
  },
  "google-custom-search": {
    "name": "google-custom-search",
    "display_name": "Google Custom Search",
    "description": "Provides Google Search results via the Google Custom Search API",
    "repository": {
      "type": "git",
      "url": "https://github.com/adenot/mcp-google-search"
    },
    "homepage": "https://github.com/adenot/mcp-google-search",
    "author": {
      "name": "adenot"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google",
      "Custom Search",
      "Webpage Reading"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@adenot/mcp-google-search"
        ],
        "env": {
          "GOOGLE_API_KEY": "your-api-key-here",
          "GOOGLE_SEARCH_ENGINE_ID": "your-search-engine-id-here"
        }
      }
    },
    "examples": [
      {
        "title": "Search Tool",
        "description": "Perform web searches using Google Custom Search API.",
        "prompt": "{\"name\":\"search\",\"arguments\":{\"query\":\"your search query\",\"num\":5}}"
      },
      {
        "title": "Webpage Reader Tool",
        "description": "Extract content from any webpage.",
        "prompt": "{\"name\":\"read_webpage\",\"arguments\":{\"url\":\"https://example.com\"}}"
      }
    ],
    "arguments": {
      "GOOGLE_API_KEY": {
        "description": "Your Google API key for accessing the Google Custom Search API.",
        "required": true,
        "example": "AIzaSyA-xxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      },
      "GOOGLE_SEARCH_ENGINE_ID": {
        "description": "The unique identifier for your Custom Search Engine that you created on Google.",
        "required": true,
        "example": "012345678901234567890:abcdefghijk"
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Perform a web search query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "num": {
              "type": "number",
              "description": "Number of results (1-10)",
              "minimum": 1,
              "maximum": 10
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "bigquery": {
    "name": "bigquery",
    "display_name": "BigQuery",
    "description": "Server implementation for Google BigQuery integration that enables direct BigQuery database access and querying capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/ergut/mcp-bigquery-server"
    },
    "homepage": "https://github.com/ergut/mcp-bigquery-server",
    "author": {
      "name": "ergut"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "BigQuery",
      "AI",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ergut/mcp-bigquery-server",
          "--project-id",
          "${PROJECT_ID}",
          "--location",
          "${LOCATION}"
        ]
      }
    },
    "arguments": {
      "PROJECT_ID": {
        "description": "Your Google Cloud project ID",
        "required": true,
        "example": "your-project-id"
      },
      "LOCATION": {
        "description": "BigQuery location, defaults to 'us-central1'.",
        "required": false,
        "example": "us-central1"
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Run a read-only BigQuery SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sql": {
              "type": "string"
            },
            "maximumBytesBilled": {
              "type": "string",
              "description": "Maximum bytes billed (default: 1GB)",
              "optional": true
            }
          }
        }
      }
    ]
  },
  "bitable-mcp": {
    "name": "bitable-mcp",
    "display_name": "Bitable",
    "description": "MCP server provides access to Lark Bitable through the Model Context Protocol. It allows users to interact with Bitable tables using predefined tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/lloydzhou/bitable-mcp"
    },
    "homepage": "https://github.com/lloydzhou/bitable-mcp",
    "author": {
      "name": "lloydzhou"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Bitable",
      "Lark"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "bitable-mcp"
        ],
        "env": {
          "PERSONAL_BASE_TOKEN": "${PERSONAL_BASE_TOKEN}",
          "APP_TOKEN": "${APP_TOKEN}"
        }
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "bitable_mcp"
        ],
        "env": {
          "PERSONAL_BASE_TOKEN": "${PERSONAL_BASE_TOKEN}",
          "APP_TOKEN": "${APP_TOKEN}"
        },
        "description": "Run with Python module (requires pip install)"
      }
    },
    "examples": [
      {
        "title": "List Tables",
        "description": "Lists all tables available in Bitable.",
        "prompt": "list_table"
      }
    ],
    "arguments": {
      "PERSONAL_BASE_TOKEN": {
        "description": "Personal base token required for authentication with the Bitable API.",
        "required": true,
        "example": "your_personal_base_token"
      },
      "APP_TOKEN": {
        "description": "Application token required for the Bitable server to function properly.",
        "required": true,
        "example": "your_app_token"
      }
    },
    "tools": [
      {
        "name": "list_table",
        "description": "list table for current bitable",
        "inputSchema": {
          "properties": {},
          "title": "list_tableArguments",
          "type": "object"
        }
      },
      {
        "name": "describe_table",
        "description": "describe_table by table name",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "describe_tableArguments",
          "type": "object"
        }
      },
      {
        "name": "read_query",
        "description": "read_query by sql",
        "inputSchema": {
          "properties": {
            "sql": {
              "title": "Sql",
              "type": "string"
            }
          },
          "required": [
            "sql"
          ],
          "title": "read_queryArguments",
          "type": "object"
        }
      }
    ]
  },
  "openapi-anyapi": {
    "name": "openapi-anyapi",
    "display_name": "Scalable OpenAPI Endpoint Discovery Tool",
    "description": "Interact with large [OpenAPI](https://www.openapis.org/) docs using built-in semantic search for endpoints. Allows for customizing the MCP server prefix.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-server-any-openapi"
    },
    "homepage": "https://github.com/baryhuang/mcp-server-any-openapi",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "OPENAPI_JSON_DOCS_URL=${OPENAPI_JSON_DOCS_URL}",
          "-e",
          "API_REQUEST_BASE_URL=${API_REQUEST_BASE_URL}",
          "-e",
          "MCP_API_PREFIX=${MCP_API_PREFIX}",
          "buryhuang/mcp-server-any-openapi:latest"
        ],
        "env": {
          "OPENAPI_JSON_DOCS_URL": "${OPENAPI_JSON_DOCS_URL}",
          "API_REQUEST_BASE_URL": "${API_REQUEST_BASE_URL}",
          "MCP_API_PREFIX": "${MCP_API_PREFIX}"
        }
      },
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/baryhuang/mcp-server-any-openapi",
          "src/mcp_server_any_openapi/server.py"
        ],
        "env": {
          "OPENAPI_JSON_DOCS_URL": "${OPENAPI_JSON_DOCS_URL}",
          "API_REQUEST_BASE_URL": "${API_REQUEST_BASE_URL}",
          "MCP_API_PREFIX": "${MCP_API_PREFIX}"
        }
      }
    },
    "tags": [
      "OpenAPI",
      "API Discovery",
      "Semantic Search",
      "FastAPI"
    ],
    "examples": [
      {
        "title": "Get API Endpoints",
        "description": "Use this tool to find relevant API endpoints by describing your intent.",
        "prompt": "Get prices for all stocks"
      }
    ],
    "arguments": {
      "OPENAPI_JSON_DOCS_URL": {
        "description": "URL to the OpenAPI specification JSON (defaults to https://api.staging.readymojo.com/openapi.json)",
        "required": false,
        "example": "https://api.example.com/openapi.json"
      },
      "API_REQUEST_BASE_URL": {
        "description": "Optional base URL to override the default URL extracted from the OpenAPI document.",
        "required": false,
        "example": "https://api.finance.com"
      },
      "MCP_API_PREFIX": {
        "description": "Customizable tool namespace (default 'any_openapi'). Allows for control over tool naming.",
        "required": false,
        "example": "finance"
      }
    },
    "tools": [
      {
        "name": "${MCP_API_PREFIX}_api_request_schema",
        "description": "Get API endpoint schemas that match your intent. Returns endpoint details including path, method, parameters, and response formats.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Describe what you want to do with the API (e.g., 'Get user profile information', 'Create a new job posting')"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "${MCP_API_PREFIX}_make_request",
        "description": "Make an actual REST API request with full control over method, headers, body, and parameters.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "method": {
              "type": "string",
              "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
              "enum": [
                "GET",
                "POST",
                "PUT",
                "DELETE",
                "PATCH"
              ]
            },
            "url": {
              "type": "string",
              "description": "Fully qualified API URL (e.g., https://api.example.com/users/123)"
            },
            "headers": {
              "type": "object",
              "description": "Request headers",
              "additionalProperties": {
                "type": "string"
              }
            },
            "query_params": {
              "type": "object",
              "description": "Query parameters",
              "additionalProperties": {
                "type": "string"
              }
            },
            "body": {
              "type": "object",
              "description": "Request body (for POST, PUT, PATCH)",
              "additionalProperties": true
            }
          },
          "required": [
            "method",
            "url"
          ]
        }
      }
    ]
  },
  "blender": {
    "name": "blender",
    "display_name": "Blender",
    "description": "Blender integration allowing prompt enabled 3D scene creation, modeling and manipulation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ahujasid/blender-mcp"
    },
    "homepage": "https://github.com/ahujasid/blender-mcp",
    "author": {
      "name": "ahujasid"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Blender",
      "Claude AI",
      "3D Modeling"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "blender-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "get_scene_info",
        "description": "Get detailed information about the current Blender scene",
        "inputSchema": {
          "properties": {},
          "title": "get_scene_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "get_object_info",
        "description": "\n    Get detailed information about a specific object in the Blender scene.\n    \n    Parameters:\n    - object_name: The name of the object to get information about\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            }
          },
          "required": [
            "object_name"
          ],
          "title": "get_object_infoArguments",
          "type": "object"
        }
      },
      {
        "name": "create_object",
        "description": "\n    Create a new object in the Blender scene.\n    \n    Parameters:\n    - type: Object type (CUBE, SPHERE, CYLINDER, PLANE, CONE, TORUS, EMPTY, CAMERA, LIGHT)\n    - name: Optional name for the object\n    - location: Optional [x, y, z] location coordinates\n    - rotation: Optional [x, y, z] rotation in radians\n    - scale: Optional [x, y, z] scale factors (not used for TORUS)\n    \n    Torus-specific parameters (only used when type == \"TORUS\"):\n    - align: How to align the torus ('WORLD', 'VIEW', or 'CURSOR')\n    - major_segments: Number of segments for the main ring\n    - minor_segments: Number of segments for the cross-section\n    - mode: Dimension mode ('MAJOR_MINOR' or 'EXT_INT')\n    - major_radius: Radius from the origin to the center of the cross sections\n    - minor_radius: Radius of the torus' cross section\n    - abso_major_rad: Total exterior radius of the torus\n    - abso_minor_rad: Total interior radius of the torus\n    - generate_uvs: Whether to generate a default UV map\n    \n    Returns:\n    A message indicating the created object name.\n    ",
        "inputSchema": {
          "properties": {
            "type": {
              "default": "CUBE",
              "title": "Type",
              "type": "string"
            },
            "name": {
              "default": null,
              "title": "Name",
              "type": "string"
            },
            "location": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Location",
              "type": "array"
            },
            "rotation": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Rotation",
              "type": "array"
            },
            "scale": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Scale",
              "type": "array"
            },
            "align": {
              "default": "WORLD",
              "title": "Align",
              "type": "string"
            },
            "major_segments": {
              "default": 48,
              "title": "Major Segments",
              "type": "integer"
            },
            "minor_segments": {
              "default": 12,
              "title": "Minor Segments",
              "type": "integer"
            },
            "mode": {
              "default": "MAJOR_MINOR",
              "title": "Mode",
              "type": "string"
            },
            "major_radius": {
              "default": 1.0,
              "title": "Major Radius",
              "type": "number"
            },
            "minor_radius": {
              "default": 0.25,
              "title": "Minor Radius",
              "type": "number"
            },
            "abso_major_rad": {
              "default": 1.25,
              "title": "Abso Major Rad",
              "type": "number"
            },
            "abso_minor_rad": {
              "default": 0.75,
              "title": "Abso Minor Rad",
              "type": "number"
            },
            "generate_uvs": {
              "default": true,
              "title": "Generate Uvs",
              "type": "boolean"
            }
          },
          "title": "create_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "modify_object",
        "description": "\n    Modify an existing object in the Blender scene.\n    \n    Parameters:\n    - name: Name of the object to modify\n    - location: Optional [x, y, z] location coordinates\n    - rotation: Optional [x, y, z] rotation in radians\n    - scale: Optional [x, y, z] scale factors\n    - visible: Optional boolean to set visibility\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "location": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Location",
              "type": "array"
            },
            "rotation": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Rotation",
              "type": "array"
            },
            "scale": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Scale",
              "type": "array"
            },
            "visible": {
              "default": null,
              "title": "Visible",
              "type": "boolean"
            }
          },
          "required": [
            "name"
          ],
          "title": "modify_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_object",
        "description": "\n    Delete an object from the Blender scene.\n    \n    Parameters:\n    - name: Name of the object to delete\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "delete_objectArguments",
          "type": "object"
        }
      },
      {
        "name": "set_material",
        "description": "\n    Set or create a material for an object.\n    \n    Parameters:\n    - object_name: Name of the object to apply the material to\n    - material_name: Optional name of the material to use or create\n    - color: Optional [R, G, B] color values (0.0-1.0)\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            },
            "material_name": {
              "default": null,
              "title": "Material Name",
              "type": "string"
            },
            "color": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Color",
              "type": "array"
            }
          },
          "required": [
            "object_name"
          ],
          "title": "set_materialArguments",
          "type": "object"
        }
      },
      {
        "name": "execute_blender_code",
        "description": "\n    Execute arbitrary Python code in Blender.\n    \n    Parameters:\n    - code: The Python code to execute\n    ",
        "inputSchema": {
          "properties": {
            "code": {
              "title": "Code",
              "type": "string"
            }
          },
          "required": [
            "code"
          ],
          "title": "execute_blender_codeArguments",
          "type": "object"
        }
      },
      {
        "name": "get_polyhaven_categories",
        "description": "\n    Get a list of categories for a specific asset type on Polyhaven.\n    \n    Parameters:\n    - asset_type: The type of asset to get categories for (hdris, textures, models, all)\n    ",
        "inputSchema": {
          "properties": {
            "asset_type": {
              "default": "hdris",
              "title": "Asset Type",
              "type": "string"
            }
          },
          "title": "get_polyhaven_categoriesArguments",
          "type": "object"
        }
      },
      {
        "name": "search_polyhaven_assets",
        "description": "\n    Search for assets on Polyhaven with optional filtering.\n    \n    Parameters:\n    - asset_type: Type of assets to search for (hdris, textures, models, all)\n    - categories: Optional comma-separated list of categories to filter by\n    \n    Returns a list of matching assets with basic information.\n    ",
        "inputSchema": {
          "properties": {
            "asset_type": {
              "default": "all",
              "title": "Asset Type",
              "type": "string"
            },
            "categories": {
              "default": null,
              "title": "Categories",
              "type": "string"
            }
          },
          "title": "search_polyhaven_assetsArguments",
          "type": "object"
        }
      },
      {
        "name": "download_polyhaven_asset",
        "description": "\n    Download and import a Polyhaven asset into Blender.\n    \n    Parameters:\n    - asset_id: The ID of the asset to download\n    - asset_type: The type of asset (hdris, textures, models)\n    - resolution: The resolution to download (e.g., 1k, 2k, 4k)\n    - file_format: Optional file format (e.g., hdr, exr for HDRIs; jpg, png for textures; gltf, fbx for models)\n    \n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "asset_id": {
              "title": "Asset Id",
              "type": "string"
            },
            "asset_type": {
              "title": "Asset Type",
              "type": "string"
            },
            "resolution": {
              "default": "1k",
              "title": "Resolution",
              "type": "string"
            },
            "file_format": {
              "default": null,
              "title": "File Format",
              "type": "string"
            }
          },
          "required": [
            "asset_id",
            "asset_type"
          ],
          "title": "download_polyhaven_assetArguments",
          "type": "object"
        }
      },
      {
        "name": "set_texture",
        "description": "\n    Apply a previously downloaded Polyhaven texture to an object.\n    \n    Parameters:\n    - object_name: Name of the object to apply the texture to\n    - texture_id: ID of the Polyhaven texture to apply (must be downloaded first)\n    \n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "object_name": {
              "title": "Object Name",
              "type": "string"
            },
            "texture_id": {
              "title": "Texture Id",
              "type": "string"
            }
          },
          "required": [
            "object_name",
            "texture_id"
          ],
          "title": "set_textureArguments",
          "type": "object"
        }
      },
      {
        "name": "get_polyhaven_status",
        "description": "\n    Check if PolyHaven integration is enabled in Blender.\n    Returns a message indicating whether PolyHaven features are available.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_polyhaven_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "get_hyper3d_status",
        "description": "\n    Check if Hyper3D Rodin integration is enabled in Blender.\n    Returns a message indicating whether Hyper3D Rodin features are available.\n\n    Don't emphasize the key type in the returned message, but sliently remember it. \n    ",
        "inputSchema": {
          "properties": {},
          "title": "get_hyper3d_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "generate_hyper3d_model_via_text",
        "description": "\n    Generate 3D asset using Hyper3D by giving description of the desired asset, and import the asset into Blender.\n    The 3D asset has built-in materials.\n    The generated model has a normalized size, so re-scaling after generation can be useful.\n    \n    Parameters:\n    - text_prompt: A short description of the desired model in **English**.\n    - bbox_condition: Optional. If given, it has to be a list of floats of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "text_prompt": {
              "title": "Text Prompt",
              "type": "string"
            },
            "bbox_condition": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Bbox Condition",
              "type": "array"
            }
          },
          "required": [
            "text_prompt"
          ],
          "title": "generate_hyper3d_model_via_textArguments",
          "type": "object"
        }
      },
      {
        "name": "generate_hyper3d_model_via_images",
        "description": "\n    Generate 3D asset using Hyper3D by giving images of the wanted asset, and import the generated asset into Blender.\n    The 3D asset has built-in materials.\n    The generated model has a normalized size, so re-scaling after generation can be useful.\n    \n    Parameters:\n    - input_image_paths: The **absolute** paths of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in MAIN_SITE mode.\n    - input_image_urls: The URLs of input images. Even if only one image is provided, wrap it into a list. Required if Hyper3D Rodin in FAL_AI mode.\n    - bbox_condition: Optional. If given, it has to be a list of ints of length 3. Controls the ratio between [Length, Width, Height] of the model.\n\n    Only one of {input_image_paths, input_image_urls} should be given at a time, depending on the Hyper3D Rodin's current mode.\n    Returns a message indicating success or failure.\n    ",
        "inputSchema": {
          "properties": {
            "input_image_paths": {
              "default": null,
              "items": {
                "type": "string"
              },
              "title": "Input Image Paths",
              "type": "array"
            },
            "input_image_urls": {
              "default": null,
              "items": {
                "type": "string"
              },
              "title": "Input Image Urls",
              "type": "array"
            },
            "bbox_condition": {
              "default": null,
              "items": {
                "type": "number"
              },
              "title": "Bbox Condition",
              "type": "array"
            }
          },
          "title": "generate_hyper3d_model_via_imagesArguments",
          "type": "object"
        }
      },
      {
        "name": "poll_rodin_job_status",
        "description": "\n    Check if the Hyper3D Rodin generation task is completed.\n\n    For Hyper3D Rodin mode MAIN_SITE:\n        Parameters:\n        - subscription_key: The subscription_key given in the generate model step.\n\n        Returns a list of status. The task is done if all status are \"Done\".\n        If \"Failed\" showed up, the generating process failed.\n        This is a polling API, so only proceed if the status are finally determined (\"Done\" or \"Canceled\").\n\n    For Hyper3D Rodin mode FAL_AI:\n        Parameters:\n        - request_id: The request_id given in the generate model step.\n\n        Returns the generation task status. The task is done if status is \"COMPLETED\".\n        The task is in progress if status is \"IN_PROGRESS\".\n        If status other than \"COMPLETED\", \"IN_PROGRESS\", \"IN_QUEUE\" showed up, the generating process might be failed.\n        This is a polling API, so only proceed if the status are finally determined (\"COMPLETED\" or some failed state).\n    ",
        "inputSchema": {
          "properties": {
            "subscription_key": {
              "default": null,
              "title": "Subscription Key",
              "type": "string"
            },
            "request_id": {
              "default": null,
              "title": "Request Id",
              "type": "string"
            }
          },
          "title": "poll_rodin_job_statusArguments",
          "type": "object"
        }
      },
      {
        "name": "import_generated_asset",
        "description": "\n    Import the asset generated by Hyper3D Rodin after the generation task is completed.\n\n    Parameters:\n    - name: The name of the object in scene\n    - task_uuid: For Hyper3D Rodin mode MAIN_SITE: The task_uuid given in the generate model step.\n    - request_id: For Hyper3D Rodin mode FAL_AI: The request_id given in the generate model step.\n\n    Only give one of {task_uuid, request_id} based on the Hyper3D Rodin Mode!\n    Return if the asset has been imported successfully.\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "task_uuid": {
              "default": null,
              "title": "Task Uuid",
              "type": "string"
            },
            "request_id": {
              "default": null,
              "title": "Request Id",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "import_generated_assetArguments",
          "type": "object"
        }
      }
    ]
  },
  "virtual-location-google-street-view-etc": {
    "name": "virtual-location-google-street-view-etc",
    "display_name": "Virtual Traveling Bot",
    "description": "Integrates Google Map, Google Street View, PixAI, Stability.ai, ComfyUI API and Bluesky to provide a virtual location simulation in LLM (written in Effect.ts)",
    "repository": {
      "type": "git",
      "url": "https://github.com/mfukushim/map-traveler-mcp"
    },
    "homepage": "https://github.com/mfukushim/map-traveler-mcp",
    "author": {
      "name": "mfukushim"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google Maps",
      "Avatar",
      "Virtual Travel"
    ],
    "tools": [
      {
        "name": "tips",
        "description": "Inform you of recommended actions for your device",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_setting",
        "description": "Get current setting",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_traveler_info",
        "description": "get a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {}
          }
        }
      },
      {
        "name": "set_traveler_info",
        "description": "set a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {
              "type": "string",
              "description": "traveler's setting. traveler's name, the language traveler speak, etc."
            }
          },
          "required": [
            "settings"
          ]
        }
      },
      {
        "name": "set_avatar_prompt",
        "description": "set a traveler's avatar prompt. A prompt for AI image generation to specify the appearance of a traveler's avatar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "traveler's avatar AI image generation prompt."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "reset_avatar_prompt",
        "description": "reset to default traveler's avatar prompt.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "start_journey",
        "description": "Start the journey to destination",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "stop_journey",
        "description": "Stop the journey",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "reach_a_percentage_of_destination",
        "description": "Reach a specified percentage of the destination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeElapsedPercentage": {
              "type": "number",
              "description": "Percent progress towards destination. (0~100)"
            }
          },
          "required": [
            "timeElapsedPercentage"
          ]
        }
      },
      {
        "name": "get_current_view_info",
        "description": "Get the address of the current location and information on nearby facilities,view snapshot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "includePhoto": {
              "type": "boolean",
              "description": "Get scenery photos of current location"
            },
            "includeNearbyFacilities": {
              "type": "boolean",
              "description": "Get information on nearby facilities"
            }
          }
        }
      },
      {
        "name": "get_traveler_location",
        "description": "Get the address of the current traveler's location",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_sns_mentions",
        "description": "Get recent social media mentions",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_sns_feeds",
        "description": "Get recent social media posts from fellow travelers feeds",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "post_sns_writer",
        "description": "Post your recent travel experiences to social media for fellow travelers and readers.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "A description of the journey. important: Do not use offensive language."
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "reply_sns_writer",
        "description": "Write a reply to the article with the specified ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "A description of the reply article. important: Do not use offensive language."
            },
            "id": {
              "type": "string",
              "description": "The ID of the original post to which you want to add a reply."
            }
          },
          "required": [
            "message",
            "id"
          ]
        }
      },
      {
        "name": "add_like",
        "description": "Add a like to the specified post",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the post to like."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "set_current_location",
        "description": "Set my current address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "address to set"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_destination_address",
        "description": "get a address of destination location",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "set_destination_address",
        "description": "set a address of destination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "address of destination"
            }
          },
          "required": [
            "address"
          ]
        }
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mfukushim/map-traveler-mcp"
        ],
        "env": {
          "GoogleMapApi_key": "${GoogleMapApi_key}",
          "mapApi_url": "${mapApi_url}",
          "time_scale": "${time_scale}",
          "sqlite_path": "${sqlite_path}",
          "rembg_path": "${rembg_path}",
          "remBgUrl": "${remBgUrl}",
          "pixAi_key": "${pixAi_key}",
          "sd_key": "${sd_key}",
          "pixAi_modelId": "${pixAi_modelId}",
          "comfy_url": "${comfy_url}",
          "comfy_workflow_t2i": "${comfy_workflow_t2i}",
          "comfy_workflow_i2i": "${comfy_workflow_i2i}",
          "comfy_params": "${comfy_params}",
          "fixed_model_prompt": "${fixed_model_prompt}",
          "bodyAreaRatio": "${bodyAreaRatio}",
          "bodyHWRatio": "${bodyHWRatio}",
          "bodyWindowRatioW": "${bodyWindowRatioW}",
          "bodyWindowRatioH": "${bodyWindowRatioH}",
          "bs_id": "${bs_id}",
          "bs_pass": "${bs_pass}",
          "bs_handle": "${bs_handle}",
          "filter_tools": "${filter_tools}",
          "moveMode": "${moveMode}",
          "image_width": "${image_width}",
          "DATABASE_URL": "${DATABASE_URL}"
        }
      }
    },
    "examples": [
      {
        "title": "Travel to Tokyo",
        "description": "Instruct the avatar to travel to Tokyo Station.",
        "prompt": "Go to Tokyo Station."
      },
      {
        "title": "Current Location Info",
        "description": "Get the current location information of the avatar.",
        "prompt": "Where are you now?"
      }
    ],
    "arguments": {
      "GoogleMapApi_key": {
        "description": "API key for accessing Google Maps services.",
        "required": true,
        "example": "YOUR_GOOGLE_MAP_API_KEY"
      },
      "mapApi_url": {
        "description": "Custom endpoint for the Map API, if any; otherwise, the default endpoint is used.",
        "required": false,
        "example": "https://your-custom-map-api.com"
      },
      "time_scale": {
        "description": "Scale factor to adjust the travel time based on real roads duration; default is 4.",
        "required": false,
        "example": "5"
      },
      "sqlite_path": {
        "description": "Path for saving the SQLite database file. It determines where the travel log will be stored.",
        "required": true,
        "example": "%USERPROFILE%/Desktop/traveler.sqlite"
      },
      "rembg_path": {
        "description": "Absolute path of the installed rembg command line interface for removing backgrounds from images.",
        "required": true,
        "example": "C:\\path\\to\\your\\rembg.exe"
      },
      "remBgUrl": {
        "description": "URL for the rembg API service if used; this is an alternative to the command line interface.",
        "required": false,
        "example": "http://rembg:7000"
      },
      "pixAi_key": {
        "description": "API key for accessing PixAI image generation services; either this or sd_key must be set to use image generation.",
        "required": true,
        "example": "YOUR_PIXAI_API_KEY"
      },
      "sd_key": {
        "description": "API key for accessing Stability.ai image generation services; either this or pixAi_key must be set.",
        "required": true,
        "example": "YOUR_STABILITY_AI_API_KEY"
      },
      "pixAi_modelId": {
        "description": "ID for the PixAI model to be used, if not set, the default model will be used.",
        "required": false,
        "example": "1648918127446573124"
      },
      "comfy_url": {
        "description": "URL to the ComfyUI API for image generation; must be set if using ComfyUI for this purpose.",
        "required": false,
        "example": "http://192.168.1.100:8188"
      },
      "comfy_workflow_t2i": {
        "description": "Path to the workflow JSON file for text-to-image conversion in ComfyUI.",
        "required": false,
        "example": "C:\\path\\to\\workflow\\t2i.json"
      },
      "comfy_workflow_i2i": {
        "description": "Path to the workflow JSON file for image-to-image conversion in ComfyUI.",
        "required": false,
        "example": "C:\\path\\to\\workflow\\i2i.json"
      },
      "comfy_params": {
        "description": "Parameters for the ComfyUI workflow in key-value format, received during the request.",
        "required": false,
        "example": "key1=value1,key2=value2"
      },
      "fixed_model_prompt": {
        "description": "A fixed prompt for avatar generation that prevents changes during conversations.",
        "required": false,
        "example": "Generate a friendly avatar."
      },
      "bodyAreaRatio": {
        "description": "Acceptable ratio for the avatar image area; affects how much of the image is used for the avatar.",
        "required": false,
        "example": "0.042"
      },
      "bodyHWRatio": {
        "description": "Acceptable aspect ratios for the avatar image; ensures correct proportions for the avatar.",
        "required": false,
        "example": "1.5~2.3"
      },
      "bodyWindowRatioW": {
        "description": "Horizontal ratio for the avatar composite window; affects layout.",
        "required": false,
        "example": "0.5"
      },
      "bodyWindowRatioH": {
        "description": "Aspect ratio for the avatar composite window; also affects layout.",
        "required": false,
        "example": "0.75"
      },
      "bs_id": {
        "description": "Bluesky SNS registration address for posting travel updates.",
        "required": false,
        "example": "YOUR_BSKY_ID"
      },
      "bs_pass": {
        "description": "Bluesky SNS password for the dedicated account used for posting.",
        "required": false,
        "example": "YOUR_BSKY_PASSWORD"
      },
      "bs_handle": {
        "description": "Bluesky SNS handle name for the account; used in the posts.",
        "required": false,
        "example": "myusername.bsky.social"
      },
      "filter_tools": {
        "description": "Settings to filter the tools available for use; all tools will be available by default.",
        "required": false,
        "example": "tips,set_traveler_location"
      },
      "moveMode": {
        "description": "Indicates whether the movement mode is realtime or skip; default is realtime.",
        "required": false,
        "example": "realtime"
      },
      "image_width": {
        "description": "Width of the generated output image in pixels; the default is 512.",
        "required": false,
        "example": "512"
      },
      "DATABASE_URL": {
        "description": "Database URL for persistent storage; used if a different database should be connected.",
        "required": false,
        "example": "mysql://user:password@host/dbname"
      }
    }
  },
  "multicluster-mcp-sever": {
    "name": "multicluster-mcp-sever",
    "display_name": "Multi-Cluster Server",
    "description": "The gateway for GenAI systems to interact with multiple Kubernetes clusters.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yanmxa/multicluster-mcp-server"
    },
    "homepage": "https://github.com/yanmxa/multicluster-mcp-server",
    "author": {
      "name": "yanmxa"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Generative AI",
      "Kubernetes"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/yanmxa/multicluster-mcp-server"
        ]
      }
    },
    "tools": [
      {
        "name": "kubectl_executor",
        "description": "Securely execute a kubectl command.",
        "inputSchema": {
          "command": {
            "type": "string",
            "description": "The full kubectl command to execute. Must start with 'kubectl'."
          },
          "cluster": {
            "type": "string",
            "description": "Optional cluster name for multi-cluster environments. Specify only if explicitly provided."
          }
        },
        "required": [
          "command"
        ]
      },
      {
        "name": "clusters",
        "description": "Retrieves a list of Kubernetes clusters (also known as managed clusters or spoke clusters).",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "connect_cluster_via_admin",
        "description": "Generates the KUBECONFIG for the cluster using the ServiceAccount and binds it to the cluster-admin role.",
        "inputSchema": {
          "cluster": {
            "type": "string",
            "description": "The target cluster where the ServiceAccount will be created."
          }
        },
        "required": [
          "cluster"
        ]
      },
      {
        "name": "apply_service_account_with_cluster_role",
        "description": "Creates a ServiceAccount in the specified cluster and optionally binds it to a ClusterRole. If no ClusterRole is provided, only the ServiceAccount and kubeconfig are created.",
        "inputSchema": {
          "cluster": {
            "type": "string",
            "description": "The cluster where the ServiceAccount will be created."
          },
          "clusterRole": {
            "type": "object",
            "description": "Optional ClusterRole object defining permissions for the ServiceAccount."
          }
        },
        "required": [
          "cluster"
        ]
      }
    ]
  },
  "google-maps": {
    "name": "google-maps",
    "display_name": "Google Maps",
    "description": "Location services, directions, and place details",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/google-maps",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Google Maps",
      "Geolocation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-google-maps"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "GOOGLE_MAPS_API_KEY",
          "mcp/google-maps"
        ],
        "env": {
          "GOOGLE_MAPS_API_KEY": "${GOOGLE_MAPS_API_KEY}"
        }
      }
    },
    "arguments": {
      "GOOGLE_MAPS_API_KEY": {
        "description": "Your Google Maps API key obtained from the Google Developers Console.",
        "required": true,
        "example": "AIzaSyD..."
      }
    },
    "tools": [
      {
        "name": "maps_geocode",
        "description": "Convert an address into geographic coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address to geocode"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "maps_reverse_geocode",
        "description": "Convert coordinates into an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ]
        }
      },
      {
        "name": "maps_search_places",
        "description": "Search for places using Google Places API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "location": {
              "type": "object",
              "properties": {
                "latitude": {
                  "type": "number"
                },
                "longitude": {
                  "type": "number"
                }
              },
              "description": "Optional center point for the search"
            },
            "radius": {
              "type": "number",
              "description": "Search radius in meters (max 50000)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "maps_place_details",
        "description": "Get detailed information about a specific place",
        "inputSchema": {
          "type": "object",
          "properties": {
            "place_id": {
              "type": "string",
              "description": "The place ID to get details for"
            }
          },
          "required": [
            "place_id"
          ]
        }
      },
      {
        "name": "maps_distance_matrix",
        "description": "Calculate travel distance and time for multiple origins and destinations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origins": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of origin addresses or coordinates"
            },
            "destinations": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of destination addresses or coordinates"
            },
            "mode": {
              "type": "string",
              "description": "Travel mode (driving, walking, bicycling, transit)",
              "enum": [
                "driving",
                "walking",
                "bicycling",
                "transit"
              ]
            }
          },
          "required": [
            "origins",
            "destinations"
          ]
        }
      },
      {
        "name": "maps_elevation",
        "description": "Get elevation data for locations on the earth",
        "inputSchema": {
          "type": "object",
          "properties": {
            "locations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "latitude": {
                    "type": "number"
                  },
                  "longitude": {
                    "type": "number"
                  }
                },
                "required": [
                  "latitude",
                  "longitude"
                ]
              },
              "description": "Array of locations to get elevation for"
            }
          },
          "required": [
            "locations"
          ]
        }
      },
      {
        "name": "maps_directions",
        "description": "Get directions between two points",
        "inputSchema": {
          "type": "object",
          "properties": {
            "origin": {
              "type": "string",
              "description": "Starting point address or coordinates"
            },
            "destination": {
              "type": "string",
              "description": "Ending point address or coordinates"
            },
            "mode": {
              "type": "string",
              "description": "Travel mode (driving, walking, bicycling, transit)",
              "enum": [
                "driving",
                "walking",
                "bicycling",
                "transit"
              ]
            }
          },
          "required": [
            "origin",
            "destination"
          ]
        }
      }
    ]
  },
  "spotify": {
    "name": "spotify",
    "display_name": "Spotify",
    "description": "This MCP allows an LLM to play and use Spotify.",
    "repository": {
      "type": "git",
      "url": "https://github.com/varunneal/spotify-mcp"
    },
    "homepage": "https://github.com/varunneal/spotify-mcp",
    "author": {
      "name": "varunneal"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "spotify",
      "audio"
    ],
    "examples": [
      {
        "title": "Basic Playback Control",
        "description": "Use the MCP to start, pause, or skip songs on Spotify.",
        "prompt": "Start playing a song on Spotify."
      },
      {
        "title": "Search for Tracks",
        "description": "Search for tracks, albums, artists, or playlists using the Spotify API.",
        "prompt": "Search for the album 'Thriller'."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/varunneal/spotify-mcp",
          "spotify-mcp"
        ],
        "env": {
          "SPOTIFY_CLIENT_ID": "${SPOTIFY_CLIENT_ID}",
          "SPOTIFY_CLIENT_SECRET": "${SPOTIFY_CLIENT_SECRET}",
          "SPOTIFY_REDIRECT_URI": "${SPOTIFY_REDIRECT_URI}"
        }
      }
    },
    "arguments": {
      "SPOTIFY_CLIENT_ID": {
        "description": "The client ID for your Spotify application, required to authenticate with the Spotify API.",
        "required": true,
        "example": "your_spotify_client_id_here"
      },
      "SPOTIFY_CLIENT_SECRET": {
        "description": "The client secret for your Spotify application, needed for secure authentication with the API.",
        "required": true,
        "example": "your_spotify_client_secret_here"
      },
      "SPOTIFY_REDIRECT_URI": {
        "description": "The redirect URI you specified when creating the Spotify application, needed for the OAuth authentication process.",
        "required": false,
        "example": "http://localhost:8888"
      }
    },
    "tools": [
      {
        "name": "SpotifyPlayback",
        "description": "Manages the current playback with the following actions:\n    - get: Get information about user's current track.\n    - start: Starts playing new item or resumes current playback if called with no uri.\n    - pause: Pauses current playback.\n    - skip: Skips current track.\n    ",
        "inputSchema": {
          "description": "Manages the current playback with the following actions:\n- get: Get information about user's current track.\n- start: Starts playing new item or resumes current playback if called with no uri.\n- pause: Pauses current playback.\n- skip: Skips current track.",
          "properties": {
            "action": {
              "description": "Action to perform: 'get', 'start', 'pause' or 'skip'.",
              "title": "Action",
              "type": "string"
            },
            "spotify_uri": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Spotify uri of item to play for 'start' action. If omitted, resumes current playback.",
              "title": "Spotify Uri"
            },
            "num_skips": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "description": "Number of tracks to skip for `skip` action.",
              "title": "Num Skips"
            }
          },
          "required": [
            "action"
          ],
          "title": "Playback",
          "type": "object"
        }
      },
      {
        "name": "SpotifySearch",
        "description": "Search for tracks, albums, artists, or playlists on Spotify.",
        "inputSchema": {
          "description": "Search for tracks, albums, artists, or playlists on Spotify.",
          "properties": {
            "query": {
              "description": "query term",
              "title": "Query",
              "type": "string"
            },
            "qtype": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "track",
              "description": "Type of items to search for (track, album, artist, playlist, or comma-separated combination)",
              "title": "Qtype"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 10,
              "description": "Maximum number of items to return",
              "title": "Limit"
            }
          },
          "required": [
            "query"
          ],
          "title": "Search",
          "type": "object"
        }
      },
      {
        "name": "SpotifyQueue",
        "description": "Manage the playback queue - get the queue or add tracks.",
        "inputSchema": {
          "description": "Manage the playback queue - get the queue or add tracks.",
          "properties": {
            "action": {
              "description": "Action to perform: 'add' or 'get'.",
              "title": "Action",
              "type": "string"
            },
            "track_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Track ID to add to queue (required for add action)",
              "title": "Track Id"
            }
          },
          "required": [
            "action"
          ],
          "title": "Queue",
          "type": "object"
        }
      },
      {
        "name": "SpotifyGetInfo",
        "description": "Get detailed information about a Spotify item (track, album, artist, or playlist).",
        "inputSchema": {
          "description": "Get detailed information about a Spotify item (track, album, artist, or playlist).",
          "properties": {
            "item_uri": {
              "description": "URI of the item to get information about. If 'playlist' or 'album', returns its tracks. If 'artist', returns albums and top tracks.",
              "title": "Item Uri",
              "type": "string"
            }
          },
          "required": [
            "item_uri"
          ],
          "title": "GetInfo",
          "type": "object"
        }
      }
    ]
  },
  "any-chat-completions": {
    "name": "any-chat-completions",
    "display_name": "Any Chat Completions",
    "description": "Interact with any OpenAI SDK Compatible Chat Completions API like OpenAI, Perplexity, Groq, xAI and many more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pyroprompts/any-chat-completions-mcp"
    },
    "homepage": "https://github.com/pyroprompts/any-chat-completions-mcp",
    "author": {
      "name": "pyroprompts"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Claude",
      "OpenAI",
      "API",
      "Chat Completion"
    ],
    "examples": [
      {
        "title": "OpenAI Integration",
        "description": "Integrate OpenAI into Claude Desktop",
        "prompt": "Configure the MCP server to use OpenAI's API."
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/pyroprompts/any-chat-completions-mcp"
        ],
        "env": {
          "AI_CHAT_KEY": "${AI_CHAT_KEY}",
          "AI_CHAT_NAME": "${AI_CHAT_NAME}",
          "AI_CHAT_MODEL": "${AI_CHAT_MODEL}",
          "AI_CHAT_BASE_URL": "${AI_CHAT_BASE_URL}"
        }
      }
    },
    "arguments": {
      "AI_CHAT_KEY": {
        "description": "API key for authentication with the chat service provider.",
        "required": true,
        "example": "your_openai_secret_key_here"
      },
      "AI_CHAT_NAME": {
        "description": "The name of the AI chat provider to use, like 'OpenAI' or 'PyroPrompts'.",
        "required": true,
        "example": "OpenAI"
      },
      "AI_CHAT_MODEL": {
        "description": "Specifies which model to be used for the chat service, e.g., 'gpt-4o'.",
        "required": true,
        "example": "gpt-4o"
      },
      "AI_CHAT_BASE_URL": {
        "description": "The base URL for the API service of the chat provider.",
        "required": true,
        "example": "https://api.openai.com/v1"
      }
    },
    "tools": [
      {
        "name": "chat-with-${AI_CHAT_NAME_CLEAN}",
        "description": "Text chat with ${AI_CHAT_NAME}",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the chat to send to ${AI_CHAT_NAME}"
            }
          },
          "required": [
            "content"
          ]
        }
      }
    ]
  },
  "google-tasks": {
    "name": "google-tasks",
    "display_name": "Google Tasks",
    "description": "Google Tasks API Model Context Protocol Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/gtasks-mcp"
    },
    "homepage": "https://github.com/zcaceres/gtasks-mcp",
    "author": {
      "name": "zcaceres"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "google",
      "tasks",
      "productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/gtasks-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search for tasks in Google Tasks.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for tasks"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "list",
        "description": "List all tasks in Google Tasks.",
        "inputSchema": {
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "create",
        "description": "Create a new task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID",
            "optional": true
          },
          "title": {
            "type": "string",
            "description": "Task title"
          },
          "notes": {
            "type": "string",
            "description": "Task notes",
            "optional": true
          },
          "due": {
            "type": "string",
            "description": "Due date",
            "optional": true
          }
        },
        "required": [
          "title"
        ]
      },
      {
        "name": "update",
        "description": "Update an existing task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID",
            "optional": true
          },
          "id": {
            "type": "string",
            "description": "Task ID"
          },
          "uri": {
            "type": "string",
            "description": "Task URI"
          },
          "title": {
            "type": "string",
            "description": "New task title",
            "optional": true
          },
          "notes": {
            "type": "string",
            "description": "New task notes",
            "optional": true
          },
          "status": {
            "type": "string",
            "description": "New task status ('needsAction' or 'completed')",
            "optional": true
          },
          "due": {
            "type": "string",
            "description": "New due date",
            "optional": true
          }
        },
        "required": [
          "id",
          "uri"
        ]
      },
      {
        "name": "delete",
        "description": "Delete a task in Google Tasks.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID"
          },
          "id": {
            "type": "string",
            "description": "Task ID"
          }
        },
        "required": [
          "taskListId",
          "id"
        ]
      },
      {
        "name": "clear",
        "description": "Clear completed tasks from a Google Tasks task list.",
        "inputSchema": {
          "taskListId": {
            "type": "string",
            "description": "Task list ID"
          }
        },
        "required": [
          "taskListId"
        ]
      }
    ]
  },
  "xmind": {
    "name": "xmind",
    "display_name": "XMind",
    "description": "Read and search through your XMind directory containing XMind files.",
    "repository": {
      "type": "git",
      "url": "https://github.com/apeyroux/mcp-xmind"
    },
    "homepage": "https://github.com/apeyroux/mcp-xmind",
    "license": "MIT",
    "author": {
      "name": "apeyroux"
    },
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "XMind",
      "Mind Mapping",
      "Analysis",
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@41px/mcp-xmind",
          "${USER_XMIND_DIRECTORY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Search for Nodes",
        "description": "Searches through the mind map for specific nodes based on the query parameters.",
        "prompt": "{\"name\": \"search_nodes\", \"arguments\": {\"path\": \"/path/to/file.xmind\", \"query\": \"project\", \"searchIn\": [\"title\", \"notes\"], \"caseSensitive\": false}}"
      },
      {
        "title": "Extract Node",
        "description": "Extracts a node from the mind map based on a search query.",
        "prompt": "{\"name\": \"extract_node\", \"arguments\": {\"path\": \"/path/to/file.xmind\", \"searchQuery\": \"Feature > API\"}}"
      },
      {
        "title": "List Tasks",
        "description": "Lists TODO tasks from the mind map.",
        "prompt": "{\"name\": \"get_todo_tasks\", \"arguments\": {\"path\": \"/path/to/file.xmind\"}}"
      }
    ],
    "arguments": {
      "USER_XMIND_DIRECTORY": {
        "description": "The path to the directory containing XMind files that should be processed by the server.",
        "required": true,
        "example": "/Users/alex/XMind"
      }
    },
    "tools": [
      {
        "name": "read_xmind",
        "description": "Parse and analyze XMind files with multiple capabilities:\n                - Extract complete mind map structure in JSON format\n                - Include all relationships between nodes with their IDs and titles\n                - Extract callouts attached to topics\n                - Generate text or markdown summaries\n                - Search for specific content\n                - Get hierarchical path to any node\n                - Filter content by labels, task status, or node depth\n                - Extract all URLs and external references\n                - Analyze relationships and connections between topics\n                Input: File path to .xmind file\n                Output: JSON structure containing nodes, relationships, and callouts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_xmind_directory",
        "description": "Comprehensive XMind file discovery and analysis tool:\n                - Recursively scan directories for .xmind files\n                - Filter files by creation/modification date\n                - Search for files containing specific content\n                - Group files by project or category\n                - Detect duplicate mind maps\n                - Generate directory statistics and summaries\n                - Verify file integrity and structure\n                - Monitor changes in mind map files\n                Input: Directory path to scan\n                Output: List of XMind files with optional metadata",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directory": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "read_multiple_xmind_files",
        "description": "Advanced multi-file analysis and correlation tool:\n                - Process multiple XMind files simultaneously\n                - Compare content across different mind maps\n                - Identify common themes and patterns\n                - Merge related content from different files\n                - Generate cross-reference reports\n                - Find content duplications across files\n                - Create consolidated summaries\n                - Track changes across multiple versions\n                - Generate comparative analysis\n                Input: Array of file paths to .xmind files\n                Output: Combined analysis results in JSON format with per-file details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "search_xmind_files",
        "description": "Advanced file search tool with recursive capabilities:\n                - Search for files and directories by partial name matching\n                - Case-insensitive pattern matching\n                - Searches through all subdirectories recursively\n                - Returns full paths to all matching items\n                - Includes both files and directories in results\n                - Safe searching within allowed directories only\n                - Handles special characters in names\n                - Continues searching even if some directories are inaccessible\n                Input: {\n                    directory: Starting directory path,\n                    pattern: Search text to match in names\n                }\n                Output: Array of full paths to matching items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string"
            },
            "directory": {
              "type": "string"
            }
          },
          "required": [
            "pattern"
          ]
        }
      },
      {
        "name": "extract_node",
        "description": "Smart node extraction with fuzzy path matching:\n                - Flexible search using partial or complete node paths\n                - Returns multiple matching nodes ranked by relevance\n                - Supports approximate matching for better results\n                - Includes full context and hierarchy information\n                - Returns complete subtree for each match\n                - Best tool for exploring and navigating complex mind maps\n                - Perfect for finding nodes when exact path is unknown\n                Usage examples:\n                - \"Project > Backend\" : finds nodes in any path containing these terms\n                - \"Feature API\" : finds nodes containing these words in any order\n                Input: {\n                    path: Path to .xmind file,\n                    searchQuery: Text to search in node paths (flexible matching)\n                }\n                Output: Ranked list of matching nodes with their full subtrees",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "searchQuery": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "searchQuery"
          ]
        }
      },
      {
        "name": "extract_node_by_id",
        "description": "Extract a specific node and its subtree using its unique ID:\n                - Find and extract node using its XMind ID\n                - Return complete subtree structure\n                - Preserve all node properties and relationships\n                - Fast direct access without path traversal\n                Note: For a more detailed view with fuzzy matching, use \"extract_node\" with the node's path\n                Input: {\n                    path: Path to .xmind file,\n                    nodeId: Unique identifier of the node\n                }\n                Output: JSON structure of the found node and its subtree",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "nodeId": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "nodeId"
          ]
        }
      },
      {
        "name": "search_nodes",
        "description": "Advanced node search with multiple criteria:\n                - Search through titles, notes, labels, callouts and tasks\n                - Filter by task status (todo/done)\n                - Find nodes by their relationships\n                - Configure which fields to search in\n                - Case-sensitive or insensitive search\n                - Get full context including task status\n                - Returns all matching nodes with their IDs\n                - Includes relationship information and task status\n                Input: {\n                    path: Path to .xmind file,\n                    query: Search text,\n                    searchIn: Array of fields to search in ['title', 'notes', 'labels', 'callouts', 'tasks'],\n                    taskStatus: 'todo' | 'done' (optional),\n                    caseSensitive: Boolean (optional)\n                }\n                Output: Detailed search results with task status and context",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "query": {
              "type": "string"
            },
            "searchIn": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "title",
                  "notes",
                  "labels",
                  "callouts",
                  "tasks"
                ]
              }
            },
            "caseSensitive": {
              "type": "boolean"
            },
            "taskStatus": {
              "type": "string",
              "enum": [
                "todo",
                "done"
              ]
            }
          },
          "required": [
            "path",
            "query"
          ]
        }
      }
    ]
  },
  "influxdb": {
    "name": "influxdb",
    "display_name": "InfluxDB",
    "description": "Run queries against InfluxDB OSS API v2.",
    "repository": {
      "type": "git",
      "url": "https://github.com/idoru/influxdb-mcp-server"
    },
    "homepage": "https://github.com/idoru/influxdb-mcp-server",
    "author": {
      "name": "idoru"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "InfluxDB",
      "API",
      "server",
      "time-series"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "${INFLUXDB_TOKEN}",
          "${INFLUXDB_URL}",
          "${INFLUXDB_ORG}"
        ],
        "env": {
          "INFLUXDB_TOKEN": "your_token",
          "INFLUXDB_URL": "http://localhost:8086",
          "INFLUXDB_ORG": "your_org"
        }
      }
    },
    "arguments": {
      "INFLUXDB_TOKEN": {
        "description": "Authentication token for the InfluxDB API",
        "required": true,
        "example": "your_token"
      },
      "INFLUXDB_URL": {
        "description": "URL of the InfluxDB instance",
        "required": false,
        "example": "http://localhost:8086"
      },
      "INFLUXDB_ORG": {
        "description": "Default organization name for certain operations",
        "required": false,
        "example": "your_org"
      }
    },
    "tools": [
      {
        "name": "write-data",
        "description": "Write data to InfluxDB in line protocol format.",
        "inputSchema": {
          "org": {
            "type": "string",
            "description": "The organization name"
          },
          "bucket": {
            "type": "string",
            "description": "The bucket name"
          },
          "data": {
            "type": "string",
            "description": "Data in InfluxDB line protocol format"
          },
          "precision": {
            "type": "string",
            "enum": [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "description": "Timestamp precision (ns, us, ms, s)"
          }
        },
        "required": [
          "org",
          "bucket",
          "data"
        ]
      },
      {
        "name": "query-data",
        "description": "Execute a Flux query on InfluxDB data.",
        "inputSchema": {
          "org": {
            "type": "string",
            "description": "The organization name"
          },
          "query": {
            "type": "string",
            "description": "Flux query string"
          }
        },
        "required": [
          "org",
          "query"
        ]
      },
      {
        "name": "create-bucket",
        "description": "Create a new bucket in InfluxDB.",
        "inputSchema": {
          "name": {
            "type": "string",
            "description": "The bucket name"
          },
          "orgID": {
            "type": "string",
            "description": "The organization ID"
          },
          "retentionPeriodSeconds": {
            "type": "number",
            "description": "Retention period in seconds (optional)"
          }
        },
        "required": [
          "name",
          "orgID"
        ]
      },
      {
        "name": "create-org",
        "description": "Create a new organization in InfluxDB.",
        "inputSchema": {
          "name": {
            "type": "string",
            "description": "The organization name"
          },
          "description": {
            "type": "string",
            "description": "Organization description (optional)"
          }
        },
        "required": [
          "name"
        ]
      }
    ]
  },
  "mssql": {
    "name": "mssql",
    "display_name": "MSSQL",
    "description": "MCP Server for MSSQL database in Python",
    "repository": {
      "type": "git",
      "url": "https://github.com/JexinSam/mssql_mcp_server"
    },
    "homepage": "https://github.com/JexinSam/mssql_mcp_server",
    "author": {
      "name": "JexinSam"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MSSQL",
      "AI",
      "Database Access"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mssql_mcp_server"
        ],
        "env": {
          "MSSQL_DRIVER": "${MSSQL_DRIVER}",
          "MSSQL_HOST": "${MSSQL_HOST}",
          "MSSQL_USER": "${MSSQL_USER}",
          "MSSQL_PASSWORD": "${MSSQL_PASSWORD}",
          "MSSQL_DATABASE": "${MSSQL_DATABASE}"
        }
      }
    },
    "arguments": {
      "MSSQL_DRIVER": {
        "description": "Environment variable that specifies the driver to connect to the MSSQL database.",
        "required": true,
        "example": "mssql_driver"
      },
      "MSSQL_HOST": {
        "description": "Environment variable that specifies the hostname or IP address of the MSSQL server.",
        "required": true,
        "example": "localhost"
      },
      "MSSQL_USER": {
        "description": "Environment variable that defines the username for connecting to the MSSQL database.",
        "required": true,
        "example": "your_username"
      },
      "MSSQL_PASSWORD": {
        "description": "Environment variable that stores the password for the MSSQL user.",
        "required": true,
        "example": "your_password"
      },
      "MSSQL_DATABASE": {
        "description": "Environment variable that specifies the name of the MSSQL database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the MSSQL server",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "The SQL query to execute"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "n8n": {
    "name": "n8n",
    "display_name": "n8n",
    "description": "This MCP server provides tools and resources for AI assistants to manage n8n workflows and executions, including listing, creating, updating, and deleting workflows, as well as monitoring their execution status.",
    "repository": {
      "type": "git",
      "url": "https://github.com/leonardsellem/n8n-mcp-server"
    },
    "homepage": "https://github.com/leonardsellem/n8n-mcp-server",
    "author": {
      "name": "leonardsellem"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "n8n",
      "server",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@anaisbetts/mcp-installer"
        ],
        "env": {
          "N8N_API_URL": "${N8N_API_URL}",
          "N8N_API_KEY": "${N8N_API_KEY}"
        }
      }
    },
    "arguments": {
      "N8N_API_URL": {
        "description": "URL of the n8n API",
        "required": true,
        "example": "http://localhost:5678/api/v1"
      },
      "N8N_API_KEY": {
        "description": "API key for authenticating with n8n",
        "required": true,
        "example": "n8n_api_..."
      }
    },
    "tools": [
      {
        "name": "install_repo_mcp_server",
        "description": "Install an MCP server via npx or uvx",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The package name of the MCP server"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "install_local_mcp_server",
        "description": "Install an MCP server whose code is cloned locally on your computer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path to the MCP server code cloned on your computer"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "bing-web-search-api": {
    "name": "bing-web-search-api",
    "display_name": "Bing Search API",
    "description": "Server implementation for Microsoft Bing Web Search API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/leehanchung/bing-search-mcp"
    },
    "homepage": "https://github.com/leehanchung/bing-search-mcp",
    "author": {
      "name": "leehanchung"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Bing",
      "Search",
      "Web",
      "News",
      "Images"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+http://github.com/leehanchung/bing-search-mcp",
          "mcp-server-bing"
        ],
        "env": {
          "BING_API_KEY": "${BING_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Search the web for various queries.",
        "prompt": "Search for 'latest technology news'."
      },
      {
        "title": "News Search Example",
        "description": "Search for the latest news articles.",
        "prompt": "Search for 'global warming'."
      },
      {
        "title": "Image Search Example",
        "description": "Find images related to a query.",
        "prompt": "Search for 'sunsets'."
      }
    ],
    "arguments": {
      "BING_API_KEY": {
        "description": "API key required for authenticating requests to the Microsoft Bing Search API.",
        "required": true,
        "example": "your-bing-api-key"
      }
    },
    "tools": [
      {
        "name": "bing_web_search",
        "description": "Performs a web search using the Bing Search API for general information\n    and websites.\n\n    Args:\n        query: Search query (required)\n        count: Number of results (1-50, default 10)\n        offset: Pagination offset (default 0)\n        market: Market code like en-US, en-GB, etc.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "offset": {
              "default": 0,
              "title": "Offset",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_web_searchArguments",
          "type": "object"
        }
      },
      {
        "name": "bing_news_search",
        "description": "Searches for news articles using Bing News Search API for current\n    events and timely information.\n\n    Args:\n        query: News search query (required)\n        count: Number of results (1-50, default 10)\n        market: Market code like en-US, en-GB, etc.\n        freshness: Time period of news (Day, Week, Month)\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            },
            "freshness": {
              "default": "Day",
              "title": "Freshness",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_news_searchArguments",
          "type": "object"
        }
      },
      {
        "name": "bing_image_search",
        "description": "Searches for images using Bing Image Search API for visual content.\n\n    Args:\n        query: Image search query (required)\n        count: Number of results (1-50, default 10)\n        market: Market code like en-US, en-GB, etc.\n    ",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "count": {
              "default": 10,
              "title": "Count",
              "type": "integer"
            },
            "market": {
              "default": "en-US",
              "title": "Market",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "bing_image_searchArguments",
          "type": "object"
        }
      }
    ]
  },
  "image-generation": {
    "name": "image-generation",
    "display_name": "Image Generation",
    "description": "This MCP server provides image generation capabilities using the Replicate Flux model.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Image-Generation-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Image-Generation-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "image",
      "generation",
      "flux",
      "Replicate"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/image-gen-server"
        ],
        "env": {
          "REPLICATE_API_TOKEN": "${REPLICATE_API_TOKEN}",
          "MODEL": "${MODEL}",
          "your-replicate-api-token": "${your_replicate_api_token}",
          "alternative-model-name": "${alternative_model_name}"
        }
      }
    },
    "arguments": {
      "REPLICATE_API_TOKEN": {
        "description": "Your Replicate API token for authentication",
        "required": true,
        "example": "your-replicate-api-token"
      },
      "MODEL": {
        "description": "The Replicate model to use for image generation. Defaults to \"black-forest-labs/flux-schnell\"",
        "required": false,
        "example": "alternative-model-name"
      }
    },
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate an image using the Flux model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Prompt for generated image"
            },
            "seed": {
              "type": "integer",
              "description": "Random seed for reproducible generation"
            },
            "aspect_ratio": {
              "type": "string",
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "description": "Aspect ratio for the generated image",
              "default": "1:1"
            },
            "output_format": {
              "type": "string",
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "description": "Format of the output images",
              "default": "webp"
            },
            "num_outputs": {
              "type": "integer",
              "description": "Number of outputs to generate (1-4)",
              "default": 1,
              "minimum": 1,
              "maximum": 4
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "aws-s3": {
    "name": "aws-s3",
    "display_name": "Sample S3 Model Context Protocol",
    "description": "A sample MCP server for AWS S3 that flexibly fetches objects from S3 such as PDF documents.",
    "repository": {
      "type": "git",
      "url": "https://github.com/aws-samples/sample-mcp-server-s3"
    },
    "homepage": "https://github.com/aws-samples/sample-mcp-server-s3",
    "author": {
      "name": "aws-samples"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "S3",
      "PDF",
      "aws"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "s3-mcp-server"
        ]
      }
    }
  },
  "markdownify": {
    "name": "markdownify",
    "display_name": "Markdownify",
    "description": "MCP to convert almost anything to Markdown (PPTX, HTML, PDF, Youtube Transcripts and more)",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/mcp-markdownify-server"
    },
    "homepage": "https://github.com/zcaceres/mcp-markdownify-server",
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "markdown",
      "conversion"
    ],
    "author": {
      "name": "zcaceres"
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/mcp-markdownify-server"
        ],
        "env": {
          "UV_PATH": "${UV_PATH}"
        }
      }
    },
    "arguments": {
      "UV_PATH": {
        "description": "Environment variable specifying the installation location of the `uv` dependency.",
        "required": false,
        "example": "/path/to/uv"
      }
    }
  },
  "openapi-schema": {
    "name": "openapi-schema",
    "display_name": "OpenAPI Schema Model Context Protocol",
    "description": "Allow LLMs to explore large [OpenAPI](https://www.openapis.org/) schemas without bloating the context.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hannesj/mcp-openapi-schema"
    },
    "homepage": "https://github.com/hannesj/mcp-openapi-schema",
    "author": {
      "name": "hannesj"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "OpenAPI",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-openapi-schema",
          "${ABSOLUTE_PATH_TO_OPENAPI_YAML}"
        ]
      }
    },
    "arguments": {
      "ABSOLUTE_PATH_TO_OPENAPI_YAML": {
        "description": "The absolute path to the OpenAPI YAML file that the MCP server will use to load the schema.",
        "required": true,
        "example": "/absolute/path/to/openapi.yaml"
      }
    },
    "tools": [
      {
        "name": "list-endpoints",
        "description": "Lists all API paths and their HTTP methods with summaries, organized by path",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-endpoint",
        "description": "Gets detailed information about a specific API endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-request-body",
        "description": "Gets the request body schema for a specific endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-response-schema",
        "description": "Gets the response schema for a specific endpoint, method, and status code",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            },
            "statusCode": {
              "type": "string",
              "default": "200"
            }
          },
          "required": [
            "path",
            "method"
          ]
        }
      },
      {
        "name": "get-path-parameters",
        "description": "Gets the parameters for a specific path",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "method": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list-components",
        "description": "Lists all schema components (schemas, parameters, responses, etc.)",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-component",
        "description": "Gets detailed definition for a specific component",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Component type (e.g., schemas, parameters, responses)"
            },
            "name": {
              "type": "string",
              "description": "Component name"
            }
          },
          "required": [
            "type",
            "name"
          ]
        }
      },
      {
        "name": "list-security-schemes",
        "description": "Lists all available security schemes",
        "inputSchema": {
          "type": "object"
        }
      },
      {
        "name": "get-examples",
        "description": "Gets examples for a specific component or endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "request",
                "response",
                "component"
              ],
              "description": "Type of example to retrieve"
            },
            "path": {
              "type": "string",
              "description": "API path (required for request/response examples)"
            },
            "method": {
              "type": "string",
              "description": "HTTP method (required for request/response examples)"
            },
            "statusCode": {
              "type": "string",
              "description": "Status code (for response examples)"
            },
            "componentType": {
              "type": "string",
              "description": "Component type (required for component examples)"
            },
            "componentName": {
              "type": "string",
              "description": "Component name (required for component examples)"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "search-schema",
        "description": "Searches across paths, operations, and schemas",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "Search pattern (case-insensitive)"
            }
          },
          "required": [
            "pattern"
          ]
        }
      }
    ]
  },
  "xcodebuild": {
    "name": "xcodebuild",
    "display_name": "Xcode Build",
    "description": "\ud83c\udf4e Build iOS Xcode workspace/project and feed back errors to llm.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ShenghaiWang/xcodebuild"
    },
    "homepage": "https://github.com/ShenghaiWang/xcodebuild",
    "author": {
      "name": "ShenghaiWang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "xcode",
      "mcpxcodebuild"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcpxcodebuild"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcpxcodebuild"
        ]
      }
    },
    "examples": [
      {
        "title": "Build iOS Project",
        "description": "Builds the iOS Xcode workspace/project located at a specified folder.",
        "prompt": "build --folder /path/to/your/project"
      }
    ],
    "tools": [
      {
        "name": "build",
        "description": "Build the iOS Xcode workspace/project in the folder",
        "inputSchema": {
          "description": "Parameters",
          "properties": {
            "folder": {
              "description": "The full path of the current folder that the iOS Xcode workspace/project sits",
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "folder"
          ],
          "title": "Folder",
          "type": "object"
        }
      },
      {
        "name": "test",
        "description": "Run test for the iOS Xcode workspace/project in the folder",
        "inputSchema": {
          "description": "Parameters",
          "properties": {
            "folder": {
              "description": "The full path of the current folder that the iOS Xcode workspace/project sits",
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "folder"
          ],
          "title": "Folder",
          "type": "object"
        }
      }
    ]
  },
  "azure-adx": {
    "name": "azure-adx",
    "display_name": "Azure Data Explorer",
    "description": "Query and analyze Azure Data Explorer databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pab1it0/adx-mcp-server"
    },
    "homepage": "https://github.com/pab1it0/adx-mcp-server",
    "author": {
      "name": "pab1it0"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Azure",
      "KQL",
      "Data Explorer"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pab1it0/adx-mcp-server",
          "adx-mcp-server"
        ],
        "env": {
          "ADX_CLUSTER_URL": "${ADX_CLUSTER_URL}",
          "ADX_DATABASE": "${ADX_DATABASE}"
        }
      }
    },
    "arguments": {
      "ADX_CLUSTER_URL": {
        "description": "The URL of the Azure Data Explorer cluster.",
        "required": true,
        "example": "https://yourcluster.region.kusto.windows.net"
      },
      "ADX_DATABASE": {
        "description": "The name of the Azure Data Explorer database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Executes a Kusto Query Language (KQL) query against the configured Azure Data Explorer database and returns the results as a list of dictionaries.",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "execute_queryArguments",
          "type": "object"
        }
      },
      {
        "name": "list_tables",
        "description": "Retrieves a list of all tables available in the configured Azure Data Explorer database, including their names, folders, and database associations.",
        "inputSchema": {
          "properties": {},
          "title": "list_tablesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_table_schema",
        "description": "Retrieves the schema information for a specified table in the Azure Data Explorer database, including column names, data types, and other schema-related metadata.",
        "inputSchema": {
          "properties": {
            "table_name": {
              "title": "Table Name",
              "type": "string"
            }
          },
          "required": [
            "table_name"
          ],
          "title": "get_table_schemaArguments",
          "type": "object"
        }
      },
      {
        "name": "sample_table_data",
        "description": "Retrieves a random sample of rows from the specified table in the Azure Data Explorer database. The sample_size parameter controls how many rows to return (default: 10).",
        "inputSchema": {
          "properties": {
            "table_name": {
              "title": "Table Name",
              "type": "string"
            },
            "sample_size": {
              "default": 10,
              "title": "Sample Size",
              "type": "integer"
            }
          },
          "required": [
            "table_name"
          ],
          "title": "sample_table_dataArguments",
          "type": "object"
        }
      }
    ]
  },
  "llm-context": {
    "name": "llm-context",
    "display_name": "LLM Context",
    "description": "Provides a repo-packing MCP tool with configurable profiles that specify file inclusion/exclusion patterns and optional prompts.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cyberchitta/llm-context.py"
    },
    "homepage": "https://github.com/cyberchitta/llm-context.py",
    "author": {
      "name": "cyberchitta"
    },
    "license": "Apache 2.0",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "LLM",
      "Context Injection",
      "Development",
      "ChatGPT",
      "Productivity"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "llm-context",
          "lc-mcp"
        ]
      }
    },
    "arguments": {
      "mcp": {
        "description": "Indicates the model context protocol that should be used for communication.",
        "required": true,
        "example": "lc-mcp"
      }
    },
    "tools": [
      {
        "name": "lc-project-context",
        "description": "IMPORTANT: First check if project context is already available in the conversation before making any new requests. Use lc-get-files for retrieving specific files, and only use this tool when a broad repository overview is needed.\n\nGenerates a structured repository overview including: 1) Directory tree with file status (\u2713 full, \u25cb outline, \u2717 excluded) 2) Complete contents of key files 3) Smart outlines highlighting important definitions in supported languages. The output is customizable via profiles that control file inclusion rules and presentation format. The assistant tracks previously retrieved project context in the conversation and checks this history before making new requests.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use (e.g. 'code', 'copy', 'full') - defines file inclusion and presentation rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            }
          },
          "required": [
            "root_path"
          ],
          "title": "ContextRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-get-files",
        "description": "IMPORTANT: Check previously retrieved file contents before making new requests. Retrieves (read-only) complete contents of specified files from the project. For this project, this is the preferred method for all file content analysis and text searches - simply retrieve the relevant files and examine their contents. The assistant cannot modify files with this tool - it only reads their contents.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "paths": {
              "description": "File paths relative to root_path, starting with a forward slash and including the root directory name. For example, if root_path is '/home/user/projects/myproject', then a valid path would be '/myproject/src/main.py",
              "items": {
                "type": "string"
              },
              "title": "Paths",
              "type": "array"
            }
          },
          "required": [
            "root_path",
            "paths"
          ],
          "title": "FilesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-list-modified-files",
        "description": "IMPORTANT: First get the generation timestamp from the project context. Returns a list of paths to files that have been modified since a given timestamp. This is typically used to track which files have changed during the conversation. After getting the list, use lc-get-files to examine the contents of any modified files of interest.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use (e.g. 'code', 'copy', 'full') - defines file inclusion and presentation rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            },
            "timestamp": {
              "description": "Unix timestamp to check modifications since",
              "title": "Timestamp",
              "type": "number"
            }
          },
          "required": [
            "root_path",
            "timestamp"
          ],
          "title": "ListModifiedFilesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-code-outlines",
        "description": "Returns smart outlines highlighting important definitions in all supported code files. This provides a high-level overview of code structure without retrieving full file contents. Outlines show key definitions (classes, functions, methods) in the codebase. Use lc-get-implementations to retrieve the full implementation of any definition shown in these outlines.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "rule_name": {
              "default": "lc-code",
              "description": "Rule to use for file selection rules",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "title": "Rule Name",
              "type": "string"
            }
          },
          "required": [
            "root_path"
          ],
          "title": "OutlinesRequest",
          "type": "object"
        }
      },
      {
        "name": "lc-get-implementations",
        "description": "Retrieves complete code implementations of definitions identified in code outlines. Provide a list of file paths and definition names to get their full implementations. This tool works with all supported languages except C and C++.",
        "inputSchema": {
          "properties": {
            "root_path": {
              "description": "Root directory path (e.g. '/home/user/projects/myproject')",
              "format": "path",
              "title": "Root Path",
              "type": "string"
            },
            "queries": {
              "description": "List of (file_path, definition_name) tuples to fetch implementations for",
              "items": {
                "maxItems": 2,
                "minItems": 2,
                "prefixItems": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "type": "array"
              },
              "title": "Queries",
              "type": "array"
            }
          },
          "required": [
            "root_path",
            "queries"
          ],
          "title": "ImplementationsRequest",
          "type": "object"
        }
      }
    ]
  },
  "gmail-headless": {
    "name": "gmail-headless",
    "display_name": "Headless Gmail Server",
    "description": "Remote hostable MCP server that can get and send Gmail messages without local credential or file system setup.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-headless-gmail"
    },
    "homepage": "https://github.com/baryhuang/mcp-headless-gmail",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Gmail",
      "Headless",
      "Docker",
      "API"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "buryhuang/mcp-headless-gmail:latest"
        ]
      }
    },
    "tools": [
      {
        "name": "gmail_refresh_token",
        "description": "Refresh the access token using the refresh token and client credentials",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token (optional if expired)"
          },
          "google_refresh_token": {
            "type": "string",
            "description": "Google OAuth2 refresh token"
          },
          "google_client_id": {
            "type": "string",
            "description": "Google OAuth2 client ID for token refresh"
          },
          "google_client_secret": {
            "type": "string",
            "description": "Google OAuth2 client secret for token refresh"
          }
        },
        "required": [
          "google_refresh_token",
          "google_client_id",
          "google_client_secret"
        ]
      },
      {
        "name": "gmail_get_recent_emails",
        "description": "Get the most recent emails from Gmail (returns metadata, snippets, and first 1k chars of body)",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "max_results": {
            "type": "integer",
            "description": "Maximum number of emails to return (default: 10)"
          },
          "unread_only": {
            "type": "boolean",
            "description": "Whether to return only unread emails (default: False)"
          }
        },
        "required": [
          "google_access_token"
        ]
      },
      {
        "name": "gmail_get_email_body_chunk",
        "description": "Get a 1k character chunk of an email body starting from the specified offset",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "message_id": {
            "type": "string",
            "description": "ID of the message to retrieve"
          },
          "thread_id": {
            "type": "string",
            "description": "ID of the thread to retrieve (will get the first message if multiple exist)"
          },
          "offset": {
            "type": "integer",
            "description": "Offset in characters to start from (default: 0)"
          }
        },
        "required": [
          "google_access_token"
        ]
      },
      {
        "name": "gmail_send_email",
        "description": "Send an email via Gmail",
        "inputSchema": {
          "google_access_token": {
            "type": "string",
            "description": "Google OAuth2 access token"
          },
          "to": {
            "type": "string",
            "description": "Recipient email address"
          },
          "subject": {
            "type": "string",
            "description": "Email subject"
          },
          "body": {
            "type": "string",
            "description": "Email body content (plain text)"
          },
          "html_body": {
            "type": "string",
            "description": "Email body content in HTML format (optional)"
          }
        },
        "required": [
          "google_access_token",
          "to",
          "subject",
          "body"
        ]
      }
    ]
  },
  "mac-messages-mcp": {
    "name": "mac-messages-mcp",
    "display_name": "Mac Messages",
    "description": "An MCP server that securely interfaces with your iMessage database via the Model Context Protocol (MCP), allowing LLMs to query and analyze iMessage conversations. It includes robust phone number validation, attachment processing, contact management, group chat handling, and full support for sending and receiving messages.",
    "repository": {
      "type": "git",
      "url": "https://github.com/carterlasalle/mac_messages_mcp"
    },
    "homepage": "https://github.com/carterlasalle/mac_messages_mcp",
    "author": {
      "name": "carterlasalle"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mac-messages-mcp"
        ]
      }
    },
    "tags": [
      "python",
      "mac",
      "messages"
    ],
    "tools": [
      {
        "name": "tool_get_recent_messages",
        "description": "\n    Get recent messages from the Messages app.\n    \n    Args:\n        hours: Number of hours to look back (default: 24)\n        contact: Filter by contact name, phone number, or email (optional)\n                Use \"contact:N\" to select a specific contact from previous matches\n    ",
        "inputSchema": {
          "properties": {
            "hours": {
              "default": 24,
              "title": "Hours",
              "type": "integer"
            },
            "contact": {
              "default": null,
              "title": "Contact",
              "type": "string"
            }
          },
          "title": "tool_get_recent_messagesArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_send_message",
        "description": "\n    Send a message using the Messages app.\n    \n    Args:\n        recipient: Phone number, email, contact name, or \"contact:N\" to select from matches\n                  For example, \"contact:1\" selects the first contact from a previous search\n        message: Message text to send\n        group_chat: Whether to send to a group chat (uses chat ID instead of buddy)\n    ",
        "inputSchema": {
          "properties": {
            "recipient": {
              "title": "Recipient",
              "type": "string"
            },
            "message": {
              "title": "Message",
              "type": "string"
            },
            "group_chat": {
              "default": false,
              "title": "Group Chat",
              "type": "boolean"
            }
          },
          "required": [
            "recipient",
            "message"
          ],
          "title": "tool_send_messageArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_find_contact",
        "description": "\n    Find a contact by name using fuzzy matching.\n    \n    Args:\n        name: The name to search for\n    ",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            }
          },
          "required": [
            "name"
          ],
          "title": "tool_find_contactArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_db_access",
        "description": "\n    Diagnose database access issues.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_db_accessArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_contacts",
        "description": "\n    List available contacts in the address book.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_contactsArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_check_addressbook",
        "description": "\n    Diagnose AddressBook access issues.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_check_addressbookArguments",
          "type": "object"
        }
      },
      {
        "name": "tool_get_chats",
        "description": "\n    List available group chats from the Messages app.\n    ",
        "inputSchema": {
          "properties": {},
          "title": "tool_get_chatsArguments",
          "type": "object"
        }
      }
    ]
  },
  "llamacloud": {
    "name": "llamacloud",
    "display_name": "LlamaCloud",
    "description": "Integrate the data stored in a managed index on [LlamaCloud](https://cloud.llamaindex.ai/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/run-llama/mcp-server-llamacloud"
    },
    "homepage": "https://github.com/run-llama/mcp-server-llamacloud",
    "author": {
      "name": "run-llama"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "LlamaCloud",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@llamaindex/mcp-server-llamacloud",
          "--index",
          "10k-SEC-Tesla",
          "--description",
          "10k SEC documents from 2023 for Tesla",
          "--index",
          "10k-SEC-Apple",
          "--description",
          "10k SEC documents from 2023 for Apple"
        ],
        "env": {
          "LLAMA_CLOUD_PROJECT_NAME": "<YOUR_PROJECT_NAME>",
          "LLAMA_CLOUD_API_KEY": "<YOUR_API_KEY>"
        }
      }
    },
    "arguments": {
      "LLAMA_CLOUD_PROJECT_NAME": {
        "description": "The name of your LlamaCloud project that you want to use with the transfer tools.",
        "required": true,
        "example": "MyProject"
      },
      "LLAMA_CLOUD_API_KEY": {
        "description": "Your API key for accessing LlamaCloud services, which is necessary for authentication.",
        "required": true,
        "example": "1234567890abcdef"
      }
    },
    "tools": [
      {
        "name": "get_information_10k_sec_tesla",
        "description": "Get information from the 10k-SEC-Tesla index. The index contains 10k SEC documents from 2023 for Tesla",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query used to get information from the 10k-SEC-Tesla index."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_information_10k_sec_apple",
        "description": "Get information from the 10k-SEC-Apple index. The index contains 10k SEC documents from 2023 for Apple",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query used to get information from the 10k-SEC-Apple index."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "replicate": {
    "name": "replicate",
    "display_name": "Replicate",
    "description": "Search, run and manage machine learning models on Replicate through a simple tool-based interface. Browse models, create predictions, track their status, and handle generated images.",
    "repository": {
      "type": "git",
      "url": "https://github.com/deepfates/mcp-replicate"
    },
    "homepage": "https://github.com/deepfates/mcp-replicate",
    "author": {
      "name": "deepfates"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Replicate",
      "API"
    ],
    "examples": [
      {
        "title": "Run a model prediction",
        "description": "Creates a prediction using a specified model and input parameters.",
        "prompt": "create_prediction(model_id='model_id_here', input_params='input_params_here')"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "mcp-replicate"
        ],
        "env": {
          "REPLICATE_API_TOKEN": "${REPLICATE_API_TOKEN}"
        }
      }
    },
    "arguments": {
      "REPLICATE_API_TOKEN": {
        "description": "Your Replicate API token to authenticate requests to the Replicate API. Needed for the server to function and fetch models or execute predictions.",
        "required": true,
        "example": "your_token_here"
      }
    },
    "tools": [
      {
        "name": "search_models",
        "description": "Search for models using semantic search",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_models",
        "description": "List available models with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Filter by model owner"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor"
            }
          }
        }
      },
      {
        "name": "list_collections",
        "description": "List available model collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Pagination cursor"
            }
          }
        }
      },
      {
        "name": "get_collection",
        "description": "Get details of a specific collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "slug": {
              "type": "string",
              "description": "Collection slug"
            }
          },
          "required": [
            "slug"
          ]
        }
      },
      {
        "name": "create_prediction",
        "description": "Create a new prediction using either a model version (for community models) or model name (for official models)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "version": {
              "type": "string",
              "description": "Model version ID to use (for community models)"
            },
            "model": {
              "type": "string",
              "description": "Model name to use (for official models)"
            },
            "input": {
              "type": "object",
              "description": "Input parameters for the model",
              "additionalProperties": true
            },
            "webhook_url": {
              "type": "string",
              "description": "Optional webhook URL for notifications"
            }
          },
          "oneOf": [
            {
              "required": [
                "version",
                "input"
              ]
            },
            {
              "required": [
                "model",
                "input"
              ]
            }
          ]
        }
      },
      {
        "name": "cancel_prediction",
        "description": "Cancel a running prediction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prediction_id": {
              "type": "string",
              "description": "ID of the prediction to cancel"
            }
          },
          "required": [
            "prediction_id"
          ]
        }
      },
      {
        "name": "get_prediction",
        "description": "Get details about a specific prediction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prediction_id": {
              "type": "string",
              "description": "ID of the prediction to get details for"
            }
          },
          "required": [
            "prediction_id"
          ]
        }
      },
      {
        "name": "list_predictions",
        "description": "List recent predictions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of predictions to return",
              "default": 10
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            }
          }
        }
      },
      {
        "name": "get_model",
        "description": "Get details of a specific model including available versions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "owner": {
              "type": "string",
              "description": "Model owner"
            },
            "name": {
              "type": "string",
              "description": "Model name"
            }
          },
          "required": [
            "owner",
            "name"
          ]
        }
      },
      {
        "name": "view_image",
        "description": "Display an image in the system's default web browser",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the image to display"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "clear_image_cache",
        "description": "Clear the image viewer cache",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_image_cache_stats",
        "description": "Get statistics about the image cache",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "brave-search": {
    "name": "brave-search",
    "display_name": "Brave Search",
    "description": "Web and local search using Brave's Search API",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/brave-search",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "brave",
      "search",
      "web",
      "local"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-brave-search"
        ],
        "env": {
          "BRAVE_API_KEY": "${BRAVE_API_KEY}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "BRAVE_API_KEY",
          "mcp/brave-search"
        ],
        "env": {
          "BRAVE_API_KEY": "${BRAVE_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Web Search Example",
        "description": "Execute a web search with pagination and filtering.",
        "prompt": "brave_web_search(query=\"example search\", count=10, offset=0)"
      },
      {
        "title": "Local Search Example",
        "description": "Search for local businesses and services.",
        "prompt": "brave_local_search(query=\"restaurants near me\", count=5)"
      }
    ],
    "arguments": {
      "BRAVE_API_KEY": {
        "description": "The API key required to authenticate requests to the Brave Search API.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      }
    },
    "tools": [
      {
        "name": "brave_web_search",
        "description": "Performs a web search using the Brave Search API, ideal for general queries, news, articles, and online content. Use this for broad information gathering, recent events, or when you need diverse web sources. Supports pagination, content filtering, and freshness controls. Maximum 20 results per request, with offset for pagination. ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query (max 400 chars, 50 words)"
            },
            "count": {
              "type": "number",
              "description": "Number of results (1-20, default 10)",
              "default": 10
            },
            "offset": {
              "type": "number",
              "description": "Pagination offset (max 9, default 0)",
              "default": 0
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "brave_local_search",
        "description": "Searches for local businesses and places using Brave's Local Search API. Best for queries related to physical locations, businesses, restaurants, services, etc. Returns detailed information including:\n- Business names and addresses\n- Ratings and review counts\n- Phone numbers and opening hours\nUse this when the query implies 'near me' or mentions specific locations. Automatically falls back to web search if no local results are found.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Local search query (e.g. 'pizza near Central Park')"
            },
            "count": {
              "type": "number",
              "description": "Number of results (1-20, default 5)",
              "default": 5
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "naver": {
    "name": "naver",
    "display_name": "Naver",
    "description": "This MCP server provides tools to interact with various Naver services, such as searching blogs, news, books, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/pfldy2850/py-mcp-naver"
    },
    "homepage": "https://github.com/pfldy2850/py-mcp-naver",
    "author": {
      "name": "pfldy2850"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Naver",
      "API",
      "OpenAPI",
      "Search"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/pfldy2850/py-mcp-naver.git",
          "src/server.py"
        ],
        "env": {
          "NAVER_CLIENT_ID": "${NAVER_CLIENT_ID}",
          "NAVER_CLIENT_SECRET": "${NAVER_CLIENT_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Blog Posts",
        "description": "Search blog posts on Naver using a query.",
        "prompt": "search_blog('your query here')"
      },
      {
        "title": "Search News Articles",
        "description": "Search news articles on Naver using a query.",
        "prompt": "search_news('your query here')"
      },
      {
        "title": "Search Books",
        "description": "Search books on Naver using a query.",
        "prompt": "search_book('your query here')"
      }
    ],
    "arguments": {
      "NAVER_CLIENT_ID": {
        "description": "The Client ID for accessing the Naver Open API, obtained from the Naver developer portal.",
        "required": true,
        "example": "your_naver_client_id"
      },
      "NAVER_CLIENT_SECRET": {
        "description": "The Client Secret for accessing the Naver Open API, obtained from the Naver developer portal.",
        "required": true,
        "example": "your_naver_client_secret"
      }
    },
    "tools": [
      {
        "name": "search_blog",
        "description": "Search blog posts on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for blog posts"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_news",
        "description": "Search news articles on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for news articles"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_book",
        "description": "Search books on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for books"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "get_book_adv",
        "description": "Get detailed book information using title or ISBN.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for book title or ISBN (optional)"
          },
          "d_titl": {
            "type": "string",
            "description": "Book title (optional)"
          },
          "d_isbn": {
            "type": "string",
            "description": "Book ISBN (optional)"
          }
        },
        "required": []
      },
      {
        "name": "adult_check",
        "description": "Check if a search term is adult content.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search term to check for adult content"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_encyc",
        "description": "Search encyclopedia entries on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for encyclopedia entries"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_cafe_article",
        "description": "Search articles in Naver cafes.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for cafe articles"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_kin",
        "description": "Search questions and answers on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for Q&A"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_local",
        "description": "Search local information on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for local information"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'random')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "fix_spelling",
        "description": "Correct spelling errors in a given text.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Text to correct spelling errors"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_webkr",
        "description": "Search web pages on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for web pages"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_image",
        "description": "Search images on Naver with filters.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for images"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          },
          "filter": {
            "type": "string",
            "description": "Filter for image search (default: 'all')"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_shop",
        "description": "Search shopping items on Naver with filters.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for shopping items"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          },
          "sort": {
            "type": "string",
            "description": "Sorting method (default: 'sim')"
          },
          "filter": {
            "type": "string",
            "description": "Filter for shopping search (optional)"
          },
          "exclude": {
            "type": "string",
            "description": "Exclude filter for shopping search (optional)"
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "search_doc",
        "description": "Search documents on Naver.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query for documents"
          },
          "display": {
            "type": "integer",
            "description": "Number of results to display (default: 10)"
          },
          "start": {
            "type": "integer",
            "description": "Starting index for pagination (default: 1)"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "kibela": {
    "name": "kibela",
    "display_name": "Kibela",
    "description": "Interact with Kibela API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kiwamizamurai/mcp-kibela-server"
    },
    "homepage": "https://github.com/kiwamizamurai/mcp-kibela-server",
    "author": {
      "name": "kiwamizamurai"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Kibela",
      "Integration"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kiwamizamurai/mcp-kibela-server"
        ],
        "env": {
          "KIBELA_TEAM": "${KIBELA_TEAM}",
          "KIBELA_TOKEN": "${KIBELA_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Search Kibela notes",
        "description": "Search through your Kibela notes using a query.",
        "prompt": "kibela_search_notes(\"my search query\")"
      },
      {
        "title": "Get latest notes",
        "description": "Retrieve your latest notes from Kibela.",
        "prompt": "kibela_get_my_notes()"
      },
      {
        "title": "Get note content",
        "description": "Fetch content of a specific note by ID.",
        "prompt": "kibela_get_note_content(\"note-id\")"
      }
    ],
    "arguments": {
      "KIBELA_TEAM": {
        "description": "Your Kibela team name",
        "required": true,
        "example": "your-team"
      },
      "KIBELA_TOKEN": {
        "description": "Your Kibela API token",
        "required": true,
        "example": "your-token"
      }
    },
    "tools": [
      {
        "name": "kibela_search_notes",
        "description": "Search Kibela notes with given query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "kibela_get_my_notes",
        "description": "Get your latest notes from Kibela",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of notes to fetch (max 50)",
              "default": 15
            }
          }
        }
      },
      {
        "name": "kibela_get_note_content",
        "description": "Get content and comments of a specific note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Note ID"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "whale-tracker-mcp": {
    "name": "whale-tracker-mcp",
    "display_name": "Whale Tracker",
    "description": "A mcp server for tracking cryptocurrency whale transactions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/whale-tracker-mcp"
    },
    "homepage": "https://github.com/kukapay/whale-tracker-mcp",
    "author": {
      "name": "kukapay"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "whale tracker",
      "cryptocurrency",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/whale-tracker-mcp",
          "whale-tracker-mcp"
        ],
        "env": {
          "WHALE_TRACKER_API_KEY": "your_api_key_here"
        }
      }
    },
    "examples": [
      {
        "title": "Fetch Recent Transactions",
        "description": "What are the latest whale transactions on Ethereum with a minimum value of $1,000,000?",
        "prompt": "What are the latest whale transactions on Ethereum with a minimum value of $1,000,000?"
      },
      {
        "title": "Get Transaction Details",
        "description": "Tell me about transaction ID 123456789.",
        "prompt": "Tell me about transaction ID 123456789."
      },
      {
        "title": "Analyze Whale Activity",
        "description": "Analyze recent whale transactions on Bitcoin.",
        "prompt": "Analyze recent whale transactions on Bitcoin."
      }
    ],
    "arguments": {
      "WHALE_TRACKER_API_KEY": {
        "description": "Environment variable to load the Whale Alert API key for the server.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "flightradar24": {
    "name": "flightradar24",
    "display_name": "Flightradar24",
    "description": "A Claude Desktop MCP server that helps you track flights in real-time using Flightradar24 data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sunsetcoder/flightradar24-mcp-server"
    },
    "author": {
      "name": "sunsetcoder"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Check Flight Status",
        "description": "Ask for the status of a specific flight.",
        "prompt": "What's the status of flight UA123?"
      },
      {
        "title": "Show Current Flights at Airport",
        "description": "Request to see all flights currently at an airport.",
        "prompt": "Show me all flights currently at SFO"
      },
      {
        "title": "Emergency Flights Query",
        "description": "Ask if there are emergency flights in the area.",
        "prompt": "Are there any emergency flights in the area?"
      },
      {
        "title": "International Flights Arrival",
        "description": "Request information on international flights arriving within a timeframe.",
        "prompt": "Show me all international flights arriving at SFO in the next 2 hours"
      }
    ],
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Flightradar24",
      "Flight Tracking"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/sunsetcoder/flightradar24-mcp-server"
        ],
        "env": {
          "FR24_API_KEY": "${FR24_API_KEY}",
          "FR24_API_URL": "${FR24_API_URL}"
        }
      }
    },
    "arguments": {
      "FR24_API_KEY": {
        "description": "Flightradar24 API key required for accessing flight data from the Flightradar24 API.",
        "required": true,
        "example": "your_actual_api_key_here"
      },
      "FR24_API_URL": {
        "description": "The base URL for calling the Flightradar24 API for fetching real-time flight data.",
        "required": false,
        "example": "https://fr24api.flightradar24.com"
      }
    }
  },
  "fantasy-pl": {
    "name": "fantasy-pl",
    "display_name": "Fantasy Premier League",
    "description": "Give your coding agent direct access to up-to date Fantasy Premier League data",
    "repository": {
      "type": "git",
      "url": "https://github.com/rishijatia/fantasy-pl-mcp"
    },
    "homepage": "https://github.com/rishijatia/fantasy-pl-mcp",
    "author": {
      "name": "rishijatia"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "FPL",
      "fantasy",
      "football"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "fpl-mcp"
        ]
      }
    },
    "examples": [
      {
        "title": "Compare Players",
        "description": "This example shows how to compare the statistics of two players.",
        "prompt": "Compare Mohamed Salah and Erling Haaland over the last 5 gameweeks."
      },
      {
        "title": "Find Players",
        "description": "This example demonstrates how to find players of a specific team.",
        "prompt": "Find all Arsenal midfielders."
      },
      {
        "title": "Current Gameweek Status",
        "description": "This example prompts for the current gameweek status.",
        "prompt": "What's the current gameweek status?"
      },
      {
        "title": "Top Forwards",
        "description": "This example retrieves the top 5 forwards by points.",
        "prompt": "Show me the top 5 forwards by points."
      }
    ]
  },
  "claudepost": {
    "name": "claudepost",
    "display_name": "Claude Post Email Management",
    "description": "ClaudePost enables seamless email management for Gmail, offering secure features like email search, reading, and sending.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ZilongXue/claude-post"
    },
    "homepage": "https://github.com/ZilongXue/claude-post",
    "author": {
      "name": "Zilong Xue"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Email Management",
      "Natural Language Processing"
    ],
    "examples": [
      {
        "title": "Search Emails",
        "description": "Search for emails using natural language commands.",
        "prompt": "Show me emails from last week."
      },
      {
        "title": "Read Email Content",
        "description": "Request to read specific email content.",
        "prompt": "Show me the content of email #12345."
      },
      {
        "title": "Send Emails",
        "description": "Send emails using voice commands.",
        "prompt": "I want to send an email to john@example.com."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ZilongXue/claude-post",
          "email-client"
        ]
      }
    },
    "tools": [
      {
        "name": "search-emails",
        "description": "Search emails within a date range and/or with specific keywords",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format (optional)"
            },
            "end_date": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format (optional)"
            },
            "keyword": {
              "type": "string",
              "description": "Keyword to search in email subject and body (optional)"
            },
            "folder": {
              "type": "string",
              "description": "Folder to search in ('inbox' or 'sent', defaults to 'inbox')",
              "enum": [
                "inbox",
                "sent"
              ]
            }
          }
        }
      },
      {
        "name": "get-email-content",
        "description": "Get the full content of a specific email by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email_id": {
              "type": "string",
              "description": "The ID of the email to retrieve"
            }
          },
          "required": [
            "email_id"
          ]
        }
      },
      {
        "name": "count-daily-emails",
        "description": "Count emails received for each day in a date range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format"
            },
            "end_date": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format"
            }
          },
          "required": [
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "send-email",
        "description": "CONFIRMATION STEP: Actually send the email after user confirms the details. Before calling this, first show the email details to the user for confirmation. Required fields: recipients (to), subject, and content. Optional: CC recipients.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of recipient email addresses (confirmed)"
            },
            "subject": {
              "type": "string",
              "description": "Confirmed email subject"
            },
            "content": {
              "type": "string",
              "description": "Confirmed email content"
            },
            "cc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of CC recipient email addresses (optional, confirmed)"
            }
          },
          "required": [
            "to",
            "subject",
            "content"
          ]
        }
      }
    ]
  },
  "quickchart": {
    "name": "quickchart",
    "display_name": "Quickchart",
    "description": "A Model Context Protocol server for generating charts using QuickChart.io",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/Quickchart-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/Quickchart-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "quickchart",
      "chart generation",
      "data visualization"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gongrzhe/quickchart-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "Basic bar chart",
        "description": "Generate a bar chart using Chart.js configuration.",
        "prompt": "{\"type\":\"bar\",\"data\":{\"labels\":[\"January\",\"February\",\"March\"],\"datasets\":[{\"label\":\"Sales\",\"data\":[65,59,80],\"backgroundColor\":\"rgb(75,192,192)\"}]},\"options\":{\"title\":{\"display\":true,\"text\":\"Monthly Sales\"}}}"
      }
    ],
    "arguments": {
      "client": {
        "description": "Specifies the client type for which the QuickChart Server is installed. In this case, it's for Claude.",
        "required": true,
        "example": "claude"
      }
    },
    "tools": [
      {
        "name": "generate_chart",
        "description": "Generate a chart using QuickChart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Chart type (bar, line, pie, doughnut, radar, polarArea, scatter, bubble, radialGauge, speedometer)"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels for data points"
            },
            "datasets": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "data": {
                    "type": "array"
                  },
                  "backgroundColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "borderColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "additionalConfig": {
                    "type": "object"
                  }
                },
                "required": [
                  "data"
                ]
              }
            },
            "title": {
              "type": "string"
            },
            "options": {
              "type": "object"
            }
          },
          "required": [
            "type",
            "datasets"
          ]
        }
      },
      {
        "name": "download_chart",
        "description": "Download a chart image to a local file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "config": {
              "type": "object",
              "description": "Chart configuration object"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the chart image should be saved"
            }
          },
          "required": [
            "config",
            "outputPath"
          ]
        }
      }
    ]
  },
  "puppeteer": {
    "name": "puppeteer",
    "display_name": "Puppeteer Browser Automation",
    "description": "Browser automation and web scraping",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/puppeteer",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "puppeteer",
      "automation",
      "javascript",
      "screenshots",
      "web"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-puppeteer"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "--init",
          "-e",
          "DOCKER_CONTAINER=true",
          "mcp/puppeteer"
        ]
      }
    },
    "tools": [
      {
        "name": "puppeteer_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "puppeteer_screenshot",
        "description": "Take a screenshot of the current page or a specific element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the screenshot"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for element to screenshot"
            },
            "width": {
              "type": "number",
              "description": "Width in pixels (default: 800)"
            },
            "height": {
              "type": "number",
              "description": "Height in pixels (default: 600)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "puppeteer_click",
        "description": "Click an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to click"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "puppeteer_fill",
        "description": "Fill out an input field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for input field"
            },
            "value": {
              "type": "string",
              "description": "Value to fill"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "puppeteer_select",
        "description": "Select an element on the page with Select tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to select"
            },
            "value": {
              "type": "string",
              "description": "Value to select"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "puppeteer_hover",
        "description": "Hover an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to hover"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "puppeteer_evaluate",
        "description": "Execute JavaScript in the browser console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JavaScript code to execute"
            }
          },
          "required": [
            "script"
          ]
        }
      }
    ]
  },
  "sqlite": {
    "name": "sqlite",
    "display_name": "SQLite",
    "description": "Database interaction and business intelligence capabilities",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sqlite",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "sqlite",
      "database",
      "business insights"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "-v",
          "mcp-test:/mcp",
          "mcp/sqlite",
          "--db-path",
          "/mcp/test.db"
        ]
      }
    },
    "examples": [
      {
        "title": "Interactive SQL Analysis",
        "description": "Guides users through database operations and insights generation.",
        "prompt": "mcp-demo -topic [business_domain]"
      }
    ],
    "tools": [
      {
        "name": "read_query",
        "description": "Execute a SELECT query on the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SELECT SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "write_query",
        "description": "Execute an INSERT, UPDATE, or DELETE query on the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_table",
        "description": "Create a new table in the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "CREATE TABLE SQL statement"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_tables",
        "description": "List all tables in the SQLite database",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "describe_table",
        "description": "Get the schema information for a specific table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the table to describe"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "append_insight",
        "description": "Add a business insight to the memo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "insight": {
              "type": "string",
              "description": "Business insight discovered from data analysis"
            }
          },
          "required": [
            "insight"
          ]
        }
      }
    ]
  },
  "dbhub": {
    "name": "dbhub",
    "display_name": "DBHub - Universal Database Gateway",
    "description": "Universal database MCP server connecting to MySQL, PostgreSQL, SQLite, DuckDB and etc.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bytebase/dbhub"
    },
    "homepage": "https://github.com/bytebase/dbhub/",
    "author": {
      "name": "bytebase"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Database Gateway",
      "PostgreSQL",
      "MySQL",
      "SQL Server",
      "SQLite"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "bytebase/dbhub",
          "--transport",
          "stdio",
          "--dsn",
          "${DATABASE_URL}"
        ]
      },
      "npx": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@bytebase/dbhub",
          "--transport",
          "stdio",
          "--dsn",
          "${DATABASE_URL}"
        ]
      }
    },
    "arguments": {
      "DATABASE_URL": {
        "description": "The database connection string which includes the user, password, host, port, and database name.",
        "required": true,
        "example": "postgres://user:password@localhost:5432/dbname?sslmode=disable"
      }
    },
    "tools": [
      {
        "name": "list_connectors",
        "description": "Lists all available database connectors and their sample DSNs. Indicates which connector is active based on the current DSN.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "run_query",
        "description": "Executes a SQL query and returns the results.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "SQL query to execute"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "obsidian-mcp": {
    "name": "obsidian-mcp",
    "display_name": "Obsidian",
    "description": "(by Steven Stavrakis) An MCP server for Obsidian.md with tools for searching, reading, writing, and organizing notes.",
    "repository": {
      "type": "git",
      "url": "https://github.com/StevenStavrakis/obsidian-mcp"
    },
    "homepage": "https://github.com/StevenStavrakis/obsidian-mcp",
    "author": {
      "name": "StevenStavrakis"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Obsidian",
      "AI",
      "Notes",
      "Productivity"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "obsidian-mcp",
          "${OBSIDIAN_VAULT_PATH}",
          "${OBSIDIAN_VAULT_PATH2}"
        ]
      }
    },
    "arguments": {
      "OBSIDIAN_VAULT_PATH": {
        "description": "Path to your Obsidian vault",
        "required": true
      },
      "OBSIDIAN_VAULT_PATH2": {
        "description": "Path to your second Obsidian vault",
        "required": false
      }
    },
    "examples": [
      {
        "title": "Read a note",
        "description": "Read the contents of a note.",
        "prompt": "read-note('note-id')"
      },
      {
        "title": "Create a new note",
        "description": "Create a new note in the vault.",
        "prompt": "create-note('note-name', 'note-content')"
      }
    ],
    "tools": [
      {
        "name": "create-note",
        "description": "Create a new note in the specified vault with markdown content.\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\" }\n- Subfolder note: { \"vault\": \"vault2\", \"filename\": \"note.md\", \"folder\": \"journal/2024\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault to create the note in"
            },
            "filename": {
              "type": "string",
              "minLength": 1,
              "description": "Just the note name without any path separators (e.g. 'my-note.md', NOT 'folder/my-note.md'). Will add .md extension if missing"
            },
            "content": {
              "type": "string",
              "minLength": 1,
              "description": "Content of the note in markdown format"
            },
            "folder": {
              "type": "string",
              "description": "Optional subfolder path relative to vault root (e.g. 'journal/subfolder'). Use this for the path instead of including it in filename"
            }
          },
          "required": [
            "vault",
            "filename",
            "content"
          ]
        }
      },
      {
        "name": "list-available-vaults",
        "description": "Lists all available vaults that can be used with other tools",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "edit-note",
        "description": "Edit an existing note in the specified vault.\n\n    There is a limited and discrete list of supported operations:\n    - append: Appends content to the end of the note\n    - prepend: Prepends content to the beginning of the note\n    - replace: Replaces the entire content of the note\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\", \"operation\": \"append\", \"content\": \"new content\" }\n- Subfolder note: { \"vault\": \"vault2\", \"filename\": \"note.md\", \"folder\": \"journal/2024\", \"operation\": \"append\", \"content\": \"new content\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "search-vault",
        "description": "Search for specific content within vault notes (NOT for listing available vaults - use the list-vaults prompt for that).\n\nThis tool searches through note contents and filenames for specific text or tags:\n- Content search: { \"vault\": \"vault1\", \"query\": \"hello world\", \"searchType\": \"content\" }\n- Filename search: { \"vault\": \"vault2\", \"query\": \"meeting-notes\", \"searchType\": \"filename\" }\n- Search both: { \"vault\": \"vault1\", \"query\": \"project\", \"searchType\": \"both\" }\n- Tag search: { \"vault\": \"vault2\", \"query\": \"tag:status/active\" }\n- Search in subfolder: { \"vault\": \"vault1\", \"query\": \"hello\", \"path\": \"journal/2024\" }\n\nNote: To get a list of available vaults, use the list-vaults prompt instead of this search tool.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault to search in"
            },
            "query": {
              "type": "string",
              "minLength": 1,
              "description": "Search query (required). For text search use the term directly, for tag search use tag: prefix"
            },
            "path": {
              "type": "string",
              "description": "Optional subfolder path within the vault to limit search scope"
            },
            "caseSensitive": {
              "type": "boolean",
              "default": false,
              "description": "Whether to perform case-sensitive search (default: false)"
            },
            "searchType": {
              "type": "string",
              "enum": [
                "content",
                "filename",
                "both"
              ],
              "default": "content",
              "description": "Type of search to perform (default: content)"
            }
          },
          "required": [
            "vault",
            "query"
          ]
        }
      },
      {
        "name": "move-note",
        "description": "Move/rename a note while preserving links",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "source": {
              "type": "string",
              "minLength": 1,
              "description": "Source path of the note relative to vault root (e.g., 'folder/note.md')"
            },
            "destination": {
              "type": "string",
              "minLength": 1,
              "description": "Destination path relative to vault root (e.g., 'new-folder/new-name.md')"
            }
          },
          "required": [
            "vault",
            "source",
            "destination"
          ]
        }
      },
      {
        "name": "create-directory",
        "description": "Create a new directory in the specified vault",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault where the directory should be created"
            },
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "Path of the directory to create (relative to vault root)"
            },
            "recursive": {
              "type": "boolean",
              "default": true,
              "description": "Create parent directories if they don't exist"
            }
          },
          "required": [
            "vault",
            "path"
          ]
        }
      },
      {
        "name": "delete-note",
        "description": "Delete a note, moving it to .trash by default or permanently deleting if specified",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "Path of the note relative to vault root (e.g., 'folder/note.md')"
            },
            "reason": {
              "type": "string",
              "description": "Optional reason for deletion (stored in trash metadata)"
            },
            "permanent": {
              "type": "boolean",
              "default": false,
              "description": "Whether to permanently delete instead of moving to trash (default: false)"
            }
          },
          "required": [
            "vault",
            "path"
          ]
        }
      },
      {
        "name": "add-tags",
        "description": "Add tags to notes in frontmatter and/or content.\n\nExamples:\n- Add to both locations: { \"files\": [\"note.md\"], \"tags\": [\"status/active\"] }\n- Add to frontmatter only: { \"files\": [\"note.md\"], \"tags\": [\"project/docs\"], \"location\": \"frontmatter\" }\n- Add to start of content: { \"files\": [\"note.md\"], \"tags\": [\"type/meeting\"], \"location\": \"content\", \"position\": \"start\" }",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the notes"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of note filenames to process (must have .md extension)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of tags to add (e.g., 'status/active', 'project/docs')"
            },
            "location": {
              "type": "string",
              "enum": [
                "frontmatter",
                "content",
                "both"
              ],
              "description": "Where to add tags (default: both)"
            },
            "normalize": {
              "type": "boolean",
              "description": "Whether to normalize tag format (e.g., ProjectActive -> project-active) (default: true)"
            },
            "position": {
              "type": "string",
              "enum": [
                "start",
                "end"
              ],
              "description": "Where to add inline tags in content (default: end)"
            }
          },
          "required": [
            "vault",
            "files",
            "tags"
          ]
        }
      },
      {
        "name": "remove-tags",
        "description": "Remove tags from notes in frontmatter and/or content.\n\nExamples:\n- Simple: { \"files\": [\"note.md\"], \"tags\": [\"project\", \"status\"] }\n- With hierarchy: { \"files\": [\"note.md\"], \"tags\": [\"work/active\", \"priority/high\"] }\n- With options: { \"files\": [\"note.md\"], \"tags\": [\"status\"], \"options\": { \"location\": \"frontmatter\" } }\n- Pattern matching: { \"files\": [\"note.md\"], \"options\": { \"patterns\": [\"status/*\"] } }\n- INCORRECT: { \"tags\": [\"#project\"] } (don't include # symbol)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the notes"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of note filenames to process (must have .md extension)"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of tags to remove (without # symbol). Example: ['project', 'work/active']"
            },
            "options": {
              "type": "object",
              "properties": {
                "location": {
                  "type": "string",
                  "enum": [
                    "frontmatter",
                    "content",
                    "both"
                  ],
                  "default": "both",
                  "description": "Where to remove tags from (default: both)"
                },
                "normalize": {
                  "type": "boolean",
                  "default": true,
                  "description": "Whether to normalize tag format (e.g., ProjectActive -> project-active) (default: true)"
                },
                "preserveChildren": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to preserve child tags when removing parent tags (default: false)"
                },
                "patterns": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "default": [],
                  "description": "Tag patterns to match for removal (supports * wildcard) (default: [])"
                }
              },
              "additionalProperties": false,
              "default": {
                "location": "both",
                "normalize": true,
                "preserveChildren": false,
                "patterns": []
              }
            }
          },
          "required": [
            "vault",
            "files",
            "tags"
          ]
        }
      },
      {
        "name": "rename-tag",
        "description": "Safely renames tags throughout the vault while preserving hierarchies.\n\nExamples:\n- Simple rename: { \"oldTag\": \"project\", \"newTag\": \"projects\" }\n- Rename with hierarchy: { \"oldTag\": \"work/active\", \"newTag\": \"projects/current\" }\n- With options: { \"oldTag\": \"status\", \"newTag\": \"state\", \"normalize\": true, \"createBackup\": true }\n- INCORRECT: { \"oldTag\": \"#project\" } (don't include # symbol)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the tags"
            },
            "oldTag": {
              "type": "string",
              "minLength": 1,
              "description": "The tag to rename (without #). Example: 'project' or 'work/active'"
            },
            "newTag": {
              "type": "string",
              "minLength": 1,
              "description": "The new tag name (without #). Example: 'projects' or 'work/current'"
            },
            "createBackup": {
              "type": "boolean",
              "default": true,
              "description": "Whether to create a backup before making changes (default: true)"
            },
            "normalize": {
              "type": "boolean",
              "default": true,
              "description": "Whether to normalize tag names (e.g., ProjectActive -> project-active) (default: true)"
            },
            "batchSize": {
              "type": "number",
              "minimum": 1,
              "maximum": 100,
              "default": 50,
              "description": "Number of files to process in each batch (1-100) (default: 50)"
            }
          },
          "required": [
            "vault",
            "oldTag",
            "newTag"
          ]
        }
      },
      {
        "name": "read-note",
        "description": "Read the content of an existing note in the vault.\n\nExamples:\n- Root note: { \"vault\": \"vault1\", \"filename\": \"note.md\" }\n- Subfolder note: { \"vault\": \"vault1\", \"filename\": \"note.md\", \"folder\": \"journal/2024\" }\n- INCORRECT: { \"filename\": \"journal/2024/note.md\" } (don't put path in filename)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "vault": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vault containing the note"
            },
            "filename": {
              "type": "string",
              "minLength": 1,
              "description": "Just the note name without any path separators (e.g. 'my-note.md', NOT 'folder/my-note.md')"
            },
            "folder": {
              "type": "string",
              "description": "Optional subfolder path relative to vault root"
            }
          },
          "required": [
            "vault",
            "filename"
          ]
        }
      }
    ]
  },
  "scholarly": {
    "name": "scholarly",
    "display_name": "scholarly",
    "description": "A MCP server to search for scholarly and academic articles.",
    "repository": {
      "type": "git",
      "url": "https://github.com/adityak74/mcp-scholarly"
    },
    "homepage": "https://github.com/adityak74/mcp-scholarly",
    "author": {
      "name": "adityak74"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "scholarly",
      "academic"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-scholarly"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/scholarly"
        ]
      }
    },
    "arguments": {
      "keyword": {
        "description": "The keyword to search for articles in arXiv.",
        "required": true,
        "example": "machine learning"
      }
    },
    "tools": [
      {
        "name": "search-arxiv",
        "description": "Search arxiv for articles related to the given keyword.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "search-google-scholar",
        "description": "Search google scholar for articles related to the given keyword.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            }
          },
          "required": [
            "keyword"
          ]
        }
      }
    ]
  },
  "fingertip": {
    "name": "fingertip",
    "display_name": "Fingertip",
    "description": "MCP server for Fingertip.com to search and create new sites.",
    "repository": {
      "type": "git",
      "url": "https://github.com/fingertip-com/fingertip-mcp"
    },
    "homepage": "https://github.com/fingertip-com/fingertip-mcp",
    "author": {
      "name": "fingertip-com"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Fingertip",
      "AI Assistants"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@fingertip/mcp"
        ]
      }
    }
  },
  "anki": {
    "name": "anki",
    "display_name": "Anki",
    "description": "An MCP server for interacting with your [Anki](https://apps.ankiweb.net/) decks and cards.",
    "repository": {
      "type": "git",
      "url": "https://github.com/scorzeth/anki-mcp-server"
    },
    "homepage": "https://github.com/scorzeth/anki-mcp-server",
    "author": {
      "name": "scorzeth"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "Anki",
      "Cards",
      "Review"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/scorzeth/anki-mcp-server"
        ],
        "description": "Run with npx (requires npm install)"
      }
    },
    "tools": [
      {
        "name": "update_cards",
        "description": "After the user answers cards you've quizzed them on, use this tool to mark them answered and update their ease",
        "inputSchema": {
          "type": "object",
          "properties": {
            "answers": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "cardId": {
                    "type": "number",
                    "description": "Id of the card to answer"
                  },
                  "ease": {
                    "type": "number",
                    "description": "Ease of the card between 1 (Again) and 4 (Easy)"
                  }
                }
              }
            }
          }
        }
      },
      {
        "name": "add_card",
        "description": "Create a new flashcard in Anki for the user. Must use HTML formatting only. IMPORTANT FORMATTING RULES:\n1. Must use HTML tags for ALL formatting - NO markdown\n2. Use <br> for ALL line breaks\n3. For code blocks, use <pre> with inline CSS styling\n4. Example formatting:\n   - Line breaks: <br>\n   - Code: <pre style=\"background-color: transparent; padding: 10px; border-radius: 5px;\">\n   - Lists: <ol> and <li> tags\n   - Bold: <strong>\n   - Italic: <em>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "front": {
              "type": "string",
              "description": "The front of the card. Must use HTML formatting only."
            },
            "back": {
              "type": "string",
              "description": "The back of the card. Must use HTML formatting only."
            }
          },
          "required": [
            "front",
            "back"
          ]
        }
      },
      {
        "name": "get_due_cards",
        "description": "Returns a given number (num) of cards due for review.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "num": {
              "type": "number",
              "description": "Number of due cards to get"
            }
          },
          "required": [
            "num"
          ]
        }
      },
      {
        "name": "get_new_cards",
        "description": "Returns a given number (num) of new and unseen cards.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "num": {
              "type": "number",
              "description": "Number of new cards to get"
            }
          },
          "required": [
            "num"
          ]
        }
      }
    ]
  },
  "obsidian-markdown-notes": {
    "name": "obsidian-markdown-notes",
    "display_name": "Obsidian Markdown Notes",
    "description": "Read and search through your Obsidian vault or any directory containing Markdown notes",
    "repository": {
      "type": "git",
      "url": "https://github.com/calclavia/mcp-obsidian"
    },
    "homepage": "https://github.com/calclavia/mcp-obsidian",
    "author": {
      "name": "calclavia"
    },
    "license": "APGL-3.0",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "obsidian"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/calclavia/mcp-obsidian.git",
          "${OBSIDIAN_VAULT_PATH}"
        ]
      }
    },
    "arguments": {
      "OBSIDIAN_VAULT_PATH": {
        "description": "Path to your Obsidian vault",
        "required": true
      }
    },
    "tools": [
      {
        "name": "read_notes",
        "description": "Read the contents of multiple notes. Each note's content is returned with its path as a reference. Failed reads for individual notes won't stop the entire operation. Reading too many at once may result in an error.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "search_notes",
        "description": "Searches for a note by its name. The search is case-insensitive and matches partial names. Queries can also be a valid regex. Returns paths of the notes that match the query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "video-editor": {
    "name": "video-editor",
    "display_name": "Video Editor",
    "description": "A Model Context Protocol Server to add, edit, and search videos with [Video Jungle](https://www.video-jungle.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/burningion/video-editing-mcp"
    },
    "homepage": "https://github.com/burningion/video-editing-mcp",
    "author": {
      "name": "burningion"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "video",
      "editing",
      "API"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/burningion/video-editing-mcp",
          "video-editor-mcp",
          "${YOURAPIKEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Add Video Example",
        "description": "Shows how to add a video from a URL.",
        "prompt": "can you download the video at https://www.youtube.com/shorts/RumgYaH5XYw and name it fly traps?"
      },
      {
        "title": "Search Videos Example",
        "description": "Example of searching videos with a keyword.",
        "prompt": "can you search my videos for fly traps?"
      },
      {
        "title": "Generate Edit Example",
        "description": "Creates an edit from found video segments.",
        "prompt": "can you create an edit of all the times the video says \"fly trap\"?"
      }
    ],
    "arguments": {
      "YOURAPIKEY": {
        "description": "API key required to authenticate and communicate with Video Jungle services.",
        "required": true,
        "example": "YOURAPIKEY"
      }
    },
    "tools": [
      {
        "name": "add-video",
        "description": "Upload video from URL. Begins analysis of video to allow for later information retrieval for automatic video editing an search.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "url": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "url"
          ]
        }
      },
      {
        "name": "search-remote-videos",
        "description": "Default method to search videos. Will return videos including video_ids, which allow for information retrieval and building video edits.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Text search query"
            },
            "limit": {
              "type": "integer",
              "default": 10,
              "minimum": 1,
              "description": "Maximum number of results to return"
            },
            "project_id": {
              "type": "string",
              "format": "uuid",
              "description": "Project ID to scope the search"
            },
            "duration_min": {
              "type": "number",
              "minimum": 0,
              "description": "Minimum video duration in seconds"
            },
            "duration_max": {
              "type": "number",
              "minimum": 0,
              "description": "Maximum video duration in seconds"
            }
          },
          "created_after": {
            "type": "string",
            "format": "date-time",
            "description": "Filter videos created after this datetime"
          },
          "created_before": {
            "type": "string",
            "format": "date-time",
            "description": "Filter videos created before this datetime"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "uniqueItems": true,
            "description": "Set of tags to filter by"
          },
          "include_segments": {
            "type": "boolean",
            "default": true,
            "description": "Whether to include video segments in results"
          },
          "include_related": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include related videos"
          },
          "query_audio": {
            "type": "string",
            "description": "Audio search query"
          },
          "query_img": {
            "type": "string",
            "description": "Image search query"
          },
          "oneOf": [
            {
              "required": [
                "query"
              ]
            }
          ]
        }
      },
      {
        "name": "search-local-videos",
        "description": "Search user's local videos in Photos app by keyword",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string"
            },
            "start_date": {
              "type": "string",
              "description": "ISO 8601 formatted datetime string (e.g. 2024-01-21T15:30:00Z)"
            },
            "end_date": {
              "type": "string",
              "description": "ISO 8601 formatted datetime string (e.g. 2024-01-21T15:30:00Z)"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "generate-edit-from-videos",
        "description": "Generate an edit from videos, from within a specific project. Creates a new project to work within no existing project ID (UUID) is passed ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Either an existing Project UUID or String. A UUID puts the edit in an existing project, and a string creates a new project with that name."
            },
            "name": {
              "type": "string",
              "description": "Video Edit name"
            },
            "open_editor": {
              "type": "boolean",
              "description": "Open a live editor with the project's edit"
            },
            "resolution": {
              "type": "string",
              "description": "Video resolution. Examples include '1920x1080', '1280x720'"
            },
            "edit": {
              "type": "array",
              "cuts": {
                "video_id": {
                  "type": "string",
                  "description": "Video UUID"
                },
                "video_start_time": {
                  "type": "string",
                  "description": "Clip start time in 00:00:00.000 format"
                },
                "video_end_time": {
                  "type": "string",
                  "description": "Clip end time in 00:00:00.000 format"
                }
              }
            }
          },
          "required": [
            "edit",
            "cuts",
            "name",
            "project_id"
          ]
        }
      },
      {
        "name": "generate-edit-from-single-video",
        "description": "Generate a compressed video edit from a single video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string"
            },
            "resolution": {
              "type": "string"
            },
            "video_id": {
              "type": "string"
            },
            "edit": {
              "type": "array",
              "cuts": {
                "video_start_time": "time",
                "video_end_time": "time"
              }
            }
          },
          "required": [
            "edit",
            "project_id",
            "video_id",
            "cuts"
          ]
        }
      },
      {
        "name": "update-video-edit",
        "description": "Update an existing video edit within a specific project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "UUID of the project containing the edit"
            },
            "edit_id": {
              "type": "string",
              "description": "UUID of the video edit to update"
            },
            "name": {
              "type": "string",
              "description": "Video Edit name"
            },
            "description": {
              "type": "string",
              "description": "Description of the video edit"
            },
            "video_output_format": {
              "type": "string",
              "description": "Output format for the video (e.g., 'mp4', 'webm')"
            },
            "video_output_resolution": {
              "type": "string",
              "description": "Video resolution. Examples include '1920x1080', '1280x720'"
            },
            "video_output_fps": {
              "type": "number",
              "description": "Frames per second for the output video"
            },
            "video_series_sequential": {
              "type": "array",
              "description": "Array of video clips in sequential order",
              "items": {
                "type": "object",
                "properties": {
                  "video_id": {
                    "type": "string",
                    "description": "Video UUID"
                  },
                  "video_start_time": {
                    "type": "string",
                    "description": "Clip start time in 00:00:00.000 format"
                  },
                  "video_end_time": {
                    "type": "string",
                    "description": "Clip end time in 00:00:00.000 format"
                  }
                }
              }
            },
            "audio_overlay": {
              "type": "object",
              "description": "Audio overlay settings and assets"
            },
            "rendered": {
              "type": "boolean",
              "description": "Whether the edit has been rendered"
            }
          },
          "required": [
            "project_id",
            "edit_id"
          ]
        }
      },
      {
        "name": "create-video-bar-chart-from-two-axis-data",
        "description": "Create a video bar chart from two-axis data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x_values": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "y_values": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "x_label": {
              "type": "string"
            },
            "y_label": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "filename": {
              "type": "string"
            }
          },
          "required": [
            "x_values",
            "y_values",
            "x_label",
            "y_label",
            "title"
          ]
        }
      },
      {
        "name": "create-video-line-chart-from-two-axis-data",
        "description": "Create a video line chart from two-axis data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x_values": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "y_values": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "x_label": {
              "type": "string"
            },
            "y_label": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "filename": {
              "type": "string"
            }
          },
          "required": [
            "x_values",
            "y_values",
            "x_label",
            "y_label",
            "title"
          ]
        }
      }
    ]
  },
  "mongodb": {
    "name": "mongodb",
    "display_name": "MongoDB",
    "description": "A Model Context Protocol Server for MongoDB.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kiliczsh/mcp-mongo-server"
    },
    "homepage": "https://github.com/kiliczsh/mcp-mongo-server",
    "author": {
      "name": "kiliczsh"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "MongoDB",
      "LLM"
    ],
    "arguments": {
      "MONGODB_URI": {
        "description": "The connection string for the MongoDB database.",
        "required": true,
        "example": "mongodb://muhammed:kilic@mongodb.localhost/sample_namespace"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-mongo-server",
          "${MONGODB_URI}"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Execute a MongoDB query with optional execution plan analysis",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to query"
            },
            "filter": {
              "type": "object",
              "description": "MongoDB query filter"
            },
            "projection": {
              "type": "object",
              "description": "Fields to include/exclude"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of documents to return"
            },
            "explain": {
              "type": "string",
              "description": "Optional: Get query execution information (queryPlanner, executionStats, or allPlansExecution)",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ]
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "aggregate",
        "description": "Execute a MongoDB aggregation pipeline with optional execution plan analysis",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to aggregate"
            },
            "pipeline": {
              "type": "array",
              "description": "Aggregation pipeline stages"
            },
            "explain": {
              "type": "string",
              "description": "Optional: Get aggregation execution information (queryPlanner, executionStats, or allPlansExecution)",
              "enum": [
                "queryPlanner",
                "executionStats",
                "allPlansExecution"
              ]
            }
          },
          "required": [
            "collection",
            "pipeline"
          ]
        }
      },
      {
        "name": "update",
        "description": "Update documents in a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to update"
            },
            "filter": {
              "type": "object",
              "description": "Filter to select documents to update"
            },
            "update": {
              "type": "object",
              "description": "Update operations to apply ($set, $unset, $inc, etc.)"
            },
            "upsert": {
              "type": "boolean",
              "description": "Create a new document if no documents match the filter"
            },
            "multi": {
              "type": "boolean",
              "description": "Update multiple documents that match the filter"
            }
          },
          "required": [
            "collection",
            "filter",
            "update"
          ]
        }
      },
      {
        "name": "serverInfo",
        "description": "Get MongoDB server information including version, storage engine, and other details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "includeDebugInfo": {
              "type": "boolean",
              "description": "Include additional debug information about the server"
            }
          }
        }
      },
      {
        "name": "insert",
        "description": "Insert one or more documents into a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to insert into"
            },
            "documents": {
              "type": "array",
              "description": "Array of documents to insert",
              "items": {
                "type": "object"
              }
            },
            "ordered": {
              "type": "boolean",
              "description": "Optional: If true, perform an ordered insert of the documents. If false, perform an unordered insert"
            },
            "writeConcern": {
              "type": "object",
              "description": "Optional: Write concern for the insert operation"
            },
            "bypassDocumentValidation": {
              "type": "boolean",
              "description": "Optional: Allow insert to bypass schema validation"
            }
          },
          "required": [
            "collection",
            "documents"
          ]
        }
      },
      {
        "name": "createIndex",
        "description": "Create one or more indexes on a MongoDB collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to create indexes on"
            },
            "indexes": {
              "type": "array",
              "description": "Array of index specifications",
              "items": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "object",
                    "description": "Index key pattern, e.g. { field: 1 } for ascending, { field: -1 } for descending"
                  },
                  "name": {
                    "type": "string",
                    "description": "Optional: Name of the index"
                  },
                  "unique": {
                    "type": "boolean",
                    "description": "Optional: If true, creates a unique index"
                  },
                  "sparse": {
                    "type": "boolean",
                    "description": "Optional: If true, creates a sparse index"
                  },
                  "background": {
                    "type": "boolean",
                    "description": "Optional: If true, creates the index in the background"
                  },
                  "expireAfterSeconds": {
                    "type": "number",
                    "description": "Optional: Specifies the TTL for documents (time to live)"
                  },
                  "partialFilterExpression": {
                    "type": "object",
                    "description": "Optional: Filter expression for partial indexes"
                  }
                },
                "required": [
                  "key"
                ]
              }
            },
            "writeConcern": {
              "type": "object",
              "description": "Optional: Write concern for the index creation"
            },
            "commitQuorum": {
              "type": [
                "string",
                "number"
              ],
              "description": "Optional: Number of voting members required to create index"
            }
          },
          "required": [
            "collection",
            "indexes"
          ]
        }
      },
      {
        "name": "count",
        "description": "Count the number of documents in a collection that match a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Name of the collection to count documents in"
            },
            "query": {
              "type": "object",
              "description": "Optional: Query filter to select documents to count"
            },
            "limit": {
              "type": "integer",
              "description": "Optional: Maximum number of documents to count"
            },
            "skip": {
              "type": "integer",
              "description": "Optional: Number of documents to skip before counting"
            },
            "hint": {
              "type": "object",
              "description": "Optional: Index hint to force query plan"
            },
            "readConcern": {
              "type": "object",
              "description": "Optional: Read concern for the count operation"
            },
            "maxTimeMS": {
              "type": "integer",
              "description": "Optional: Maximum time to allow the count to run"
            },
            "collation": {
              "type": "object",
              "description": "Optional: Collation rules for string comparison"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "listCollections",
        "description": "List all collections in the MongoDB database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nameOnly": {
              "type": "boolean",
              "description": "Optional: If true, returns only the collection names instead of full collection info"
            },
            "filter": {
              "type": "object",
              "description": "Optional: Filter to apply to the collections"
            }
          }
        }
      }
    ]
  },
  "data-exploration": {
    "name": "data-exploration",
    "display_name": "Data Exploration",
    "description": "MCP server for autonomous data exploration on .csv-based datasets, providing intelligent insights with minimal effort. NOTE: Will execute arbitrary Python code on your machine, please use with caution!",
    "repository": {
      "type": "git",
      "url": "https://github.com/reading-plus-ai/mcp-server-data-exploration"
    },
    "homepage": "https://github.com/reading-plus-ai/mcp-server-data-exploration",
    "author": {
      "name": "reading-plus-ai"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "data",
      "exploration"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-ds"
        ]
      }
    },
    "examples": [
      {
        "title": "California Real Estate Listing Prices",
        "description": "Exploring housing price trends in California using a dataset.",
        "prompt": "csv_path: Local path to the CSV file, topic: Housing price trends in California."
      },
      {
        "title": "Weather in London",
        "description": "Investigating daily weather history in London using a dataset.",
        "prompt": "csv_path: Local path to the CSV file, topic: Weather in London."
      }
    ],
    "tools": [
      {
        "name": "load_csv",
        "description": "\nLoad CSV File Tool\n\nPurpose:\nLoad a local CSV file into a DataFrame.\n\nUsage Notes:\n\t\u2022\tIf a df_name is not provided, the tool will automatically assign names sequentially as df_1, df_2, and so on.\n",
        "inputSchema": {
          "properties": {
            "csv_path": {
              "title": "Csv Path",
              "type": "string"
            },
            "df_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Df Name"
            }
          },
          "required": [
            "csv_path"
          ],
          "title": "LoadCsv",
          "type": "object"
        }
      },
      {
        "name": "run_script",
        "description": "\nPython Script Execution Tool\n\nPurpose:\nExecute Python scripts for specific data analytics tasks.\n\nAllowed Actions\n\t1.\tPrint Results: Output will be displayed as the script\u2019s stdout.\n\t2.\t[Optional] Save DataFrames: Store DataFrames in memory for future use by specifying a save_to_memory name.\n\nProhibited Actions\n\t1.\tOverwriting Original DataFrames: Do not modify existing DataFrames to preserve their integrity for future tasks.\n\t2.\tCreating Charts: Chart generation is not permitted.\n",
        "inputSchema": {
          "properties": {
            "script": {
              "title": "Script",
              "type": "string"
            },
            "save_to_memory": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Save To Memory"
            }
          },
          "required": [
            "script"
          ],
          "title": "RunScript",
          "type": "object"
        }
      }
    ]
  },
  "tmdb": {
    "name": "tmdb",
    "display_name": "TMDB",
    "description": "This MCP server integrates with The Movie Database (TMDB) API to provide movie information, search capabilities, and recommendations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Laksh-star/mcp-server-tmdb"
    },
    "homepage": "https://github.com/Laksh-star/mcp-server-tmdb",
    "author": {
      "name": "Laksh-star"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "tmdb",
      "movies",
      "recommendations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Laksh-star/mcp-server-tmdb"
        ],
        "env": {
          "TMDB_API_KEY": "${TMDB_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Search for Movies",
        "description": "Search for movies by title or keywords",
        "prompt": "\"Search for movies about artificial intelligence\""
      },
      {
        "title": "Get Trending Movies",
        "description": "Get today's or this week's trending movies",
        "prompt": "\"What are the trending movies today?\""
      },
      {
        "title": "Get Movie Recommendations",
        "description": "Get movie recommendations based on a movie ID",
        "prompt": "\"Get movie recommendations based on movie ID 550\""
      },
      {
        "title": "Get Movie Details",
        "description": "Get details of a specific movie by ID",
        "prompt": "\"Tell me about the movie with ID 550\""
      }
    ],
    "arguments": {
      "TMDB_API_KEY": {
        "description": "API key used to authenticate requests to the TMDB API.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "search_movies",
        "description": "Search for movies by title or keywords",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query for movie titles"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_recommendations",
        "description": "Get movie recommendations based on a movie ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "movieId": {
              "type": "string",
              "description": "TMDB movie ID to get recommendations for"
            }
          },
          "required": [
            "movieId"
          ]
        }
      },
      {
        "name": "get_trending",
        "description": "Get trending movies for a time window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeWindow": {
              "type": "string",
              "enum": [
                "day",
                "week"
              ],
              "description": "Time window for trending movies"
            }
          },
          "required": [
            "timeWindow"
          ]
        }
      }
    ]
  },
  "minima": {
    "name": "minima",
    "display_name": "Minima",
    "description": "MCP server for RAG on local files",
    "repository": {
      "type": "git",
      "url": "https://github.com/dmayboroda/minima"
    },
    "homepage": "https://github.com/dmayboroda/minima",
    "author": {
      "name": "dmayboroda"
    },
    "license": "MPLv2",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "ChatGPT",
      "Integration",
      "Local",
      "Open Source"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dmayboroda/minima.git@main#subdirectory=mcp-server",
          "minima"
        ]
      }
    },
    "arguments": {
      "LOCAL_FILES_PATH": {
        "description": "Specify the root folder for indexing (on your cloud or local pc). Indexing is a recursive process, meaning all documents within subfolders of this root folder will also be indexed. Supported file types: .pdf, .xls, .docx, .txt, .md, .csv.",
        "required": true,
        "example": "/Users/davidmayboroda/Downloads/PDFs/"
      },
      "EMBEDDING_MODEL_ID": {
        "description": "Specify the embedding model to use. Currently, only Sentence Transformer models are supported. Testing has been done with sentence-transformers/all-mpnet-base-v2, but other Sentence Transformer models can be used.",
        "required": false,
        "example": "sentence-transformers/all-mpnet-base-v2"
      },
      "EMBEDDING_SIZE": {
        "description": "Define the embedding dimension provided by the model, which is needed to configure Qdrant vector storage. Ensure this value matches the actual embedding size of the specified EMBEDDING_MODEL_ID.",
        "required": false,
        "example": "768"
      },
      "OLLAMA_MODEL": {
        "description": "Set up the Ollama model, use an ID available on the Ollama site. Please, use LLM model here, not an embedding.",
        "required": false,
        "example": "qwen2:0.5b"
      },
      "RERANKER_MODEL": {
        "description": "Specify the reranker model. Currently, we have tested with BAAI rerankers. You can explore all available rerankers using a specific link.",
        "required": false,
        "example": "BAAI/bge-reranker-base"
      },
      "USER_ID": {
        "description": "Just use your email here, this is needed to authenticate custom GPT to search in your data.",
        "required": true,
        "example": "user@gmail.com"
      },
      "PASSWORD": {
        "description": "Put any password here, this is used to create a firebase account for the email specified above.",
        "required": true,
        "example": "password"
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Find a context in local files (PDF, CSV, DOCX, MD, TXT)",
        "inputSchema": {
          "properties": {
            "text": {
              "description": "context to find",
              "title": "Text",
              "type": "string"
            }
          },
          "required": [
            "text"
          ],
          "title": "Query",
          "type": "object"
        }
      }
    ]
  },
  "fastn-ai-unified-api-mcp-server": {
    "name": "fastn-ai-unified-api-mcp-server",
    "display_name": "Fastn AI Unified API",
    "description": "A remote, dynamic MCP server with a unified API that connects to 1,000+ tools, actions, and workflows, featuring built-in authentication and monitoring.",
    "repository": {
      "type": "git",
      "url": "https://github.com/fastnai/mcp-fastn"
    },
    "homepage": "https://github.com/fastnai/mcp-fastn",
    "author": {
      "name": "fastnai"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "Fastn",
      "Dynamic Tool Registration",
      "API-Driven Operations"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/fastnai/mcp-fastn",
          "fastn",
          "--api_key",
          "${YOUR_API_KEY}",
          "--space_id",
          "${YOUR_WORKSPACE_ID}"
        ]
      }
    },
    "arguments": {
      "YOUR_API_KEY": {
        "description": "The API key is required to authenticate and access the Fastn server's features and services.",
        "required": true,
        "example": "your_actual_api_key_here"
      },
      "YOUR_WORKSPACE_ID": {
        "description": "The unique identifier for your workspace in Fastn, which directs the server to the correct environment and settings.",
        "required": true,
        "example": "your_actual_workspace_id_here"
      }
    }
  },
  "sentry": {
    "name": "sentry",
    "display_name": "Sentry",
    "description": "Retrieving and analyzing issues from Sentry.io",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sentry",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "sentry",
      "monitoring",
      "errors",
      "debugging"
    ],
    "examples": [
      {
        "title": "Retrieve issue details from Sentry",
        "description": "Use this command to get detailed information about a specific Sentry issue using its ID or URL.",
        "prompt": "sentry-issue {issue_id_or_url}"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_sentry",
          "--auth-token",
          "${YOUR_SENTRY_TOKEN}"
        ]
      }
    },
    "arguments": {
      "YOUR_SENTRY_TOKEN": {
        "description": "An authentication token required to access your Sentry account and retrieve issue details.",
        "required": true,
        "example": "abc123def456"
      }
    },
    "tools": [
      {
        "name": "get_sentry_issue",
        "description": "Retrieve and analyze a Sentry issue by ID or URL. Use this tool when you need to:\n                - Investigate production errors and crashes\n                - Access detailed stacktraces from Sentry\n                - Analyze error patterns and frequencies\n                - Get information about when issues first/last occurred\n                - Review error counts and status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id_or_url": {
              "type": "string",
              "description": "Sentry issue ID or URL to analyze"
            }
          },
          "required": [
            "issue_id_or_url"
          ]
        }
      }
    ]
  },
  "mcp-proxy": {
    "name": "mcp-proxy",
    "display_name": "MCP Proxy",
    "description": "Connect to MCP servers that run on SSE transport, or expose stdio servers as an SSE server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/sparfenyuk/mcp-proxy"
    },
    "homepage": "https://github.com/sparfenyuk/mcp-proxy",
    "author": {
      "name": "sparfenyuk"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "proxy",
      "sse",
      "stdio"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-proxy"
        ]
      }
    }
  },
  "dataset-viewer": {
    "name": "dataset-viewer",
    "display_name": "Dataset Viewer",
    "description": "Browse and analyze Hugging Face datasets with features like search, filtering, statistics, and data export",
    "repository": {
      "type": "git",
      "url": "https://github.com/privetin/dataset-viewer"
    },
    "homepage": "https://github.com/privetin/dataset-viewer",
    "author": {
      "name": "privetin",
      "url": "https://github.com/privetin"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Hugging Face",
      "datasets",
      "data analysis"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/privetin/dataset-viewer",
          "dataset-viewer"
        ]
      }
    },
    "examples": [
      {
        "title": "Validate a dataset",
        "description": "Check if a dataset exists and is accessible.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\"}"
      },
      {
        "title": "Get dataset information",
        "description": "Retrieve detailed information about a dataset.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\"}"
      },
      {
        "title": "Search dataset contents",
        "description": "Search for text within a dataset.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\",\"query\": \"great movie\"}"
      },
      {
        "title": "Filter and sort rows",
        "description": "Filter rows using SQL-like conditions and sort them.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\",\"where\": \"label = 'positive'\",\"orderby\": \"text DESC\",\"page\": 0}"
      },
      {
        "title": "Get dataset statistics",
        "description": "Get statistics about a dataset split.",
        "prompt": "{\"dataset\": \"stanfordnlp/imdb\",\"config\": \"plain_text\",\"split\": \"train\"}"
      }
    ],
    "arguments": {
      "HUGGINGFACE_TOKEN": {
        "description": "Your Hugging Face API token for accessing private datasets",
        "required": false,
        "example": ""
      }
    },
    "tools": [
      {
        "name": "get_info",
        "description": "Get detailed information about a Hugging Face dataset including description, features, splits, and statistics. Run validate first to check if the dataset exists and is accessible.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      },
      {
        "name": "get_rows",
        "description": "Get paginated rows from a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "page": {
              "type": "integer",
              "description": "Page number (0-based), returns 100 rows per page",
              "default": 0
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "get_first_rows",
        "description": "Get first rows from a Hugging Face dataset split",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "search_dataset",
        "description": "Search for text within a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "query": {
              "type": "string",
              "description": "Text to search for in the dataset"
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split",
            "query"
          ]
        }
      },
      {
        "name": "filter",
        "description": "Filter rows in a Hugging Face dataset using SQL-like conditions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "where": {
              "type": "string",
              "description": "SQL-like WHERE clause to filter rows",
              "examples": [
                "column = \"value\"",
                "score > 0.5",
                "text LIKE \"%query%\""
              ]
            },
            "orderby": {
              "type": "string",
              "description": "SQL-like ORDER BY clause to sort results",
              "optional": true,
              "examples": [
                "column ASC",
                "score DESC",
                "name ASC, id DESC"
              ]
            },
            "page": {
              "type": "integer",
              "description": "Page number for paginated results (100 rows per page)",
              "default": 0,
              "minimum": 0
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split",
            "where"
          ]
        }
      },
      {
        "name": "get_statistics",
        "description": "Get statistics about a Hugging Face dataset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "config": {
              "type": "string",
              "description": "Dataset configuration/subset name. Use get_info to list available configs",
              "examples": [
                "default",
                "en",
                "es"
              ]
            },
            "split": {
              "type": "string",
              "description": "Dataset split name. Splits partition the data for training/evaluation",
              "examples": [
                "train",
                "validation",
                "test"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset",
            "config",
            "split"
          ]
        }
      },
      {
        "name": "get_parquet",
        "description": "Export Hugging Face dataset split as Parquet file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      },
      {
        "name": "validate",
        "description": "Check if a Hugging Face dataset exists and is accessible",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dataset": {
              "type": "string",
              "description": "Hugging Face dataset identifier in the format owner/dataset",
              "pattern": "^[^/]+/[^/]+$",
              "examples": [
                "ylecun/mnist",
                "stanfordnlp/imdb"
              ]
            },
            "auth_token": {
              "type": "string",
              "description": "Hugging Face auth token for private/gated datasets",
              "optional": true
            }
          },
          "required": [
            "dataset"
          ]
        }
      }
    ]
  },
  "intercom": {
    "name": "intercom",
    "display_name": "Intercom Support Server",
    "description": "An MCP-compliant server for retrieving customer support tickets from Intercom. This tool enables AI assistants like Claude Desktop and Cline to access and analyze your Intercom support tickets.",
    "repository": {
      "type": "git",
      "url": "https://github.com/raoulbia-ai/mcp-server-for-intercom"
    },
    "homepage": "https://github.com/raoulbia-ai/mcp-server-for-intercom",
    "author": {
      "name": "raoulbia-ai"
    },
    "license": "Apache-2.0",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Intercom",
      "support-tickets",
      "API"
    ],
    "examples": [
      {
        "title": "List Tickets Example",
        "description": "Retrieve support tickets from Intercom between specific dates",
        "prompt": "{\"startDate\":\"15/01/2025\",\"endDate\":\"21/01/2025\",\"keyword\":\"billing\"}"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/raoulbia-ai/mcp-server-for-intercom"
        ],
        "env": {
          "INTERCOM_ACCESS_TOKEN": "your-intercom-access-token"
        }
      }
    },
    "arguments": {
      "INTERCOM_ACCESS_TOKEN": {
        "description": "Your Intercom API token used to authenticate requests to the Intercom API.",
        "required": true,
        "example": "your_intercom_api_token"
      }
    }
  },
  "vega-lite": {
    "name": "vega-lite",
    "display_name": "Vega-Lite Data Visualization",
    "description": "Generate visualizations from fetched data using the VegaLite format and renderer.",
    "repository": {
      "type": "git",
      "url": "https://github.com/isaacwasserman/mcp-vegalite-server"
    },
    "homepage": "https://github.com/isaacwasserman/mcp-vegalite-server",
    "author": {
      "name": "isaacwasserman"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "visualization",
      "data",
      "vega-lite"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/isaacwasserman/mcp-vegalite-server",
          "mcp_server_vegalite"
        ]
      }
    },
    "examples": [
      {
        "title": "Saving Data",
        "description": "Use the save_data tool to save a table of data for visualization.",
        "prompt": "save_data(name='my_table', data=[{'x': 1, 'y': 2}, {'x': 2, 'y': 3}])"
      },
      {
        "title": "Visualizing Data",
        "description": "Use the visualize_data tool to visualize saved data using Vega-Lite syntax.",
        "prompt": "visualize_data(data_name='my_table', vegalite_specification='{\"mark\": \"point\", \"encoding\": {\"x\":{\"field\":\"x\",\"type\":\"quantitative\"},\"y\":{\"field\":\"y\",\"type\":\"quantitative\"}}}')"
      }
    ],
    "tools": [
      {
        "name": "save_data",
        "description": "A tool which allows you to save data to a named table for later use in visualizations.\nWhen to use this tool:\n- Use this tool when you have data that you want to visualize later.\nHow to use this tool:\n- Provide the name of the table to save the data to (for later reference) and the data itself.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the table to save the data to"
            },
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "description": "Row of the table as a dictionary/object"
              },
              "description": "The data to save"
            }
          },
          "required": [
            "name",
            "data"
          ]
        }
      },
      {
        "name": "visualize_data",
        "description": "A tool which allows you to produce a data visualization using the Vega-Lite grammar.\nWhen to use this tool:\n- At times, it will be advantageous to provide the user with a visual representation of some data, rather than just a textual representation.\n- This tool is particularly useful when the data is complex or has many dimensions, making it difficult to understand in a tabular format. It is not useful for singular data points.\nHow to use this tool:\n- Prior to visualization, data must be saved to a named table using the save_data tool.\n- After saving the data, use this tool to visualize the data by providing the name of the table with the saved data and a Vega-Lite specification.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data_name": {
              "type": "string",
              "description": "The name of the data table to visualize"
            },
            "vegalite_specification": {
              "type": "string",
              "description": "The vegalite v5 specification for the visualization. Do not include the data field, as this will be added automatically."
            }
          },
          "required": [
            "data_name",
            "vegalite_specification"
          ]
        }
      }
    ]
  },
  "glean": {
    "name": "glean",
    "display_name": "Glean",
    "description": "A server that uses Glean API to search and chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/longyi1207/glean-mcp-server"
    },
    "homepage": "https://github.com/longyi1207/glean-mcp-server",
    "author": {
      "name": "longyi1207",
      "url": "https://github.com/longyi1207"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "glean",
      "search",
      "chat",
      "docker"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/longyi1207/glean-mcp-server"
        ],
        "env": {
          "GLEAN_API_KEY": "YOUR_API_KEY_HERE",
          "GLEAN_DOMAIN": "YOUR_DOMAIN_HERE"
        }
      }
    },
    "arguments": {
      "GLEAN_API_KEY": {
        "description": "The API key required to authenticate with the Glean API.",
        "required": true,
        "example": "YOUR_API_KEY_HERE"
      },
      "GLEAN_DOMAIN": {
        "description": "The domain used for the Glean API service operations.",
        "required": true,
        "example": "YOUR_DOMAIN_HERE"
      }
    }
  },
  "google-drive": {
    "name": "google-drive",
    "display_name": "Google Drive",
    "description": "File access and search capabilities for Google Drive",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/gdrive",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "google drive",
      "files",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-gdrive"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-v",
          "mcp-gdrive:/gdrive-server",
          "-e",
          "GDRIVE_CREDENTIALS_PATH=/gdrive-server/credentials.json",
          "mcp/gdrive"
        ]
      }
    },
    "tools": [
      {
        "name": "search",
        "description": "Search for files in Google Drive.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          }
        },
        "required": [
          "query"
        ]
      }
    ]
  },
  "excel": {
    "name": "excel",
    "display_name": "Excel",
    "description": "Excel manipulation including data reading/writing, worksheet management, formatting, charts, and pivot table.",
    "repository": {
      "type": "git",
      "url": "https://github.com/haris-musa/excel-mcp-server"
    },
    "homepage": "https://github.com/haris-musa/excel-mcp-server",
    "author": {
      "name": "haris-musa"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Excel Manipulation",
      "Python"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/haris-musa/excel-mcp-server",
          "excel-mcp-server"
        ],
        "env": {
          "EXCEL_FILES_PATH": "${EXCEL_FILES_PATH}"
        }
      }
    },
    "arguments": {
      "EXCEL_FILES_PATH": {
        "description": "Directory where Excel files will be stored.",
        "required": false,
        "example": "/path/to/excel/files"
      }
    },
    "tools": [
      {
        "name": "create_workbook",
        "description": "Creates a new Excel workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          }
        },
        "required": [
          "filepath"
        ]
      },
      {
        "name": "create_worksheet",
        "description": "Creates a new worksheet in an existing workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "get_workbook_metadata",
        "description": "Get metadata about workbook including sheets and ranges.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "include_ranges": {
            "type": "boolean"
          }
        },
        "required": [
          "filepath"
        ]
      },
      {
        "name": "write_data_to_excel",
        "description": "Write data to Excel worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data": {
            "type": "array"
          },
          "start_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data"
        ]
      },
      {
        "name": "read_data_from_excel",
        "description": "Read data from Excel worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "preview_only": {
            "type": "boolean"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "format_range",
        "description": "Apply formatting to a range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "bold": {
            "type": "boolean"
          },
          "italic": {
            "type": "boolean"
          },
          "underline": {
            "type": "boolean"
          },
          "font_size": {
            "type": "integer"
          },
          "font_color": {
            "type": "string"
          },
          "bg_color": {
            "type": "string"
          },
          "border_style": {
            "type": "string"
          },
          "border_color": {
            "type": "string"
          },
          "number_format": {
            "type": "string"
          },
          "alignment": {
            "type": "string"
          },
          "wrap_text": {
            "type": "boolean"
          },
          "merge_cells": {
            "type": "boolean"
          },
          "protection": {
            "type": "object"
          },
          "conditional_format": {
            "type": "object"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell"
        ]
      },
      {
        "name": "merge_cells",
        "description": "Merge a range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "unmerge_cells",
        "description": "Unmerge a previously merged range of cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "apply_formula",
        "description": "Apply Excel formula to cell.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "cell": {
            "type": "string"
          },
          "formula": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "cell",
          "formula"
        ]
      },
      {
        "name": "validate_formula_syntax",
        "description": "Validate Excel formula syntax without applying it.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "cell": {
            "type": "string"
          },
          "formula": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "cell",
          "formula"
        ]
      },
      {
        "name": "create_chart",
        "description": "Create chart in worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data_range": {
            "type": "string"
          },
          "chart_type": {
            "type": "string"
          },
          "target_cell": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "x_axis": {
            "type": "string"
          },
          "y_axis": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data_range",
          "chart_type",
          "target_cell"
        ]
      },
      {
        "name": "create_pivot_table",
        "description": "Create pivot table in worksheet.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "data_range": {
            "type": "string"
          },
          "target_cell": {
            "type": "string"
          },
          "rows": {
            "type": "array"
          },
          "values": {
            "type": "array"
          },
          "columns": {
            "type": "array"
          },
          "agg_func": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "data_range",
          "target_cell",
          "rows",
          "values"
        ]
      },
      {
        "name": "copy_worksheet",
        "description": "Copy worksheet within workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "source_sheet": {
            "type": "string"
          },
          "target_sheet": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "source_sheet",
          "target_sheet"
        ]
      },
      {
        "name": "delete_worksheet",
        "description": "Delete worksheet from workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name"
        ]
      },
      {
        "name": "rename_worksheet",
        "description": "Rename worksheet in workbook.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "old_name": {
            "type": "string"
          },
          "new_name": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "old_name",
          "new_name"
        ]
      },
      {
        "name": "copy_range",
        "description": "Copy a range of cells to another location.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "source_start": {
            "type": "string"
          },
          "source_end": {
            "type": "string"
          },
          "target_start": {
            "type": "string"
          },
          "target_sheet": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "source_start",
          "source_end",
          "target_start"
        ]
      },
      {
        "name": "delete_range",
        "description": "Delete a range of cells and shift remaining cells.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          },
          "shift_direction": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell",
          "end_cell"
        ]
      },
      {
        "name": "validate_excel_range",
        "description": "Validate if a range exists and is properly formatted.",
        "inputSchema": {
          "filepath": {
            "type": "string"
          },
          "sheet_name": {
            "type": "string"
          },
          "start_cell": {
            "type": "string"
          },
          "end_cell": {
            "type": "string"
          }
        },
        "required": [
          "filepath",
          "sheet_name",
          "start_cell"
        ]
      }
    ]
  },
  "opendota": {
    "name": "opendota",
    "display_name": "OpenDota",
    "description": "Interact with OpenDota API to retrieve Dota 2 match data, player statistics, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/asusevski/opendota-mcp-server"
    },
    "homepage": "https://github.com/asusevski/opendota-mcp-server",
    "author": {
      "name": "asusevski"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Dota 2",
      "API",
      "Gaming",
      "Statistics"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/asusevski/opendota-mcp-server.git",
          "src/opendota_server/server"
        ]
      }
    }
  },
  "stripe": {
    "name": "stripe",
    "display_name": "Stripe Model Context Protocol",
    "description": "The Stripe Model Context Protocol server allows you to integrate with Stripe APIs through function calling. This protocol supports various tools to interact with different Stripe services.",
    "repository": {
      "type": "git",
      "url": "https://github.com/stripe/agent-toolkit"
    },
    "homepage": "https://github.com/stripe/agent-toolkit/tree/main/modelcontextprotocol",
    "author": {
      "name": "stripe"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "stripe",
      "payments",
      "customers",
      "refunds"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@stripe/mcp",
          "--tools=all",
          "--api-key=${STRIPE_SECRET_KEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Create a customer",
        "description": "Creates a new customer in Stripe.",
        "prompt": "{\"tool\": \"customer_create\", \"arguments\": {\"email\": \"customer@example.com\", \"name\": \"John Doe\"}}"
      },
      {
        "title": "Retrieve a customer",
        "description": "Retrieves details of an existing customer.",
        "prompt": "{\"tool\": \"customer_retrieve\", \"arguments\": {\"customer_id\": \"cus_123456\"}}"
      },
      {
        "title": "Create a payment intent",
        "description": "Creates a payment intent for processing payments.",
        "prompt": "{\"tool\": \"payment_intent_create\", \"arguments\": {\"amount\": 5000, \"currency\": \"usd\", \"customer\": \"cus_123456\"}}"
      },
      {
        "title": "Create a refund",
        "description": "Creates a refund for a charge.",
        "prompt": "{\"tool\": \"refund_create\", \"arguments\": {\"charge_id\": \"ch_abc123\"}}"
      }
    ],
    "arguments": {
      "STRIPE_SECRET_KEY": {
        "description": "Your Stripe secret API key required for authenticating requests to the Stripe API.",
        "required": true,
        "example": "sk_test_4eC39HqLyjWDarjtT1zdp7dc"
      }
    },
    "tools": [
      {
        "name": "create_customer",
        "description": "\nThis tool will create a customer in Stripe.\n\nIt takes two arguments:\n- name (str): The name of the customer.\n- email (str, optional): The email of the customer.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the customer"
            },
            "email": {
              "type": "string",
              "format": "email",
              "description": "The email of the customer"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_customers",
        "description": "\nThis tool will fetch a list of Customers from Stripe.\n\nIt takes no input.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100."
            },
            "email": {
              "type": "string",
              "description": "A case-sensitive filter on the list based on the customer's email field. The value must be a string."
            }
          }
        }
      },
      {
        "name": "create_product",
        "description": "\nThis tool will create a product in Stripe.\n\nIt takes two arguments:\n- name (str): The name of the product.\n- description (str, optional): The description of the product.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the product."
            },
            "description": {
              "type": "string",
              "description": "The description of the product."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_products",
        "description": "\nThis tool will fetch a list of Products from Stripe.\n\nIt takes one optional argument:\n- limit (int, optional): The number of products to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10."
            }
          }
        }
      },
      {
        "name": "create_price",
        "description": "\nThis tool will create a price in Stripe. If a product has not already been specified, a product should be created first.\n\nIt takes three arguments:\n- product (str): The ID of the product to create the price for.\n- unit_amount (int): The unit amount of the price in cents.\n- currency (str): The currency of the price.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "product": {
              "type": "string",
              "description": "The ID of the product to create the price for."
            },
            "unit_amount": {
              "type": "integer",
              "description": "The unit amount of the price in cents."
            },
            "currency": {
              "type": "string",
              "description": "The currency of the price."
            }
          },
          "required": [
            "product",
            "unit_amount",
            "currency"
          ]
        }
      },
      {
        "name": "list_prices",
        "description": "\nThis tool will fetch a list of Prices from Stripe.\n\nIt takes two arguments.\n- product (str, optional): The ID of the product to list prices for.\n- limit (int, optional): The number of prices to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "product": {
              "type": "string",
              "description": "The ID of the product to list prices for."
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10."
            }
          }
        }
      },
      {
        "name": "create_payment_link",
        "description": "\nThis tool will create a payment link in Stripe.\n\nIt takes two arguments:\n- price (str): The ID of the price to create the payment link for.\n- quantity (int): The quantity of the product to include in the payment link.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "price": {
              "type": "string",
              "description": "The ID of the price to create the payment link for."
            },
            "quantity": {
              "type": "integer",
              "description": "The quantity of the product to include."
            }
          },
          "required": [
            "price",
            "quantity"
          ]
        }
      },
      {
        "name": "create_invoice",
        "description": "\nThis tool will create an invoice in Stripe.\n\nIt takes two arguments:\n- customer (str): The ID of the customer to create the invoice for.\n\n- days_until_due (int, optional): The number of days until the invoice is due.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to create the invoice for."
            },
            "days_until_due": {
              "type": "integer",
              "description": "The number of days until the invoice is due."
            }
          },
          "required": [
            "customer"
          ]
        }
      },
      {
        "name": "create_invoice_item",
        "description": "\nThis tool will create an invoice item in Stripe.\n\nIt takes two arguments:\n- customer (str): The ID of the customer to create the invoice item for.\n\n- price (str): The ID of the price to create the invoice item for.\n- invoice (str): The ID of the invoice to create the invoice item for.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to create the invoice item for."
            },
            "price": {
              "type": "string",
              "description": "The ID of the price for the item."
            },
            "invoice": {
              "type": "string",
              "description": "The ID of the invoice to create the item for."
            }
          },
          "required": [
            "customer",
            "price",
            "invoice"
          ]
        }
      },
      {
        "name": "finalize_invoice",
        "description": "\nThis tool will finalize an invoice in Stripe.\n\nIt takes one argument:\n- invoice (str): The ID of the invoice to finalize.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "invoice": {
              "type": "string",
              "description": "The ID of the invoice to finalize."
            }
          },
          "required": [
            "invoice"
          ]
        }
      },
      {
        "name": "retrieve_balance",
        "description": "\nThis tool will retrieve the balance from Stripe. It takes no input.\n",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_refund",
        "description": "\nThis tool will refund a payment intent in Stripe.\n\nIt takes three arguments:\n- payment_intent (str): The ID of the payment intent to refund.\n- amount (int, optional): The amount to refund in cents.\n- reason (str, optional): The reason for the refund.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "payment_intent": {
              "type": "string",
              "description": "The ID of the PaymentIntent to refund."
            },
            "amount": {
              "type": "integer",
              "description": "The amount to refund in cents."
            }
          },
          "required": [
            "payment_intent"
          ]
        }
      },
      {
        "name": "list_payment_intents",
        "description": "\nThis tool will list payment intents in Stripe.\n\nIt takes two arguments:\n- customer (str, optional): The ID of the customer to list payment intents for.\n\n- limit (int, optional): The number of payment intents to return.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "customer": {
              "type": "string",
              "description": "The ID of the customer to list payment intents for."
            },
            "limit": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "description": "A limit on the number of objects to be returned. Limit can range between 1 and 100."
            }
          }
        }
      },
      {
        "name": "search_documentation",
        "description": "\nThis tool will take in a user question about integrating with Stripe in their application, then search and retrieve relevant Stripe documentation to answer the question.\n\nIt takes two arguments:\n- question (str): The user question to search an answer for in the Stripe documentation.\n- language (str, optional): The programming language to search for in the the documentation.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The user question about integrating with Stripe will be used to search the documentation."
            },
            "language": {
              "type": "string",
              "enum": [
                "dotnet",
                "go",
                "java",
                "node",
                "php",
                "ruby",
                "python",
                "curl"
              ],
              "description": "The programming language to search for in the the documentation."
            }
          },
          "required": [
            "question"
          ]
        }
      }
    ]
  },
  "unity3d-game-engine": {
    "name": "unity3d-game-engine",
    "display_name": "Unity3D Game Engine",
    "description": "An MCP server that enables LLMs to interact with Unity3d Game Engine, supporting access to a variety of the Unit's Editor engine tools (e.g. Console Logs, Test Runner logs, Editor functions, hierarchy state, etc) and executing them as MCP tools or gather them as resources.",
    "repository": {
      "type": "git",
      "url": "https://github.com/CoderGamester/mcp-unity"
    },
    "homepage": "https://github.com/CoderGamester/mcp-unity",
    "author": {
      "name": "CoderGamester"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Unity",
      "Node.js",
      "TypeScript",
      "WebSocket",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/CoderGamester/mcp-unity"
        ],
        "env": {
          "UNITY_PORT": "8090"
        }
      }
    },
    "examples": [
      {
        "title": "Execute Menu Item",
        "description": "Execute Unity menu items programmatically using MCP Unity.",
        "prompt": "mcp-unity execute_menu_item"
      }
    ],
    "arguments": {
      "UNITY_PORT": {
        "description": "Environment variable to set the port number for the Unity MCP Server. This should be set to the desired port for the server to run and connect with the Unity Editor.",
        "required": false,
        "example": "8090"
      }
    },
    "tools": [
      {
        "name": "execute_menu_item",
        "description": "Executes a Unity menu item by path",
        "inputSchema": {
          "type": "object",
          "properties": {
            "menuPath": {
              "type": "string",
              "description": "The path to the menu item to execute (e.g. \"GameObject/Create Empty\")"
            }
          },
          "required": [
            "menuPath"
          ]
        }
      },
      {
        "name": "select_object",
        "description": "Sets the selected object in the Unity editor by path or ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectPath": {
              "type": "string",
              "description": "The path or ID of the object to select (e.g. \"Main Camera\" or a Unity object ID)"
            }
          },
          "required": [
            "objectPath"
          ]
        }
      },
      {
        "name": "package_manager",
        "description": "Manages packages in the Unity Package Manager",
        "inputSchema": {
          "type": "object",
          "properties": {
            "methodSource": {
              "type": "string",
              "description": "The method source to use (registry, github, or disk) to add the package"
            },
            "packageName": {
              "type": "string",
              "description": "The package name to add from Unity registry (e.g. com.unity.textmeshpro)"
            },
            "version": {
              "type": "string",
              "description": "The version to use for registry packages (optional)"
            },
            "repositoryUrl": {
              "type": "string",
              "description": "The GitHub repository URL (e.g. https://github.com/username/repo.git)"
            },
            "branch": {
              "type": "string",
              "description": "The branch to use for GitHub packages (optional)"
            },
            "path": {
              "type": "string",
              "description": "The path to use (folder path for disk method or subfolder for GitHub)"
            }
          },
          "required": [
            "methodSource"
          ]
        }
      },
      {
        "name": "run_tests",
        "description": "Runs Unity's Test Runner tests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "testMode": {
              "type": "string",
              "description": "The test mode to run (EditMode, PlayMode, or All)"
            },
            "testFilter": {
              "type": "string",
              "description": "Optional test filter (e.g. specific test name or namespace)"
            }
          }
        }
      },
      {
        "name": "notify_message",
        "description": "Sends a message to the Unity console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "The message to display in the Unity console"
            },
            "type": {
              "type": "string",
              "description": "The type of message (info, warning, error)"
            }
          },
          "required": [
            "message"
          ]
        }
      }
    ]
  },
  "cloudinary": {
    "name": "cloudinary",
    "display_name": "Cloudinary",
    "description": "Cloudinary Model Context Protocol Server to upload media to Cloudinary and get back the media link and details.",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/cloudinary-mcp-server"
    },
    "homepage": "https://github.com/felores/cloudinary-mcp-server",
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "cloudinary",
      "images",
      "videos"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@felores/cloudinary-mcp-server@latest"
        ],
        "env": {
          "CLOUDINARY_CLOUD_NAME": "${CLOUDINARY_CLOUD_NAME}",
          "CLOUDINARY_API_KEY": "${CLOUDINARY_API_KEY}",
          "CLOUDINARY_API_SECRET": "${CLOUDINARY_API_SECRET}"
        }
      }
    },
    "examples": [
      {
        "title": "Upload an Image",
        "description": "This example demonstrates how to upload an image to Cloudinary.",
        "prompt": "use_mcp_tool({ server_name: 'cloudinary', tool_name: 'upload', arguments: { file: 'path/to/image.jpg', resource_type: 'image', public_id: 'my-custom-id' }});"
      }
    ],
    "arguments": {
      "CLOUDINARY_CLOUD_NAME": {
        "description": "Your Cloudinary cloud name, used to identify your account and resources.",
        "required": true,
        "example": "my_cloud_name"
      },
      "CLOUDINARY_API_KEY": {
        "description": "Your Cloudinary API key, used to authenticate requests to the Cloudinary API.",
        "required": true,
        "example": "my_api_key"
      },
      "CLOUDINARY_API_SECRET": {
        "description": "Your Cloudinary API secret, used to authenticate requests and secure your Cloudinary account.",
        "required": true,
        "example": "my_api_secret"
      }
    },
    "tools": [
      {
        "name": "upload",
        "description": "Upload media (images/videos) to Cloudinary. For large files, the upload is processed in chunks and returns a streaming response. The uploaded asset will be available at:\n- HTTP: http://res.cloudinary.com/{cloud_name}/{resource_type}/upload/v1/{public_id}.{format}\n- HTTPS: https://res.cloudinary.com/{cloud_name}/{resource_type}/upload/v1/{public_id}.{format}\nwhere {cloud_name} is your Cloudinary cloud name, resource_type is 'image' or 'video', and format is determined by the file extension.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path to file, URL, or base64 data URI to upload"
            },
            "resource_type": {
              "type": "string",
              "enum": [
                "image",
                "video",
                "raw"
              ],
              "description": "Type of resource to upload. For videos, the upload will return a streaming response as it processes in chunks."
            },
            "public_id": {
              "type": "string",
              "description": "Public ID to assign to the uploaded asset. This will be used in the final URL. If not provided, Cloudinary will generate one."
            },
            "overwrite": {
              "type": "boolean",
              "description": "Whether to overwrite existing assets with the same public ID"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to assign to the uploaded asset"
            }
          },
          "required": [
            "file"
          ]
        }
      }
    ]
  },
  "notion": {
    "name": "notion",
    "display_name": "Notion",
    "description": "Notion MCP integration. Search, Read, Update, and Create pages through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/v-3/notion-server"
    },
    "homepage": "https://github.com/v-3/notion-server",
    "author": {
      "name": "v-3"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Notion"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/v-3/notion-server"
        ],
        "env": {
          "NOTION_API_KEY": "${NOTION_API_KEY}"
        }
      }
    },
    "arguments": {
      "NOTION_API_KEY": {
        "description": "Your Notion API key for authentication to access data within your Notion workspace.",
        "required": true,
        "example": "your_notion_api_key_here"
      }
    }
  },
  "dicom": {
    "name": "dicom",
    "display_name": "DICOM Model Context Protocol",
    "description": "An MCP server to query and retrieve medical images and for parsing and reading dicom-encapsulated documents (pdf etc.).",
    "repository": {
      "type": "git",
      "url": "https://github.com/ChristianHinge/dicom-mcp"
    },
    "homepage": "https://github.com/ChristianHinge/dicom-mcp",
    "author": {
      "name": "ChristianHinge",
      "url": "https://github.com/ChristianHinge"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "DICOM",
      "Medical Imaging",
      "AI",
      "PDF Extraction"
    ],
    "examples": [
      {
        "title": "List available DICOM nodes",
        "description": "Retrieve and display all configured DICOM nodes and calling AE titles.",
        "prompt": "list_dicom_nodes()"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ChristianHinge/dicom-mcp",
          "dicom-mcp",
          "${CONFIG_PATH}"
        ]
      }
    },
    "arguments": {
      "CONFIG_PATH": {
        "description": "Path to the configuration file",
        "required": true,
        "example": "/path/to/config.yaml"
      }
    },
    "tools": [
      {
        "name": "list_dicom_nodes",
        "description": "Lists all configured DICOM nodes and calling AE titles.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "switch_dicom_node",
        "description": "Switches to a different configured DICOM node.",
        "inputSchema": {
          "node_name": {
            "type": "string",
            "description": "Name of the node to switch to"
          }
        },
        "required": [
          "node_name"
        ]
      },
      {
        "name": "switch_calling_aet",
        "description": "Switches to a different configured calling AE title.",
        "inputSchema": {
          "aet_name": {
            "type": "string",
            "description": "Name of the calling AE title to switch to"
          }
        },
        "required": [
          "aet_name"
        ]
      },
      {
        "name": "verify_connection",
        "description": "Tests connectivity to the configured DICOM node using C-ECHO.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "query_patients",
        "description": "Search for patients matching specified criteria.",
        "inputSchema": {
          "name_pattern": {
            "type": "string",
            "description": "Patient name pattern (can include wildcards)",
            "optional": true
          },
          "patient_id": {
            "type": "string",
            "description": "Patient ID",
            "optional": true
          },
          "birth_date": {
            "type": "string",
            "description": "Patient birth date (YYYYMMDD)",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "query_studies",
        "description": "Search for studies matching specified criteria.",
        "inputSchema": {
          "patient_id": {
            "type": "string",
            "description": "Patient ID",
            "optional": true
          },
          "study_date": {
            "type": "string",
            "description": "Study date or range (YYYYMMDD or YYYYMMDD-YYYYMMDD)",
            "optional": true
          },
          "modality_in_study": {
            "type": "string",
            "description": "Modalities in study",
            "optional": true
          },
          "study_description": {
            "type": "string",
            "description": "Study description (can include wildcards)",
            "optional": true
          },
          "accession_number": {
            "type": "string",
            "description": "Accession number",
            "optional": true
          },
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "query_series",
        "description": "Search for series within a study.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "modality": {
            "type": "string",
            "description": "Modality (e.g., 'CT', 'MR')",
            "optional": true
          },
          "series_number": {
            "type": "string",
            "description": "Series number",
            "optional": true
          },
          "series_description": {
            "type": "string",
            "description": "Series description",
            "optional": true
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": [
          "study_instance_uid"
        ]
      },
      {
        "name": "query_instances",
        "description": "Search for instances within a series.",
        "inputSchema": {
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "instance_number": {
            "type": "string",
            "description": "Instance number",
            "optional": true
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID",
            "optional": true
          },
          "attribute_preset": {
            "type": "string",
            "description": "Preset level of detail",
            "optional": true
          },
          "additional_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Additional DICOM attributes to include",
            "optional": true
          },
          "exclude_attributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "DICOM attributes to exclude",
            "optional": true
          }
        },
        "required": [
          "series_instance_uid"
        ]
      },
      {
        "name": "get_attribute_presets",
        "description": "Lists available attribute presets for queries.",
        "inputSchema": {},
        "required": []
      },
      {
        "name": "retrieve_instance",
        "description": "Retrieves a specific DICOM instance and saves it to the local filesystem.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID"
          },
          "output_directory": {
            "type": "string",
            "description": "Directory to save the retrieved instance to (default: './retrieved_files')",
            "optional": true
          }
        },
        "required": [
          "study_instance_uid",
          "series_instance_uid",
          "sop_instance_uid"
        ]
      },
      {
        "name": "extract_pdf_text_from_dicom",
        "description": "Retrieves a DICOM instance containing an encapsulated PDF and extracts its text content.",
        "inputSchema": {
          "study_instance_uid": {
            "type": "string",
            "description": "Study Instance UID"
          },
          "series_instance_uid": {
            "type": "string",
            "description": "Series Instance UID"
          },
          "sop_instance_uid": {
            "type": "string",
            "description": "SOP Instance UID"
          }
        },
        "required": [
          "study_instance_uid",
          "series_instance_uid",
          "sop_instance_uid"
        ]
      }
    ]
  },
  "huggingface-spaces": {
    "name": "huggingface-spaces",
    "display_name": "HuggingFace Spaces \ud83e\udd17",
    "description": "Server for using HuggingFace Spaces, supporting Open Source Image, Audio, Text Models and more. Claude Desktop mode for easy integration.",
    "repository": {
      "type": "git",
      "url": "https://github.com/evalstate/mcp-hfspace"
    },
    "author": {
      "name": "evalstate"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Hugging Face",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@llmindset/mcp-hfspace"
        ]
      }
    },
    "examples": [
      {
        "title": "Image Generation Example",
        "description": "Using mcp-hfspace to generate images.",
        "prompt": "Use shuttleai/shuttle-3.1-aesthetic to create an image."
      },
      {
        "title": "Text-to-Speech Example",
        "description": "Using mcp-hfspace to convert text to speech.",
        "prompt": "Create an audio file from the text 'Hello, world!'."
      },
      {
        "title": "Speech-to-Text Example",
        "description": "Using mcp-hfspace to transcribe audio to text.",
        "prompt": "Transcribe the audio file 'sample_audio.wav'."
      },
      {
        "title": "Vision Model Example",
        "description": "Using mcp-hfspace to analyze images.",
        "prompt": "Analyze the image file 'test_image.jpg'."
      }
    ],
    "homepage": "https://github.com/evalstate/mcp-hfspace",
    "arguments": {
      "CLAUDE_DESKTOP_MODE": {
        "description": "Enables or disables the Claude Desktop Mode for the server.",
        "required": false,
        "example": "false"
      }
    },
    "tools": [
      {
        "name": "available-files",
        "description": "A list of available file and resources. If the User requests things like 'most recent image' or 'the audio' use this tool to identify the intended resource.This tool returns 'resource uri', 'name', 'size', 'last modified'  and 'mime type' in a markdown table",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "FLUX_1-schnell-infer",
        "description": "Call the FLUX.1-schnell endpoint /infer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Prompt",
              "examples": [
                "Hello!!"
              ]
            },
            "seed": {
              "type": "number",
              "description": "Seed",
              "default": 0
            },
            "randomize_seed": {
              "type": "boolean",
              "description": "Randomize seed",
              "default": true,
              "examples": [
                true
              ]
            },
            "width": {
              "type": "number",
              "description": "Width",
              "default": 1024,
              "examples": [
                256
              ]
            },
            "height": {
              "type": "number",
              "description": "Height",
              "default": 1024,
              "examples": [
                256
              ]
            },
            "num_inference_steps": {
              "type": "number",
              "description": "Number of inference steps",
              "default": 4,
              "examples": [
                1
              ]
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "hubspot": {
    "name": "hubspot",
    "display_name": "HubSpot CRM Integration",
    "description": "HubSpot CRM integration for managing contacts and companies. Create and retrieve CRM data directly through Claude chat.",
    "repository": {
      "type": "git",
      "url": "https://github.com/buryhuang/mcp-hubspot"
    },
    "homepage": "https://github.com/buryhuang/mcp-hubspot",
    "author": {
      "name": "buryhuang"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "HubSpot",
      "API",
      "AI",
      "CRM",
      "Integration"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "HUBSPOT_ACCESS_TOKEN=${HUBSPOT_ACCESS_TOKEN}",
          "buryhuang/mcp-hubspot:latest"
        ],
        "env": {
          "HUBSPOT_ACCESS_TOKEN": "${HUBSPOT_ACCESS_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Create HubSpot contacts from LinkedIn",
        "description": "This prompt allows you to create contacts in HubSpot by parsing information from a LinkedIn profile.",
        "prompt": "Create HubSpot contacts and companies from following:\n\nJohn Doe\nSoftware Engineer at Tech Corp\nSan Francisco Bay Area \u2022 500+ connections\n\nExperience\nTech Corp\nSoftware Engineer\nJan 2020 - Present \u00b7 4 yrs\nSan Francisco, California\n\nPrevious Company Inc.\nSenior Developer\n2018 - 2020 \u00b7 2 yrs\n\nEducation\nUniversity of California, Berkeley\nComputer Science, BS\n2014 - 2018"
      },
      {
        "title": "Get latest company activities",
        "description": "Use this prompt to get the latest activities related to your company in HubSpot.",
        "prompt": "What's happening latestly with my pipeline?"
      }
    ],
    "arguments": {
      "HUBSPOT_ACCESS_TOKEN": {
        "description": "The HubSpot access token required for authenticating API requests to HubSpot.",
        "required": true,
        "example": "your_access_token_here"
      }
    },
    "tools": [
      {
        "name": "hubspot_create_contact",
        "description": "Create a new contact in HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "firstname": {
              "type": "string",
              "description": "Contact's first name"
            },
            "lastname": {
              "type": "string",
              "description": "Contact's last name"
            },
            "email": {
              "type": "string",
              "description": "Contact's email address"
            },
            "properties": {
              "type": "object",
              "description": "Additional contact properties"
            }
          },
          "required": [
            "firstname",
            "lastname"
          ]
        }
      },
      {
        "name": "hubspot_create_company",
        "description": "Create a new company in HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Company name"
            },
            "properties": {
              "type": "object",
              "description": "Additional company properties"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "hubspot_get_company_activity",
        "description": "Get activity history for a specific company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company_id": {
              "type": "string",
              "description": "HubSpot company ID"
            }
          },
          "required": [
            "company_id"
          ]
        }
      },
      {
        "name": "hubspot_get_recent_engagements",
        "description": "Get recent engagement activities across all contacts and companies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "integer",
              "description": "Number of days to look back (default: 7)"
            },
            "limit": {
              "type": "integer",
              "description": "Maximum number of engagements to return (default: 50)"
            }
          }
        }
      },
      {
        "name": "hubspot_get_active_companies",
        "description": "Get most recently active companies from HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of companies to return (default: 10)"
            }
          }
        }
      },
      {
        "name": "hubspot_get_active_contacts",
        "description": "Get most recently active contacts from HubSpot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of contacts to return (default: 10)"
            }
          }
        }
      }
    ]
  },
  "ticketmaster": {
    "name": "ticketmaster",
    "display_name": "Ticketmaster",
    "description": "Search for events, venues, and attractions through the Ticketmaster Discovery API",
    "repository": {
      "type": "git",
      "url": "https://github.com/delorenj/mcp-server-ticketmaster"
    },
    "homepage": "https://github.com/delorenj/mcp-server-ticketmaster",
    "author": {
      "name": "delorenj"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "ticketmaster",
      "events",
      "venues",
      "attractions"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@delorenj/mcp-server-ticketmaster"
        ],
        "env": {
          "TICKETMASTER_API_KEY": "${TICKETMASTER_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Structured JSON Output",
        "description": "Example of structured JSON output for searching events.",
        "prompt": "<use_mcp_tool>\n<server_name>ticketmaster</server_name>\n<tool_name>search_ticketmaster</tool_name>\n<arguments>\n{\n  \"type\": \"event\",\n  \"keyword\": \"concert\",\n  \"startDate\": \"2025-02-01\",\n  \"endDate\": \"2025-02-28\",\n  \"city\": \"New York\",\n  \"stateCode\": \"NY\"\n}\n</arguments>\n</use_mcp_tool>"
      },
      {
        "title": "Human-Readable Text Output",
        "description": "Example of human-readable text output for searching events.",
        "prompt": "<use_mcp_tool>\n<server_name>ticketmaster</server_name>\n<tool_name>search_ticketmaster</tool_name>\n<arguments>\n{\n  \"type\": \"event\",\n  \"keyword\": \"concert\",\n  \"startDate\": \"2025-02-01\",\n  \"endDate\": \"2025-02-28\",\n  \"city\": \"New York\",\n  \"stateCode\": \"NY\",\n  \"format\": \"text\"\n}\n</arguments>\n</use_mcp_tool>"
      }
    ],
    "arguments": {
      "TICKETMASTER_API_KEY": {
        "description": "API key required to access the Ticketmaster Discovery API.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "search_ticketmaster",
        "description": "Search for events, venues, or attractions on Ticketmaster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "event",
                "venue",
                "attraction"
              ],
              "description": "Type of search to perform"
            },
            "keyword": {
              "type": "string",
              "description": "Search keyword or term"
            },
            "startDate": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format"
            },
            "endDate": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format"
            },
            "city": {
              "type": "string",
              "description": "City name"
            },
            "stateCode": {
              "type": "string",
              "description": "State code (e.g., NY, CA)"
            },
            "countryCode": {
              "type": "string",
              "description": "Country code (e.g., US, CA)"
            },
            "venueId": {
              "type": "string",
              "description": "Specific venue ID to search"
            },
            "attractionId": {
              "type": "string",
              "description": "Specific attraction ID to search"
            },
            "classificationName": {
              "type": "string",
              "description": "Event classification/category (e.g., \"Sports\", \"Music\")"
            },
            "format": {
              "type": "string",
              "enum": [
                "json",
                "text"
              ],
              "description": "Output format (defaults to json)",
              "default": "json"
            }
          },
          "required": [
            "type"
          ]
        }
      }
    ]
  },
  "figma": {
    "name": "figma",
    "display_name": "Figma",
    "description": "Give your coding agent direct access to Figma file data, helping it one-shot design implementation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GLips/Figma-Context-MCP"
    },
    "homepage": "https://github.com/GLips/Figma-Context-MCP",
    "author": {
      "name": "GLips"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "Figma",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "figma-developer-mcp",
          "--figma-api-key=${FIGMA_API_KEY}",
          "--stdio"
        ]
      }
    },
    "arguments": {
      "FIGMA_API_KEY": {
        "description": "Your Figma API access token (required)",
        "required": true,
        "example": "<your-figma-api-key>"
      }
    },
    "tools": [
      {
        "name": "get_figma_data",
        "description": "When the nodeId cannot be obtained, obtain the layout information about the entire Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The key of the Figma file to fetch, often found in a provided URL like figma.com/(file|design)/<fileKey>/..."
            },
            "nodeId": {
              "type": "string",
              "description": "The ID of the node to fetch, often found as URL parameter node-id=<nodeId>, always use if provided"
            },
            "depth": {
              "type": "number",
              "description": "How many levels deep to traverse the node tree, only use if explicitly requested by the user"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "download_figma_images",
        "description": "Download SVG and PNG images used in a Figma file based on the IDs of image or icon nodes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The key of the Figma file containing the node"
            },
            "nodes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "nodeId": {
                    "type": "string",
                    "description": "The ID of the Figma image node to fetch, formatted as 1234:5678"
                  },
                  "imageRef": {
                    "type": "string",
                    "description": "If a node has an imageRef fill, you must include this variable. Leave blank when downloading Vector SVG images."
                  },
                  "fileName": {
                    "type": "string",
                    "description": "The local name for saving the fetched file"
                  }
                },
                "required": [
                  "nodeId",
                  "fileName"
                ],
                "additionalProperties": false
              },
              "description": "The nodes to fetch as images"
            },
            "localPath": {
              "type": "string",
              "description": "The absolute path to the directory where images are stored in the project. Automatically creates directories if needed."
            }
          },
          "required": [
            "fileKey",
            "nodes",
            "localPath"
          ]
        }
      }
    ]
  },
  "starwind-ui": {
    "name": "starwind-ui",
    "display_name": "Starwind UI",
    "description": "This MCP provides relevant commands, documentation, and other information to allow LLMs to take full advantage of Starwind UI's open source Astro components.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Boston343/starwind-ui-mcp"
    },
    "homepage": "https://github.com/Boston343/starwind-ui-mcp/",
    "author": {
      "name": "Boston343"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Starwind",
      "Developer Tools",
      "AI",
      "Components"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Boston343/starwind-ui-mcp/"
        ]
      }
    }
  },
  "time": {
    "name": "time",
    "display_name": "Time",
    "description": "A Model Context Protocol server that provides time and timezone conversion capabilities. It automatically detects the system's timezone and offers tools for getting current time and converting between timezones.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/time#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "time",
      "timezone",
      "date",
      "converter"
    ],
    "arguments": {
      "TZ": {
        "description": "Environment variable to override the system's default timezone",
        "required": false,
        "example": "America/New_York"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-time",
          "--local-timezone=${TZ}"
        ],
        "description": "Install and run using uvx (recommended)",
        "recommended": true
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp_server_time",
          "--local-timezone=${TZ}"
        ],
        "description": "Run with Python module (requires pip install)"
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "mcp/time",
          "--local-timezone=${TZ}"
        ],
        "description": "Run with Docker"
      }
    },
    "tools": [
      {
        "name": "get_current_time",
        "description": "Get current time in a specific timezones",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timezone": {
              "type": "string",
              "description": "IANA timezone name (e.g., 'America/New_York', 'Europe/London'). Use local timezone if no timezone provided by the user."
            }
          },
          "required": [
            "timezone"
          ]
        }
      },
      {
        "name": "convert_time",
        "description": "Convert time between timezones",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source_timezone": {
              "type": "string",
              "description": "Source IANA timezone name (e.g., 'America/New_York', 'Europe/London'). Use local timezone if no source timezone provided by the user."
            },
            "time": {
              "type": "string",
              "description": "Time to convert in 24-hour format (HH:MM)"
            },
            "target_timezone": {
              "type": "string",
              "description": "Target IANA timezone name (e.g., 'Asia/Tokyo', 'America/San_Francisco'). Use local timezone if no target timezone provided by the user."
            }
          },
          "required": [
            "source_timezone",
            "time",
            "target_timezone"
          ]
        }
      }
    ],
    "examples": [
      {
        "title": "Current time",
        "description": "Get the current time in a specific timezone",
        "prompt": "What time is it in Tokyo right now?"
      },
      {
        "title": "Time conversion",
        "description": "Convert time between timezones",
        "prompt": "Convert 3:30 PM EST to Paris time."
      }
    ]
  },
  "ableton-live": {
    "name": "ableton-live",
    "display_name": "Ableton Live",
    "description": "an MCP server to control Ableton Live.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Simon-Kansara/ableton-live-mcp-server"
    },
    "homepage": "https://github.com/Simon-Kansara/ableton-live-mcp-server",
    "author": {
      "name": "Simon Kansara"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Ableton Live",
      "OSC",
      "Music"
    ],
    "installations": {
      "custom": {
        "type": "python",
        "command": "python",
        "args": [
          "mcp_ableton_server.py"
        ],
        "description": "Run with Python module (requires git clone)"
      }
    },
    "examples": [
      {
        "title": "Prepare a rock band set for recording",
        "description": "In Claude desktop, ask Claude to prepare a set to record a rock band.",
        "prompt": "_Prepare a set to record a rock band_"
      },
      {
        "title": "Set input routing for tracks",
        "description": "Set the input routing channel of all tracks that have 'voice' in their name to Ext. In 2.",
        "prompt": "_Set the input routing channel of all tracks that have 'voice' in their name to Ext. In 2_"
      }
    ]
  },
  "pandoc": {
    "name": "pandoc",
    "display_name": "Pandoc Document Conversion",
    "description": "MCP server for seamless document format conversion using Pandoc, supporting Markdown, HTML, PDF, DOCX (.docx), csv and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/vivekVells/mcp-pandoc"
    },
    "homepage": "https://github.com/vivekVells/mcp-pandoc",
    "author": {
      "name": "vivekVells"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "pandoc",
      "document",
      "conversion"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-pandoc"
        ]
      }
    },
    "examples": [
      {
        "title": "Convert Markdown to PDF",
        "description": "Converts Markdown content to PDF format and saves it to the specified path.",
        "prompt": "Convert /path/to/input.md to PDF and save as /path/to/output.pdf"
      },
      {
        "title": "Convert Content Directly",
        "description": "Converts a string of content directly to a specific output format.",
        "prompt": "Convert this text to PDF and save as /path/to/document.pdf"
      }
    ],
    "tools": [
      {
        "name": "convert-contents",
        "description": "Converts content between different formats. Transforms input content from any supported format into the specified output format.\n\n\ud83d\udea8 CRITICAL REQUIREMENTS - PLEASE READ:\n1. PDF Conversion:\n   * You MUST install TeX Live BEFORE attempting PDF conversion:\n   * Ubuntu/Debian: `sudo apt-get install texlive-xetex`\n   * macOS: `brew install texlive`\n   * Windows: Install MiKTeX or TeX Live from https://miktex.org/ or https://tug.org/texlive/\n   * PDF conversion will FAIL without this installation\n\n2. File Paths - EXPLICIT REQUIREMENTS:\n   * When asked to save or convert to a file, you MUST provide:\n     - Complete directory path\n     - Filename\n     - File extension\n   * Example request: 'Write a story and save as PDF'\n   * You MUST specify: '/path/to/story.pdf' or 'C:\\Documents\\story.pdf'\n   * The tool will NOT automatically generate filenames or extensions\n\n3. File Location After Conversion:\n   * After successful conversion, the tool will display the exact path where the file is saved\n   * Look for message: 'Content successfully converted and saved to: [file_path]'\n   * You can find your converted file at the specified location\n   * If no path is specified, files may be saved in system temp directory (/tmp/ on Unix systems)\n   * For better control, always provide explicit output file paths\n\nSupported formats:\n- Basic formats: txt, html, markdown\n- Advanced formats (REQUIRE complete file paths): pdf, docx, rst, latex, epub\n\n\u2705 CORRECT Usage Examples:\n1. 'Convert this text to HTML' (basic conversion)\n   - Tool will show converted content\n\n2. 'Save this text as PDF at /documents/story.pdf'\n   - Correct: specifies path + filename + extension\n   - Tool will show: 'Content successfully converted and saved to: /documents/story.pdf'\n\n\u274c INCORRECT Usage Examples:\n1. 'Save this as PDF in /documents/'\n   - Missing filename and extension\n2. 'Convert to PDF'\n   - Missing complete file path\n\nWhen requesting conversion, ALWAYS specify:\n1. The content or input file\n2. The desired output format\n3. For advanced formats: complete output path + filename + extension\nExample: 'Convert this markdown to PDF and save as /path/to/output.pdf'\n\nNote: After conversion, always check the success message for the exact file location.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contents": {
              "type": "string",
              "description": "The content to be converted (required if input_file not provided)"
            },
            "input_file": {
              "type": "string",
              "description": "Complete path to input file including filename and extension (e.g., '/path/to/input.md')"
            },
            "input_format": {
              "type": "string",
              "description": "Source format of the content (defaults to markdown)",
              "default": "markdown",
              "enum": [
                "markdown",
                "html",
                "pdf",
                "docx",
                "rst",
                "latex",
                "epub",
                "txt"
              ]
            },
            "output_format": {
              "type": "string",
              "description": "Desired output format (defaults to markdown)",
              "default": "markdown",
              "enum": [
                "markdown",
                "html",
                "pdf",
                "docx",
                "rst",
                "latex",
                "epub",
                "txt"
              ]
            },
            "output_file": {
              "type": "string",
              "description": "Complete path where to save the output including filename and extension (required for pdf, docx, rst, latex, epub formats)"
            }
          },
          "oneOf": [
            {
              "required": [
                "contents"
              ]
            },
            {
              "required": [
                "input_file"
              ]
            }
          ],
          "allOf": [
            {
              "if": {
                "properties": {
                  "output_format": {
                    "enum": [
                      "pdf",
                      "docx",
                      "rst",
                      "latex",
                      "epub"
                    ]
                  }
                }
              },
              "then": {
                "required": [
                  "output_file"
                ]
              }
            }
          ]
        }
      }
    ]
  },
  "aws-athena": {
    "name": "aws-athena",
    "display_name": "AWS Athena",
    "description": "A MCP server for AWS Athena to run SQL queries on Glue Catalog.",
    "repository": {
      "type": "git",
      "url": "https://github.com/lishenxydlgzs/aws-athena-mcp"
    },
    "homepage": "https://github.com/lishenxydlgzs/aws-athena-mcp",
    "author": {
      "name": "lishenxydlgzs"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "athena",
      "sql",
      "aws"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@lishenxydlgzs/aws-athena-mcp"
        ],
        "env": {
          "OUTPUT_S3_PATH": "${OUTPUT_S3_PATH}",
          "AWS_REGION": "${AWS_REGION}",
          "AWS_PROFILE": "${AWS_PROFILE}",
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_SESSION_TOKEN": "${AWS_SESSION_TOKEN}",
          "QUERY_TIMEOUT_MS": "${QUERY_TIMEOUT_MS}",
          "MAX_RETRIES": "${MAX_RETRIES}",
          "RETRY_DELAY_MS": "${RETRY_DELAY_MS}"
        }
      }
    },
    "examples": [
      {
        "title": "Show All Databases",
        "description": "Lists all databases in Athena",
        "prompt": "{\"database\": \"default\", \"query\": \"SHOW DATABASES\"}"
      },
      {
        "title": "List Tables in a Database",
        "description": "Shows all tables in the default database",
        "prompt": "{\"database\": \"default\", \"query\": \"SHOW TABLES\"}"
      },
      {
        "title": "Get Table Schema",
        "description": "Fetches the schema of the asin_sitebestimg table",
        "prompt": "{\"database\": \"default\", \"query\": \"DESCRIBE default.asin_sitebestimg\"}"
      },
      {
        "title": "Table Rows Preview",
        "description": "Shows some rows from my_database.mytable",
        "prompt": "{\"database\": \"my_database\", \"query\": \"SELECT * FROM my_table LIMIT 10\", \"maxRows\": 10}"
      },
      {
        "title": "Advanced Query with Filtering and Aggregation",
        "description": "Finds the average price by category for in-stock products",
        "prompt": "{\"database\": \"my_database\", \"query\": \"SELECT category, COUNT(*) as count, AVG(price) as avg_price FROM products WHERE in_stock = true GROUP BY category ORDER BY count DESC\", \"maxRows\": 100}"
      }
    ],
    "arguments": {
      "OUTPUT_S3_PATH": {
        "description": "S3 bucket path for saving Athena query results.",
        "required": true,
        "example": "s3://your-bucket/athena-results/"
      },
      "AWS_REGION": {
        "description": "The AWS region to use for Athena queries, defaults to AWS CLI default region.",
        "required": false,
        "example": "us-east-1"
      },
      "AWS_PROFILE": {
        "description": "AWS CLI profile to use, defaults to 'default' profile.",
        "required": false,
        "example": "default"
      },
      "AWS_ACCESS_KEY_ID": {
        "description": "AWS access key for authentication, if not using IAM role or environment variables.",
        "required": false,
        "example": ""
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "AWS secret key for authentication, if not using IAM role or environment variables.",
        "required": false,
        "example": ""
      },
      "AWS_SESSION_TOKEN": {
        "description": "Session token for temporary AWS credentials, if using temporary access.",
        "required": false,
        "example": ""
      },
      "QUERY_TIMEOUT_MS": {
        "description": "Timeout setting for queries in milliseconds (default: 300000 ms).",
        "required": false,
        "example": "300000"
      },
      "MAX_RETRIES": {
        "description": "Number of retry attempts for failed queries (default: 100).",
        "required": false,
        "example": "100"
      },
      "RETRY_DELAY_MS": {
        "description": "Delay between retry attempts in milliseconds (default: 500 ms).",
        "required": false,
        "example": "500"
      }
    },
    "tools": [
      {
        "name": "run_query",
        "description": "Execute a SQL query using AWS Athena. Returns full results if query completes before timeout, otherwise returns queryExecutionId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "description": "The Athena database to query"
            },
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            },
            "maxRows": {
              "type": "number",
              "description": "Maximum number of rows to return (default: 1000)",
              "minimum": 1,
              "maximum": 10000
            },
            "timeoutMs": {
              "type": "number",
              "description": "Timeout in milliseconds (default: 60000)",
              "minimum": 1000
            }
          },
          "required": [
            "database",
            "query"
          ]
        }
      },
      {
        "name": "get_result",
        "description": "Get results for a completed query. Returns error if query is still running.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "queryExecutionId": {
              "type": "string",
              "description": "The query execution ID"
            },
            "maxRows": {
              "type": "number",
              "description": "Maximum number of rows to return (default: 1000)",
              "minimum": 1,
              "maximum": 10000
            }
          },
          "required": [
            "queryExecutionId"
          ]
        }
      },
      {
        "name": "get_status",
        "description": "Get the current status of a query execution",
        "inputSchema": {
          "type": "object",
          "properties": {
            "queryExecutionId": {
              "type": "string",
              "description": "The query execution ID"
            }
          },
          "required": [
            "queryExecutionId"
          ]
        }
      }
    ]
  },
  "basic-memory": {
    "name": "basic-memory",
    "display_name": "Basic Memory",
    "description": "Local-first knowledge management system that builds a semantic graph from Markdown files, enabling persistent memory across conversations with LLMs.",
    "repository": {
      "type": "git",
      "url": "https://github.com/basicmachines-co/basic-memory"
    },
    "homepage": "https://github.com/basicmachines-co/basic-memory",
    "author": {
      "name": "basicmachines-co"
    },
    "license": "AGPL-3.0",
    "categories": [
      "Knowledge Base"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "basic-memory",
          "mcp"
        ]
      }
    },
    "tags": [
      "LLM",
      "Markdown",
      "Knowledge Base"
    ],
    "tools": [
      {
        "name": "delete_note",
        "description": "Delete a note by title or permalink",
        "inputSchema": {
          "properties": {
            "identifier": {
              "title": "Identifier",
              "type": "string"
            }
          },
          "required": [
            "identifier"
          ],
          "title": "delete_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "read_content",
        "description": "Read a file's raw content by path or permalink",
        "inputSchema": {
          "properties": {
            "path": {
              "title": "Path",
              "type": "string"
            }
          },
          "required": [
            "path"
          ],
          "title": "read_contentArguments",
          "type": "object"
        }
      },
      {
        "name": "build_context",
        "description": "Build context from a memory:// URI to continue conversations naturally.\n    \n    Use this to follow up on previous discussions or explore related topics.\n    Timeframes support natural language like:\n    - \"2 days ago\"\n    - \"last week\" \n    - \"today\"\n    - \"3 months ago\"\n    Or standard formats like \"7d\", \"24h\"\n    ",
        "inputSchema": {
          "properties": {
            "url": {
              "maxLength": 2028,
              "minLength": 1,
              "title": "Url",
              "type": "string"
            },
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "title": "Depth"
            },
            "timeframe": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "7d",
              "title": "Timeframe"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            },
            "max_related": {
              "default": 10,
              "title": "Max Related",
              "type": "integer"
            }
          },
          "required": [
            "url"
          ],
          "title": "build_contextArguments",
          "type": "object"
        }
      },
      {
        "name": "recent_activity",
        "description": "Get recent activity from across the knowledge base.\n    \n    Timeframe supports natural language formats like:\n    - \"2 days ago\"  \n    - \"last week\"\n    - \"yesterday\" \n    - \"today\"\n    - \"3 weeks ago\"\n    Or standard formats like \"7d\"\n    ",
        "inputSchema": {
          "$defs": {
            "SearchItemType": {
              "description": "Types of searchable items.",
              "enum": [
                "entity",
                "observation",
                "relation"
              ],
              "title": "SearchItemType",
              "type": "string"
            }
          },
          "properties": {
            "type": {
              "anyOf": [
                {
                  "items": {
                    "$ref": "#/$defs/SearchItemType"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Type"
            },
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "title": "Depth"
            },
            "timeframe": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "7d",
              "title": "Timeframe"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            },
            "max_related": {
              "default": 10,
              "title": "Max Related",
              "type": "integer"
            }
          },
          "title": "recent_activityArguments",
          "type": "object"
        }
      },
      {
        "name": "search_notes",
        "description": "Search across all content in the knowledge base.",
        "inputSchema": {
          "$defs": {
            "SearchItemType": {
              "description": "Types of searchable items.",
              "enum": [
                "entity",
                "observation",
                "relation"
              ],
              "title": "SearchItemType",
              "type": "string"
            },
            "SearchQuery": {
              "description": "Search query parameters.\n\nUse ONE of these primary search modes:\n- permalink: Exact permalink match\n- permalink_match: Path pattern with *\n- text: Full-text search of title/content (supports boolean operators: AND, OR, NOT)\n\nOptionally filter results by:\n- types: Limit to specific item types\n- entity_types: Limit to specific entity types\n- after_date: Only items after date\n\nBoolean search examples:\n- \"python AND flask\" - Find items with both terms\n- \"python OR django\" - Find items with either term\n- \"python NOT django\" - Find items with python but not django\n- \"(python OR flask) AND web\" - Use parentheses for grouping",
              "properties": {
                "permalink": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Permalink"
                },
                "permalink_match": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Permalink Match"
                },
                "text": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Text"
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Title"
                },
                "types": {
                  "anyOf": [
                    {
                      "items": {
                        "$ref": "#/$defs/SearchItemType"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Types"
                },
                "entity_types": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "Entity Types"
                },
                "after_date": {
                  "anyOf": [
                    {
                      "format": "date-time",
                      "type": "string"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "title": "After Date"
                }
              },
              "title": "SearchQuery",
              "type": "object"
            }
          },
          "properties": {
            "query": {
              "$ref": "#/$defs/SearchQuery"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "search_notesArguments",
          "type": "object"
        }
      },
      {
        "name": "read_note",
        "description": "Read a markdown note by title or permalink.",
        "inputSchema": {
          "properties": {
            "identifier": {
              "title": "Identifier",
              "type": "string"
            },
            "page": {
              "default": 1,
              "title": "Page",
              "type": "integer"
            },
            "page_size": {
              "default": 10,
              "title": "Page Size",
              "type": "integer"
            }
          },
          "required": [
            "identifier"
          ],
          "title": "read_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "write_note",
        "description": "Create or update a markdown note. Returns a markdown formatted summary of the semantic content.",
        "inputSchema": {
          "properties": {
            "title": {
              "title": "Title",
              "type": "string"
            },
            "content": {
              "title": "Content",
              "type": "string"
            },
            "folder": {
              "title": "Folder",
              "type": "string"
            },
            "tags": {
              "default": null,
              "title": "tags",
              "type": "string"
            }
          },
          "required": [
            "title",
            "content",
            "folder"
          ],
          "title": "write_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "canvas",
        "description": "Create an Obsidian canvas file to visualize concepts and connections.",
        "inputSchema": {
          "properties": {
            "nodes": {
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "title": "Nodes",
              "type": "array"
            },
            "edges": {
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "title": "Edges",
              "type": "array"
            },
            "title": {
              "title": "Title",
              "type": "string"
            },
            "folder": {
              "title": "Folder",
              "type": "string"
            }
          },
          "required": [
            "nodes",
            "edges",
            "title",
            "folder"
          ],
          "title": "canvasArguments",
          "type": "object"
        }
      },
      {
        "name": "project_info",
        "description": "Get information and statistics about the current Basic Memory project.",
        "inputSchema": {
          "properties": {},
          "title": "project_infoArguments",
          "type": "object"
        }
      }
    ]
  },
  "deepseek-r1": {
    "name": "deepseek-r1",
    "display_name": "Deepseek R1",
    "description": "A Model Context Protocol (MCP) server implementation connecting Claude Desktop with DeepSeek's language models (R1/V3)",
    "repository": {
      "type": "git",
      "url": "https://github.com/66julienmartin/MCP-server-Deepseek_R1"
    },
    "homepage": "https://github.com/66julienmartin/MCP-server-Deepseek_R1",
    "author": {
      "name": "66julienmartin",
      "url": "https://github.com/66julienmartin"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Deepseek",
      "LLM"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/66julienmartin/MCP-server-Deepseek_R1"
        ],
        "env": {
          "DEEPSEEK_API_KEY": "${DEEPSEEK_API_KEY}"
        }
      }
    },
    "arguments": {
      "DEEPSEEK_API_KEY": {
        "description": "API key for authenticating with the Deepseek service.",
        "required": true,
        "example": "your-api-key"
      }
    },
    "tools": [
      {
        "name": "deepseek_r1",
        "description": "Generate text using DeepSeek R1 model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "Input text for DeepSeek"
            },
            "max_tokens": {
              "type": "number",
              "description": "Maximum tokens to generate (default: 8192)",
              "minimum": 1,
              "maximum": 8192
            },
            "temperature": {
              "type": "number",
              "description": "Sampling temperature (default: 0.2)",
              "minimum": 0,
              "maximum": 2
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  "oceanbase": {
    "name": "oceanbase",
    "display_name": "OceanBase",
    "description": "(by yuanoOo) A Model Context Protocol (MCP) server that enables secure interaction with OceanBase databases.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yuanoOo/oceanbase_mcp_server"
    },
    "homepage": "https://github.com/yuanoOo/oceanbase_mcp_server",
    "author": {
      "name": "yuanoOo"
    },
    "license": "Apache-2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "OceanBase",
      "SQL",
      "Security"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/yuanoOo/oceanbase_mcp_server.git",
          "oceanbase_mcp_server"
        ],
        "env": {
          "OB_HOST": "${OB_HOST}",
          "OB_PORT": "${OB_PORT}",
          "OB_USER": "${OB_USER}",
          "OB_PASSWORD": "${OB_PASSWORD}",
          "OB_DATABASE": "${OB_DATABASE}"
        }
      }
    },
    "arguments": {
      "OB_HOST": {
        "description": "Database host for connecting to the OceanBase server.",
        "required": true,
        "example": "localhost"
      },
      "OB_PORT": {
        "description": "Optional: Database port to connect to OceanBase, defaults to 2881 if not specified.",
        "required": false,
        "example": "2881"
      },
      "OB_USER": {
        "description": "Username for authenticating with the OceanBase database.",
        "required": true,
        "example": "your_username"
      },
      "OB_PASSWORD": {
        "description": "Password for the specified database user.",
        "required": true,
        "example": "your_password"
      },
      "OB_DATABASE": {
        "description": "Name of the OceanBase database to connect to.",
        "required": true,
        "example": "your_database"
      }
    },
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the OceanBase server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "mcp-installer": {
    "name": "mcp-installer",
    "display_name": "Installer",
    "description": "This server is a server that installs other MCP servers for you.",
    "repository": {
      "type": "git",
      "url": "https://github.com/anaisbetts/mcp-installer"
    },
    "homepage": "https://github.com/anaisbetts/mcp-installer",
    "author": {
      "name": "anaisbetts"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "installer",
      "server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@anaisbetts/mcp-installer"
        ]
      }
    },
    "examples": [
      {
        "title": "Install MCP server",
        "description": "Install the MCP server named mcp-server-fetch",
        "prompt": "Hey Claude, install the MCP server named mcp-server-fetch"
      },
      {
        "title": "Install server with arguments",
        "description": "Install the @modelcontextprotocol/server-filesystem package as an MCP server with specific arguments",
        "prompt": "Hey Claude, install the @modelcontextprotocol/server-filesystem package as an MCP server. Use ['/Users/anibetts/Desktop'] for the arguments"
      },
      {
        "title": "Install from directory",
        "description": "Install the MCP server from a specific directory",
        "prompt": "Hi Claude, please install the MCP server at /Users/anibetts/code/mcp-youtube, I'm too lazy to do it myself."
      },
      {
        "title": "Set environment variable",
        "description": "Install the server @modelcontextprotocol/server-github with an environment variable",
        "prompt": "Install the server @modelcontextprotocol/server-github. Set the environment variable GITHUB_PERSONAL_ACCESS_TOKEN to '1234567890'"
      }
    ],
    "tools": [
      {
        "name": "install_repo_mcp_server",
        "description": "Install an MCP server via npx or uvx",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The package name of the MCP server"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "install_local_mcp_server",
        "description": "Install an MCP server whose code is cloned locally on your computer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The path to the MCP server code cloned on your computer"
            },
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The arguments to pass along"
            },
            "env": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The environment variables to set, delimited by ="
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  "google-calendar": {
    "name": "google-calendar",
    "display_name": "Google Calendar",
    "description": "Google Calendar MCP Server for managing Google calendar events. Also supports searching for events by attributes like title and location.",
    "repository": {
      "type": "git",
      "url": "https://github.com/nspady/google-calendar-mcp"
    },
    "homepage": "https://github.com/nspady/google-calendar-mcp",
    "author": {
      "name": "nspady"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Google Calendar",
      "event management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/nspady/google-calendar-mcp"
        ]
      }
    },
    "examples": [
      {
        "title": "Add Event from Screenshot",
        "description": "Add events from screenshots and images",
        "prompt": "Add this event to my calendar based on the attached screenshot."
      },
      {
        "title": "Check Upcoming Events",
        "description": "Discover upcoming events outside usual routines",
        "prompt": "What events do I have coming up this week that aren't part of my usual routine?"
      },
      {
        "title": "Check Attendance",
        "description": "Identify events with unaccepted invitations",
        "prompt": "Which events tomorrow have attendees who have not accepted the invitation?"
      },
      {
        "title": "Auto Coordinate Events",
        "description": "Create events based on the available times provided",
        "prompt": "Here's some available that was provided to me by someone. Take a look at the available times and create an event that is free on my work calendar."
      },
      {
        "title": "Check Availability",
        "description": "Provide your availability checking both calendars",
        "prompt": "Please provide availability looking at both my personal and work calendar for this upcoming week."
      }
    ]
  },
  "cryptopanic-mcp-server": {
    "name": "cryptopanic-mcp-server",
    "display_name": "CryptoPanic News",
    "description": "Providing latest cryptocurrency news to AI agents, powered by CryptoPanic.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kukapay/cryptopanic-mcp-server"
    },
    "homepage": "https://github.com/kukapay/cryptopanic-mcp-server",
    "author": {
      "name": "kukapay",
      "url": "https://github.com/kukapay"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Fetch Cryptocurrency News",
        "description": "Get the latest news articles on cryptocurrencies.",
        "prompt": "get_crypto_news(kind='news', num_pages=1)"
      }
    ],
    "categories": [
      "Finance"
    ],
    "tags": [
      "cryptocurrency",
      "news",
      "CryptoPanic"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/kukapay/cryptopanic-mcp-server",
          "main.py"
        ],
        "env": {
          "CRYPTOPANIC_API_KEY": "${CRYPTOPANIC_API_KEY}"
        }
      }
    },
    "arguments": {
      "CRYPTOPANIC_API_KEY": {
        "description": "API key to access CryptoPanic services. This key is necessary to authenticate requests made to the CryptoPanic API.",
        "required": true,
        "example": "your_api_key_here"
      }
    }
  },
  "ghost": {
    "name": "ghost",
    "display_name": "Ghost",
    "description": "A Model Context Protocol (MCP) server for interacting with Ghost CMS through LLM interfaces like Claude.",
    "repository": {
      "type": "git",
      "url": "https://github.com/MFYDev/ghost-mcp"
    },
    "homepage": "https://github.com/MFYDev/ghost-mcp",
    "author": {
      "name": "MFYDev"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "Ghost",
      "CMS",
      "Admin API"
    ],
    "examples": [
      {
        "title": "List Posts",
        "description": "List blog posts with pagination.",
        "prompt": "ghost(action=\"list_posts\", params={\"format\": \"text\", \"page\": 1, \"limit\": 15})"
      },
      {
        "title": "Search Posts by Title",
        "description": "Search for posts by title.",
        "prompt": "ghost(action=\"search_posts_by_title\", params={\"query\": \"Welcome\", \"exact\": False})"
      },
      {
        "title": "Create a Post",
        "description": "Create a new post.",
        "prompt": "ghost(action=\"create_post\", params={\"post_data\": {\"title\": \"New Post via MCP\",\"status\": \"draft\",\"lexical\": \"{\\\"root\\\":{\\\"children\\\":[{\\\"children\\\":[{\\\"detail\\\":0,\\\"format\\\":0,\\\"mode\\\":\\\"normal\\\",\\\"style\\\":\\\"\\\",\\\"text\\\":\\\"Hello World\\\",\\\"type\\\":\\\"text\\\",\\\"version\\\":1}],\\\"direction\\\":\\\"ltr\\\",\\\"format\\\":\\\"\\\",\\\"indent\\\":0,\\\"type\\\":\\\"paragraph\\\",\\\"version\\\":1}],\\\"direction\\\":\\\"ltr\\\",\\\"format\\\":\\\"\\\",\\\"indent\\\":0,\\\"type\\\":\\\"root\\\",\\\"version\\\":1}}\"}}"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/MFYDev/ghost-mcp",
          "src/main.py"
        ],
        "env": {
          "GHOST_API_URL": "${GHOST_API_URL}",
          "GHOST_STAFF_API_KEY": "${GHOST_STAFF_API_KEY}"
        }
      }
    },
    "arguments": {
      "GHOST_API_URL": {
        "description": "Your Ghost Admin API URL",
        "required": true,
        "example": "https://yourblog.com"
      },
      "GHOST_STAFF_API_KEY": {
        "description": "Your Ghost Staff API key",
        "required": true,
        "example": "your_staff_api_key"
      }
    }
  },
  "snowflake": {
    "name": "snowflake",
    "display_name": "Snowflake",
    "description": "This MCP server enables LLMs to interact with Snowflake databases, allowing for secure and controlled data operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/isaacwasserman/mcp-snowflake-server"
    },
    "homepage": "https://github.com/isaacwasserman/mcp-snowflake-server",
    "author": {
      "name": "isaacwasserman"
    },
    "license": "NOT GIVEN",
    "categories": [
      "Databases"
    ],
    "tags": [
      "snowflake",
      "sql",
      "database"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp_snowflake_server",
          "--account",
          "${ACCOUNT}",
          "--warehouse",
          "${WAREHOUSE}",
          "--user",
          "${USER}",
          "--password",
          "${PASSWORD}",
          "--role",
          "${ROLE}",
          "--database",
          "${DATABASE}",
          "--schema",
          "${SCHEMA}"
        ]
      }
    },
    "arguments": {
      "ACCOUNT": {
        "description": "The Snowflake account name to connect to.",
        "required": true,
        "example": "your_account_name"
      },
      "WAREHOUSE": {
        "description": "The name of the virtual warehouse to be used for the session.",
        "required": true,
        "example": "your_warehouse_name"
      },
      "USER": {
        "description": "The username to authenticate with Snowflake.",
        "required": true,
        "example": "your_username"
      },
      "PASSWORD": {
        "description": "The password for the specified user.",
        "required": true,
        "example": "your_password"
      },
      "ROLE": {
        "description": "The role to be assumed during the session.",
        "required": true,
        "example": "your_role_name"
      },
      "DATABASE": {
        "description": "The name of the Snowflake database to connect to.",
        "required": true,
        "example": "your_database_name"
      },
      "SCHEMA": {
        "description": "The schema within the database where queries will be executed.",
        "required": true,
        "example": "your_schema_name"
      }
    },
    "tools": [
      {
        "name": "read_query",
        "description": "Execute a SELECT query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SELECT SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "append_insight",
        "description": "Add a data insight to the memo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "insight": {
              "type": "string",
              "description": "Data insight discovered from analysis"
            }
          },
          "required": [
            "insight"
          ]
        }
      }
    ]
  },
  "rquest": {
    "name": "rquest",
    "display_name": "Rquest",
    "description": "An MCP server providing realistic browser-like HTTP request capabilities with accurate TLS/JA3/JA4 fingerprints for bypassing anti-bot measures.",
    "repository": {
      "type": "git",
      "url": "https://github.com/xxxbrian/mcp-rquest"
    },
    "homepage": "https://github.com/xxxbrian/mcp-rquest",
    "author": {
      "name": "xxxbrian"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "http",
      "request",
      "llm",
      "browser",
      "emulation",
      "pdf",
      "markdown"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-rquest"
        ]
      },
      "python": {
        "type": "python",
        "command": "python",
        "args": [
          "-m",
          "mcp-rquest"
        ]
      }
    },
    "examples": [
      {
        "title": "Convert HTML or PDF to Markdown",
        "description": "Use the get_stored_response_with_markdown tool to convert HTML or PDF responses to Markdown for better processing by LLMs.",
        "prompt": "get_stored_response_with_markdown('document.pdf')"
      }
    ],
    "tools": [
      {
        "name": "http_get",
        "description": "Make an HTTP GET request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_post",
        "description": "Make an HTTP POST request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_put",
        "description": "Make an HTTP PUT request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_delete",
        "description": "Make an HTTP DELETE request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_patch",
        "description": "Make an HTTP PATCH request to the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "form": {
              "type": "array",
              "description": "Form data as [[key, value], ...]"
            },
            "json_payload": {
              "type": "object",
              "description": "JSON payload"
            },
            "body": {
              "type": "object",
              "description": "Request body"
            },
            "multipart": {
              "type": "array",
              "description": "Multipart data as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_head",
        "description": "Make an HTTP HEAD request to retrieve only headers from the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_options",
        "description": "Make an HTTP OPTIONS request to retrieve options for the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "http_trace",
        "description": "Make an HTTP TRACE request for diagnostic tracing of the specified URL",
        "inputSchema": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to send the request to"
            },
            "proxy": {
              "type": "string",
              "description": "Proxy to use for the request"
            },
            "headers": {
              "type": "object",
              "description": "Headers to include in the request"
            },
            "cookies": {
              "type": "object",
              "description": "Cookies to include in the request"
            },
            "allow_redirects": {
              "type": "boolean",
              "description": "Whether to follow redirects"
            },
            "max_redirects": {
              "type": "integer",
              "description": "Maximum number of redirects to follow"
            },
            "auth": {
              "type": "string",
              "description": "Authentication credentials"
            },
            "bearer_auth": {
              "type": "string",
              "description": "Bearer token for authentication"
            },
            "basic_auth": {
              "type": "array",
              "description": "Basic auth credentials as [username, password]"
            },
            "query": {
              "type": "array",
              "description": "Query parameters as [[key, value], ...]"
            },
            "force_store_response_content": {
              "type": "boolean",
              "description": "Force storing response content regardless of size"
            }
          }
        }
      },
      {
        "name": "get_stored_response",
        "description": "Retrieve a stored HTTP response by its ID",
        "inputSchema": {
          "type": "object",
          "required": [
            "response_id"
          ],
          "properties": {
            "response_id": {
              "type": "string",
              "description": "ID of the stored response"
            },
            "start_line": {
              "type": "integer",
              "description": "Starting line number (1-indexed)"
            },
            "end_line": {
              "type": "integer",
              "description": "Ending line number (inclusive)"
            }
          }
        }
      },
      {
        "name": "get_stored_response_with_markdown",
        "description": "Retrieve a stored HTTP response by its ID and convert it to Markdown format. Supports HTML and PDF content types. (Converting large PDF to Markdown may cause timeout, just wait and try again.)",
        "inputSchema": {
          "type": "object",
          "required": [
            "response_id"
          ],
          "properties": {
            "response_id": {
              "type": "string",
              "description": "ID of the stored response"
            }
          }
        }
      },
      {
        "name": "get_model_state",
        "description": "Get the current state of the PDF models(used by `get_stored_response_with_markdown`) loading process",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "restart_model_loading",
        "description": "Restart the PDF models(used by `get_stored_response_with_markdown`) loading process if it failed or got stuck",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "neo4j": {
    "name": "neo4j",
    "display_name": "Neo4j Server",
    "description": "A community built server that interacts with Neo4j Graph Database.",
    "repository": {
      "type": "git",
      "url": "https://github.com/da-okazaki/mcp-neo4j-server"
    },
    "homepage": "https://github.com/da-okazaki/mcp-neo4j-server",
    "author": {
      "name": "da-okazaki"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "neo4j",
      "database"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@alanse/mcp-neo4j-server"
        ],
        "env": {
          "NEO4J_URI": "${NEO4J_URI}",
          "NEO4J_USERNAME": "${NEO4J_USERNAME}",
          "NEO4J_PASSWORD": "${NEO4J_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "Querying Data",
        "description": "Ask questions about the data, e.g., 'Show me all employees in the Sales department'.",
        "prompt": "User: \"Show me all employees in the Sales department\""
      },
      {
        "title": "Creating Data",
        "description": "Instruct the bot to create new entities, e.g., 'Add a new person named John Doe who is 30 years old'.",
        "prompt": "User: \"Add a new person named John Doe who is 30 years old\""
      },
      {
        "title": "Creating Relationships",
        "description": "Request to establish relationships between entities, e.g., 'Make John Doe friends with Jane Smith'.",
        "prompt": "User: \"Make John Doe friends with Jane Smith\""
      },
      {
        "title": "Complex Operations",
        "description": "Perform comprehensive queries like 'Find all products purchased by customers who live in New York'.",
        "prompt": "User: \"Find all products purchased by customers who live in New York\""
      }
    ],
    "arguments": {
      "NEO4J_URI": {
        "description": "Neo4j database URI (default: bolt://localhost:7687)",
        "required": false,
        "example": "bolt://localhost:7687"
      },
      "NEO4J_USERNAME": {
        "description": "Neo4j username (default: neo4j)",
        "required": false,
        "example": "neo4j"
      },
      "NEO4J_PASSWORD": {
        "description": "Neo4j password",
        "required": true
      }
    },
    "tools": [
      {
        "name": "execute_query",
        "description": "Execute a Cypher query on Neo4j database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Cypher query to execute"
            },
            "params": {
              "type": "object",
              "description": "Query parameters",
              "additionalProperties": true
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_node",
        "description": "Create a new node in Neo4j",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string",
              "description": "Node label"
            },
            "properties": {
              "type": "object",
              "description": "Node properties",
              "additionalProperties": true
            }
          },
          "required": [
            "label",
            "properties"
          ]
        }
      },
      {
        "name": "create_relationship",
        "description": "Create a relationship between two nodes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromNodeId": {
              "type": "number",
              "description": "ID of the source node"
            },
            "toNodeId": {
              "type": "number",
              "description": "ID of the target node"
            },
            "type": {
              "type": "string",
              "description": "Relationship type"
            },
            "properties": {
              "type": "object",
              "description": "Relationship properties",
              "additionalProperties": true
            }
          },
          "required": [
            "fromNodeId",
            "toNodeId",
            "type"
          ]
        }
      }
    ]
  },
  "discord": {
    "name": "discord",
    "display_name": "Discord",
    "description": "A MCP server to connect to Discord guilds through a bot and read and write messages in channels",
    "repository": {
      "type": "git",
      "url": "https://github.com/v-3/discordmcp"
    },
    "homepage": "https://github.com/v-3/discordmcp",
    "author": {
      "name": "v-3",
      "url": "https://github.com/v-3"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "Discord",
      "LLM",
      "Bot"
    ],
    "examples": [
      {
        "title": "Read Messages",
        "description": "Fetch the last 5 messages from a channel.",
        "prompt": "{\"channel\": \"general\", \"limit\": 5}"
      },
      {
        "title": "Send Message",
        "description": "Send a message to the specified channel.",
        "prompt": "{\"channel\": \"announcements\", \"message\": \"Meeting starts in 10 minutes\"}"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/v-3/discordmcp"
        ],
        "env": {
          "DISCORD_TOKEN": "${DISCORD_TOKEN}"
        }
      }
    },
    "arguments": {
      "DISCORD_TOKEN": {
        "description": "The Discord bot token required for authentication and to interact with Discord's API.",
        "required": true,
        "example": "your_discord_bot_token_here"
      }
    }
  },
  "airflow": {
    "name": "airflow",
    "display_name": "Apache Airflow",
    "description": "A MCP Server that connects to [Apache Airflow](https://airflow.apache.org/) using official python client.",
    "repository": {
      "type": "git",
      "url": "https://github.com/yangkyeongmo/mcp-server-apache-airflow"
    },
    "homepage": "https://github.com/yangkyeongmo/mcp-server-apache-airflow",
    "author": {
      "name": "yangkyeongmo"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Apache Airflow",
      "DAG",
      "Workflow",
      "Data Pipeline"
    ],
    "arguments": {
      "AIRFLOW_HOST": {
        "description": "URL of your Apache Airflow instance",
        "required": true,
        "example": "https://your-airflow-host:8080"
      },
      "AIRFLOW_USERNAME": {
        "description": "Username for authenticating with Airflow",
        "required": true,
        "example": "admin"
      },
      "AIRFLOW_PASSWORD": {
        "description": "Password for authenticating with Airflow",
        "required": true,
        "example": "your_secure_password"
      }
    },
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "mcp-server-apache-airflow"
        ],
        "env": {
          "AIRFLOW_HOST": "${AIRFLOW_HOST}",
          "AIRFLOW_USERNAME": "${AIRFLOW_USERNAME}",
          "AIRFLOW_PASSWORD": "${AIRFLOW_PASSWORD}"
        }
      }
    },
    "tools": [
      {
        "name": "get_config",
        "description": "Get current configuration",
        "inputSchema": {
          "properties": {
            "section": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Section"
            }
          },
          "title": "get_configArguments",
          "type": "object"
        }
      },
      {
        "name": "get_value",
        "description": "Get a specific option from configuration",
        "inputSchema": {
          "properties": {
            "section": {
              "title": "Section",
              "type": "string"
            },
            "option": {
              "title": "Option",
              "type": "string"
            }
          },
          "required": [
            "section",
            "option"
          ],
          "title": "get_valueArguments",
          "type": "object"
        }
      },
      {
        "name": "list_connections",
        "description": "List all connections",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "list_connectionsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_connection",
        "description": "Create a connection",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            },
            "conn_type": {
              "title": "Conn Type",
              "type": "string"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_id",
            "conn_type"
          ],
          "title": "create_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_connection",
        "description": "Get a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "get_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "update_connection",
        "description": "Update a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            },
            "conn_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Conn Type"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "update_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_connection",
        "description": "Delete a connection by ID",
        "inputSchema": {
          "properties": {
            "conn_id": {
              "title": "Conn Id",
              "type": "string"
            }
          },
          "required": [
            "conn_id"
          ],
          "title": "delete_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "test_connection",
        "description": "Test a connection",
        "inputSchema": {
          "properties": {
            "conn_type": {
              "title": "Conn Type",
              "type": "string"
            },
            "host": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Host"
            },
            "port": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Port"
            },
            "login": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Login"
            },
            "password": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Password"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema"
            },
            "extra": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "conn_type"
          ],
          "title": "test_connectionArguments",
          "type": "object"
        }
      },
      {
        "name": "fetch_dags",
        "description": "Fetch all DAGs",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            },
            "only_active": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Only Active"
            },
            "paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Paused"
            },
            "dag_id_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id Pattern"
            }
          },
          "title": "get_dagsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag",
        "description": "Get a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_details",
        "description": "Get a simplified representation of DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_detailsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_source",
        "description": "Get a source code",
        "inputSchema": {
          "properties": {
            "file_token": {
              "title": "File Token",
              "type": "string"
            }
          },
          "required": [
            "file_token"
          ],
          "title": "get_dag_sourceArguments",
          "type": "object"
        }
      },
      {
        "name": "pause_dag",
        "description": "Pause a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "pause_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "unpause_dag",
        "description": "Unpause a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "unpause_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_tasks",
        "description": "Get tasks for DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_tasksArguments",
          "type": "object"
        }
      },
      {
        "name": "get_task",
        "description": "Get a task by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "task_id"
          ],
          "title": "get_taskArguments",
          "type": "object"
        }
      },
      {
        "name": "get_tasks",
        "description": "Get tasks for DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_tasksArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_dag",
        "description": "Update a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "is_paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Is Paused"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "patch_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_dags",
        "description": "Update multiple DAGs",
        "inputSchema": {
          "properties": {
            "dag_id_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id Pattern"
            },
            "is_paused": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Is Paused"
            },
            "tags": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tags"
            }
          },
          "title": "patch_dagsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag",
        "description": "Delete a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "delete_dagArguments",
          "type": "object"
        }
      },
      {
        "name": "clear_task_instances",
        "description": "Clear a set of task instances",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Ids"
            },
            "start_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date"
            },
            "end_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date"
            },
            "include_subdags": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Subdags"
            },
            "include_parentdag": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Parentdag"
            },
            "include_upstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Upstream"
            },
            "include_downstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Downstream"
            },
            "include_future": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Future"
            },
            "include_past": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Past"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            },
            "reset_dag_runs": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Reset Dag Runs"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "clear_task_instancesArguments",
          "type": "object"
        }
      },
      {
        "name": "set_task_instances_state",
        "description": "Set a state of task instances",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "state": {
              "title": "State",
              "type": "string"
            },
            "task_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Ids"
            },
            "execution_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date"
            },
            "include_upstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Upstream"
            },
            "include_downstream": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Downstream"
            },
            "include_future": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Future"
            },
            "include_past": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Past"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            }
          },
          "required": [
            "dag_id",
            "state"
          ],
          "title": "set_task_instances_stateArguments",
          "type": "object"
        }
      },
      {
        "name": "reparse_dag_file",
        "description": "Request re-parsing of a DAG file",
        "inputSchema": {
          "properties": {
            "file_token": {
              "title": "File Token",
              "type": "string"
            }
          },
          "required": [
            "file_token"
          ],
          "title": "reparse_dag_fileArguments",
          "type": "object"
        }
      },
      {
        "name": "post_dag_run",
        "description": "Trigger a DAG by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Run Id"
            },
            "data_interval_end": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data Interval End"
            },
            "data_interval_start": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data Interval Start"
            },
            "end_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date"
            },
            "execution_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date"
            },
            "external_trigger": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "External Trigger"
            },
            "last_scheduling_decision": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Last Scheduling Decision"
            },
            "logical_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Logical Date"
            },
            "note": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Note"
            },
            "run_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Run Type"
            },
            "start_date": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "post_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_runs",
        "description": "Get DAG runs by ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "updated_at_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Gte"
            },
            "updated_at_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_runsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_runs_batch",
        "description": "List DAG runs (batch)",
        "inputSchema": {
          "properties": {
            "dag_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "page_offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Page Offset"
            },
            "page_limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Page Limit"
            }
          },
          "title": "get_dag_runs_batchArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_run",
        "description": "Get a DAG run by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "get_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "update_dag_run_state",
        "description": "Update a DAG run state by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "update_dag_run_stateArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_run",
        "description": "Delete a DAG run by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "delete_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "clear_dag_run",
        "description": "Clear a DAG run",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "dry_run": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dry Run"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "clear_dag_runArguments",
          "type": "object"
        }
      },
      {
        "name": "set_dag_run_note",
        "description": "Update the DagRun note",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "note": {
              "title": "Note",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "note"
          ],
          "title": "set_dag_run_noteArguments",
          "type": "object"
        }
      },
      {
        "name": "get_upstream_dataset_events",
        "description": "Get dataset events for a DAG run",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "get_upstream_dataset_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_stats",
        "description": "Get DAG stats",
        "inputSchema": {
          "properties": {
            "dag_ids": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            }
          },
          "title": "get_dag_statsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_datasets",
        "description": "List datasets",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "uri_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Uri Pattern"
            },
            "dag_ids": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Ids"
            }
          },
          "title": "get_datasetsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset",
        "description": "Get a dataset by URI",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "uri"
          ],
          "title": "get_datasetArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset_events",
        "description": "Get dataset events",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "dataset_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dataset Id"
            },
            "source_dag_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Dag Id"
            },
            "source_task_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Task Id"
            },
            "source_run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Run Id"
            },
            "source_map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Source Map Index"
            }
          },
          "title": "get_dataset_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "create_dataset_event",
        "description": "Create dataset event",
        "inputSchema": {
          "properties": {
            "dataset_uri": {
              "title": "Dataset Uri",
              "type": "string"
            },
            "extra": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Extra"
            }
          },
          "required": [
            "dataset_uri"
          ],
          "title": "create_dataset_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_dataset_queued_event",
        "description": "Get a queued Dataset event for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "uri"
          ],
          "title": "get_dag_dataset_queued_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dag_dataset_queued_events",
        "description": "Get queued Dataset events for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "get_dag_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_dataset_queued_event",
        "description": "Delete a queued Dataset event for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "uri"
          ],
          "title": "delete_dag_dataset_queued_eventArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dag_dataset_queued_events",
        "description": "Delete queued Dataset events for a DAG",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "before": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            }
          },
          "required": [
            "dag_id"
          ],
          "title": "delete_dag_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_dataset_queued_events",
        "description": "Get queued Dataset events for a Dataset",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            }
          },
          "required": [
            "uri"
          ],
          "title": "get_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_dataset_queued_events",
        "description": "Delete queued Dataset events for a Dataset",
        "inputSchema": {
          "properties": {
            "uri": {
              "title": "Uri",
              "type": "string"
            },
            "before": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            }
          },
          "required": [
            "uri"
          ],
          "title": "delete_dataset_queued_eventsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_event_logs",
        "description": "List log entries from event log",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            },
            "dag_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Dag Id"
            },
            "task_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Task Id"
            },
            "run_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Run Id"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "try_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Try Number"
            },
            "event": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Event"
            },
            "owner": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Owner"
            },
            "before": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Before"
            },
            "after": {
              "anyOf": [
                {
                  "format": "date-time",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "After"
            },
            "included_events": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Included Events"
            },
            "excluded_events": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Excluded Events"
            }
          },
          "title": "get_event_logsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_event_log",
        "description": "Get a specific log entry by ID",
        "inputSchema": {
          "properties": {
            "event_log_id": {
              "title": "Event Log Id",
              "type": "integer"
            }
          },
          "required": [
            "event_log_id"
          ],
          "title": "get_event_logArguments",
          "type": "object"
        }
      },
      {
        "name": "get_import_errors",
        "description": "List import errors",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "get_import_errorsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_import_error",
        "description": "Get a specific import error by ID",
        "inputSchema": {
          "properties": {
            "import_error_id": {
              "title": "Import Error Id",
              "type": "integer"
            }
          },
          "required": [
            "import_error_id"
          ],
          "title": "get_import_errorArguments",
          "type": "object"
        }
      },
      {
        "name": "get_health",
        "description": "Get instance status",
        "inputSchema": {
          "properties": {},
          "title": "get_healthArguments",
          "type": "object"
        }
      },
      {
        "name": "get_version",
        "description": "Get version information",
        "inputSchema": {
          "properties": {},
          "title": "get_versionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_plugins",
        "description": "Get a list of loaded plugins",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "title": "get_pluginsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_pools",
        "description": "List pools",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "get_poolsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_pool",
        "description": "Get a pool by name",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "get_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_pool",
        "description": "Delete a pool",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "delete_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "post_pool",
        "description": "Create a pool",
        "inputSchema": {
          "properties": {
            "name": {
              "title": "Name",
              "type": "string"
            },
            "slots": {
              "title": "Slots",
              "type": "integer"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            },
            "include_deferred": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Deferred"
            }
          },
          "required": [
            "name",
            "slots"
          ],
          "title": "post_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "patch_pool",
        "description": "Update a pool",
        "inputSchema": {
          "properties": {
            "pool_name": {
              "title": "Pool Name",
              "type": "string"
            },
            "slots": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Slots"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            },
            "include_deferred": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Include Deferred"
            }
          },
          "required": [
            "pool_name"
          ],
          "title": "patch_poolArguments",
          "type": "object"
        }
      },
      {
        "name": "get_task_instance",
        "description": "Get a task instance by DAG ID, task ID, and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            }
          },
          "required": [
            "dag_id",
            "task_id",
            "dag_run_id"
          ],
          "title": "get_task_instanceArguments",
          "type": "object"
        }
      },
      {
        "name": "list_task_instances",
        "description": "List task instances by DAG ID and DAG run ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "execution_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Gte"
            },
            "execution_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Execution Date Lte"
            },
            "start_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Gte"
            },
            "start_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Start Date Lte"
            },
            "end_date_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Gte"
            },
            "end_date_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "End Date Lte"
            },
            "updated_at_gte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Gte"
            },
            "updated_at_lte": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Updated At Lte"
            },
            "duration_gte": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Duration Gte"
            },
            "duration_lte": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Duration Lte"
            },
            "state": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            },
            "pool": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Pool"
            },
            "queue": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Queue"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id"
          ],
          "title": "list_task_instancesArguments",
          "type": "object"
        }
      },
      {
        "name": "update_task_instance",
        "description": "Update a task instance by DAG ID, DAG run ID, and task ID",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "State"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id"
          ],
          "title": "update_task_instanceArguments",
          "type": "object"
        }
      },
      {
        "name": "list_variables",
        "description": "List all variables",
        "inputSchema": {
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            },
            "order_by": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Order By"
            }
          },
          "title": "list_variablesArguments",
          "type": "object"
        }
      },
      {
        "name": "create_variable",
        "description": "Create a variable",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            },
            "value": {
              "title": "Value",
              "type": "string"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            }
          },
          "required": [
            "key",
            "value"
          ],
          "title": "create_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "get_variable",
        "description": "Get a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "title": "get_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "update_variable",
        "description": "Update a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            },
            "value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Value"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            }
          },
          "required": [
            "key"
          ],
          "title": "update_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "delete_variable",
        "description": "Delete a variable by key",
        "inputSchema": {
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            }
          },
          "required": [
            "key"
          ],
          "title": "delete_variableArguments",
          "type": "object"
        }
      },
      {
        "name": "get_xcom_entries",
        "description": "Get all XCom entries",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "xcom_key": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Xcom Key"
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Limit"
            },
            "offset": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Offset"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id"
          ],
          "title": "get_xcom_entriesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_xcom_entry",
        "description": "Get an XCom entry",
        "inputSchema": {
          "properties": {
            "dag_id": {
              "title": "Dag Id",
              "type": "string"
            },
            "dag_run_id": {
              "title": "Dag Run Id",
              "type": "string"
            },
            "task_id": {
              "title": "Task Id",
              "type": "string"
            },
            "xcom_key": {
              "title": "Xcom Key",
              "type": "string"
            },
            "map_index": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Map Index"
            },
            "deserialize": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Deserialize"
            },
            "stringify": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Stringify"
            }
          },
          "required": [
            "dag_id",
            "dag_run_id",
            "task_id",
            "xcom_key"
          ],
          "title": "get_xcom_entryArguments",
          "type": "object"
        }
      }
    ]
  },
  "volcengine-tos": {
    "name": "volcengine-tos",
    "display_name": "VolcEngine TOS",
    "description": "A sample MCP server for VolcEngine TOS that flexibly get objects from TOS.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dinghuazhou/sample-mcp-server-tos"
    },
    "author": {
      "name": "dinghuazhou"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "TOS",
      "Volcengine",
      "Data"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dinghuazhou/sample-mcp-server-tos",
          "tos-mcp-server"
        ]
      }
    },
    "examples": [
      {
        "title": "List Buckets",
        "description": "Returns a list of all buckets owned by the authenticated sender of the request",
        "prompt": "ListBuckets"
      },
      {
        "title": "List Objects in a Bucket",
        "description": "Returns some or all (up to 1,000) of the objects in a bucket with each request",
        "prompt": "ListObjectsV2"
      },
      {
        "title": "Get an Object",
        "description": "Retrieves an object from volcengine TOS.",
        "prompt": "GetObject"
      }
    ],
    "homepage": "https://github.com/dinghuazhou/sample-mcp-server-tos"
  },
  "opencti": {
    "name": "opencti",
    "display_name": "OpenCTI",
    "description": "Interact with OpenCTI platform to retrieve threat intelligence data including reports, indicators, malware and threat actors.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Spathodea-Network/opencti-mcp"
    },
    "homepage": "https://github.com/Spathodea-Network/opencti-mcp",
    "author": {
      "name": "Spathodea-Network"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "OpenCTI",
      "Threat Intelligence"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Spathodea-Network/opencti-mcp"
        ],
        "env": {
          "OPENCTI_URL": "${OPENCTI_URL}",
          "OPENCTI_TOKEN": "${OPENCTI_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Latest Reports",
        "description": "Retrieves the most recent threat intelligence reports.",
        "prompt": "{ \"name\": \"get_latest_reports\", \"arguments\": { \"first\": 10 } }"
      },
      {
        "title": "Search Malware",
        "description": "Searches for malware information in the OpenCTI database.",
        "prompt": "{ \"name\": \"search_malware\", \"arguments\": { \"query\": \"ransomware\" } }"
      },
      {
        "title": "User Management - List Users",
        "description": "Lists all users in the system.",
        "prompt": "{ \"name\": \"list_users\", \"arguments\": {} }"
      }
    ],
    "arguments": {
      "OPENCTI_URL": {
        "description": "Your OpenCTI instance URL",
        "required": true
      },
      "OPENCTI_TOKEN": {
        "description": "Your OpenCTI API token",
        "required": true
      }
    },
    "tools": [
      {
        "name": "get_latest_reports",
        "description": "\u7372\u53d6\u6700\u65b0\u7684OpenCTI\u5831\u544a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "get_report_by_id",
        "description": "\u6839\u64daID\u7372\u53d6OpenCTI\u5831\u544a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u5831\u544aID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "search_indicators",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u6307\u6a19",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "search_malware",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u60e1\u610f\u7a0b\u5f0f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "search_threat_actors",
        "description": "\u641c\u5c0bOpenCTI\u4e2d\u7684\u5a01\u8105\u884c\u70ba\u8005",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "\u641c\u5c0b\u95dc\u9375\u5b57"
            },
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_user_by_id",
        "description": "\u6839\u64daID\u7372\u53d6\u4f7f\u7528\u8005\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u4f7f\u7528\u8005ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_users",
        "description": "\u5217\u51fa\u6240\u6709\u4f7f\u7528\u8005",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_groups",
        "description": "\u5217\u51fa\u6240\u6709\u7fa4\u7d44",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "list_attack_patterns",
        "description": "\u5217\u51fa\u6240\u6709\u653b\u64ca\u6a21\u5f0f",
        "inputSchema": {
          "type": "object",
          "properties": {
            "first": {
              "type": "number",
              "description": "\u8fd4\u56de\u7d50\u679c\u6578\u91cf\u9650\u5236",
              "default": 10
            }
          }
        }
      },
      {
        "name": "get_campaign_by_name",
        "description": "\u6839\u64da\u540d\u7a31\u7372\u53d6\u884c\u52d5\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "\u884c\u52d5\u540d\u7a31"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_connectors",
        "description": "\u5217\u51fa\u6240\u6709\u9023\u63a5\u5668",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_status_templates",
        "description": "\u5217\u51fa\u6240\u6709\u72c0\u614b\u6a21\u677f",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_file_by_id",
        "description": "\u6839\u64daID\u7372\u53d6\u6a94\u6848\u8cc7\u8a0a",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "\u6a94\u6848ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_files",
        "description": "\u5217\u51fa\u6240\u6709\u6a94\u6848",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_marking_definitions",
        "description": "\u5217\u51fa\u6240\u6709\u6a19\u8a18\u5b9a\u7fa9",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_labels",
        "description": "\u5217\u51fa\u6240\u6709\u6a19\u7c64",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "arangodb": {
    "name": "arangodb",
    "display_name": "ArangoDB",
    "description": "MCP Server that provides database interaction capabilities through [ArangoDB](https://arangodb.com/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/ravenwits/mcp-server-arangodb"
    },
    "homepage": "https://github.com/ravenwits/mcp-server-arangodb",
    "author": {
      "name": "ravenwits"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "ArangoDB",
      "TypeScript"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ravenwits/mcp-server-arangodb"
        ],
        "description": "Run with npx (requires npm install)",
        "env": {
          "ARANGO_URL": "${ARANGO_URL}",
          "ARANGO_DATABASE": "${ARANGO_DATABASE}",
          "ARANGO_USERNAME": "${ARANGO_USERNAME}",
          "ARANGO_PASSWORD": "${ARANGO_PASSWORD}"
        }
      }
    },
    "examples": [
      {
        "title": "List all collections",
        "description": "Query to list all collections in the database.",
        "prompt": "{}"
      },
      {
        "title": "Insert a new document",
        "description": "Insert a new document into the 'users' collection.",
        "prompt": "{\"collection\": \"users\", \"document\": {\"name\": \"John Doe\", \"email\": \"john@example.com\"}}"
      },
      {
        "title": "Update a document",
        "description": "Update a document in the 'users' collection by key.",
        "prompt": "{\"collection\": \"users\", \"key\": \"123456\", \"update\": {\"name\": \"Jane Doe\"}}"
      },
      {
        "title": "Remove a document",
        "description": "Remove a document from the 'users' collection by key.",
        "prompt": "{\"collection\": \"users\", \"key\": \"123456\"}}"
      },
      {
        "title": "Backup database collections",
        "description": "Backup collections to a specified directory.",
        "prompt": "{\"outputDir\": \"./backup\"}"
      }
    ],
    "arguments": {
      "ARANGO_URL": {
        "description": "ArangoDB server URL (note: 8529 is the default port for ArangoDB for local development)",
        "required": true
      },
      "ARANGO_DATABASE": {
        "description": "Database name",
        "required": true
      },
      "ARANGO_USERNAME": {
        "description": "Database user",
        "required": true
      },
      "ARANGO_PASSWORD": {
        "description": "Database password",
        "required": true
      }
    },
    "tools": [
      {
        "name": "arango_query",
        "description": "Execute an AQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "AQL query string"
            },
            "bindVars": {
              "type": "object",
              "description": "Query bind variables",
              "additionalProperties": true
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "arango_insert",
        "description": "Insert a document into a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "document": {
              "type": "object",
              "description": "Document to insert",
              "additionalProperties": true
            }
          },
          "required": [
            "collection",
            "document"
          ]
        }
      },
      {
        "name": "arango_update",
        "description": "Update a document in a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "key": {
              "type": "string",
              "description": "Document key"
            },
            "update": {
              "type": "object",
              "description": "Update object",
              "additionalProperties": true
            }
          },
          "required": [
            "collection",
            "key",
            "update"
          ]
        }
      },
      {
        "name": "arango_remove",
        "description": "Remove a document from a collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Collection name"
            },
            "key": {
              "type": "string",
              "description": "Document key"
            }
          },
          "required": [
            "collection",
            "key"
          ]
        }
      },
      {
        "name": "arango_backup",
        "description": "Backup collections to JSON files.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "outputDir": {
              "type": "string",
              "description": "An absolute directory path to store backup files",
              "default": "./backup",
              "optional": true
            },
            "collection": {
              "type": "string",
              "description": "Collection name to backup. If not provided, backs up all collections.",
              "optional": true
            },
            "docLimit": {
              "type": "integer",
              "description": "Limit the number of documents to backup. If not provided, backs up all documents.",
              "optional": true
            }
          },
          "required": [
            "outputDir"
          ]
        }
      },
      {
        "name": "arango_list_collections",
        "description": "List all collections in the database",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "arango_create_collection",
        "description": "Create a new collection in the database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the collection to create"
            },
            "type": {
              "type": {
                "2": "DOCUMENT_COLLECTION",
                "3": "EDGE_COLLECTION",
                "DOCUMENT_COLLECTION": 2,
                "EDGE_COLLECTION": 3
              },
              "description": "Type of collection to create",
              "default": 2
            },
            "waitForSync": {
              "type": "boolean",
              "description": "If true, wait for data to be synchronized to disk before returning",
              "default": false
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  "elasticsearch": {
    "name": "elasticsearch",
    "display_name": "Elasticsearch",
    "description": "MCP server implementation that provides Elasticsearch interaction.",
    "repository": {
      "type": "git",
      "url": "https://github.com/cr7258/elasticsearch-mcp-server"
    },
    "homepage": "https://github.com/cr7258/elasticsearch-mcp-server",
    "author": {
      "name": "cr7258"
    },
    "license": "Apache License Version 2.0",
    "categories": [
      "Databases"
    ],
    "tags": [
      "elasticsearch",
      "server"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "elasticsearch-mcp-server"
        ],
        "env": {
          "ELASTIC_HOST": "${ELASTIC_HOST}",
          "ELASTIC_USERNAME": "${ELASTIC_USERNAME}",
          "ELASTIC_PASSWORD": "${ELASTIC_PASSWORD}"
        }
      }
    },
    "arguments": {
      "ELASTIC_HOST": {
        "description": "The host URL of the Elasticsearch server.",
        "required": true,
        "example": "https://localhost:9200"
      },
      "ELASTIC_USERNAME": {
        "description": "The username for authenticating with the Elasticsearch server.",
        "required": true,
        "example": "elastic"
      },
      "ELASTIC_PASSWORD": {
        "description": "The password for authenticating with the Elasticsearch server.",
        "required": true,
        "example": "test123"
      }
    },
    "tools": [
      {
        "name": "list_indices",
        "description": "List all indices in the Elasticsearch cluster",
        "inputSchema": {
          "properties": {},
          "title": "list_indicesArguments",
          "type": "object"
        }
      },
      {
        "name": "get_mapping",
        "description": "Get index mapping",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            }
          },
          "required": [
            "index"
          ],
          "title": "get_mappingArguments",
          "type": "object"
        }
      },
      {
        "name": "get_settings",
        "description": "Get index settings",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            }
          },
          "required": [
            "index"
          ],
          "title": "get_settingsArguments",
          "type": "object"
        }
      },
      {
        "name": "search_documents",
        "description": "Search documents in an index with a custom query",
        "inputSchema": {
          "properties": {
            "index": {
              "title": "Index",
              "type": "string"
            },
            "body": {
              "additionalProperties": true,
              "title": "Body",
              "type": "object"
            }
          },
          "required": [
            "index",
            "body"
          ],
          "title": "search_documentsArguments",
          "type": "object"
        }
      },
      {
        "name": "get_cluster_health",
        "description": "Get cluster health status",
        "inputSchema": {
          "properties": {},
          "title": "get_cluster_healthArguments",
          "type": "object"
        }
      },
      {
        "name": "get_cluster_stats",
        "description": "Get cluster statistics",
        "inputSchema": {
          "properties": {},
          "title": "get_cluster_statsArguments",
          "type": "object"
        }
      }
    ]
  },
  "goal-story": {
    "name": "goal-story",
    "display_name": "Goal Story",
    "description": "a Goal Tracker and Visualization Tool for personal and professional development.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hichana/goalstory-mcp"
    },
    "homepage": "https://github.com/hichana/goalstory-mcp",
    "author": {
      "name": "hichana"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "goal tracking",
      "storytelling",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "goalstory-mcp",
          "https://prod-goalstory-rqc2.encr.app",
          "${YOUR_API_KEY}"
        ]
      }
    },
    "arguments": {
      "YOUR_API_KEY": {
        "description": "The API key required to authenticate your requests to the Goal Story service.",
        "required": true,
        "example": "abcdefgh12345678"
      }
    },
    "tools": [
      {
        "name": "goalstory_about",
        "description": "Retrieve information about Goal Story's philosophy and the power of story-driven goal achievement. Use this to help users understand the unique approach of Goal Storying.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_read_self_user",
        "description": "Get the user's profile data including their preferences, belief systems, and past goal history to enable personalized goal storying and context-aware discussions.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_update_self_user",
        "description": "Update the user's profile including their name, visibility preferences, and personal context. When updating 'about' data, guide the user through questions to understand their motivations, beliefs, and goal-achievement style.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The user's preferred name for their Goal Story profile."
            },
            "about": {
              "type": "string",
              "description": "Personal context including motivations, beliefs, and goal-achievement preferences gathered through guided questions."
            },
            "visibility": {
              "type": "number",
              "description": "Profile visibility setting where 0 = public (viewable by others) and 1 = private (only visible to user)."
            }
          }
        }
      },
      {
        "name": "goalstory_count_goals",
        "description": "Get the total number of goals in the user's journey. Useful for tracking overall progress and goal management patterns.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_create_goal",
        "description": "Begin the goal clarification process by creating a new goal. Always discuss and refine the goal with the user before or after saving, ensuring it's well-defined and aligned with their aspirations. Confirm if any adjustments are needed after creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Clear and specific title that captures the essence of the goal."
            },
            "description": {
              "type": "string",
              "description": "Detailed explanation of the goal, including context, motivation, and desired outcomes."
            },
            "story_mode": {
              "type": "string",
              "description": "Narrative approach that shapes how future stories visualize goal achievement."
            },
            "belief_mode": {
              "type": "string",
              "description": "Framework defining how the user's core beliefs and values influence this goal."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "goalstory_update_goal",
        "description": "Update goal details including name, status, description, outcomes, evidence of completion, and story/belief modes that influence how stories are generated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to be updated."
            },
            "name": {
              "type": "string",
              "description": "Refined or clarified goal title."
            },
            "status": {
              "type": "number",
              "description": "Goal progress status: 0 = active/in progress, 1 = successfully completed."
            },
            "description": {
              "type": "string",
              "description": "Enhanced goal context, motivation, or outcome details."
            },
            "outcome": {
              "type": "string",
              "description": "Actual results and impact achieved through goal completion or progress."
            },
            "evidence": {
              "type": "string",
              "description": "Concrete proof, measurements, or observations of goal progress/completion."
            },
            "story_mode": {
              "type": "string",
              "description": "Updated narrative style for future goal achievement stories."
            },
            "belief_mode": {
              "type": "string",
              "description": "Refined understanding of how personal beliefs shape this goal."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_destroy_goal",
        "description": "Remove a goal and all its associated steps and stories from the user's journey. Use with confirmation to prevent accidental deletion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to be permanently removed."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_goal",
        "description": "Retrieve detailed information about a specific goal to support focused discussion and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the goal to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_read_goals",
        "description": "Get an overview of the user's goal journey, with optional pagination to manage larger sets of goals.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of goals (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of goals to return per page."
            }
          }
        }
      },
      {
        "name": "goalstory_read_current_focus",
        "description": "Identify which goal and step the user is currently focused on to maintain context in discussions and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "goalstory_get_story_context",
        "description": "Gather rich context about the user, their current goal/step, beliefs, and motivations to create deeply personalized and meaningful stories. Combines user profile data with conversation insights.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goalId": {
              "type": "string",
              "description": "Unique identifier of the goal for context gathering."
            },
            "stepId": {
              "type": "string",
              "description": "Unique identifier of the specific step for context gathering."
            },
            "feedback": {
              "type": "string",
              "description": "Additional user input to enhance context understanding."
            }
          },
          "required": [
            "goalId",
            "stepId"
          ]
        }
      },
      {
        "name": "goalstory_create_steps",
        "description": "Formulate actionable steps for a goal through thoughtful discussion. Present the steps for user review either before or after saving, ensuring they're clear and achievable. Confirm if any refinements are needed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal these steps will help achieve."
            },
            "steps": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of clear, actionable step descriptions in sequence."
            }
          },
          "required": [
            "goal_id",
            "steps"
          ]
        }
      },
      {
        "name": "goalstory_read_steps",
        "description": "Access the action plan for a specific goal, showing all steps in the journey toward achievement.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal whose steps to retrieve."
            },
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of steps (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of steps to return per page."
            }
          },
          "required": [
            "goal_id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_step",
        "description": "Get detailed information about a specific step to support focused discussion and story creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_update_step",
        "description": "Update step details including the name, completion status, evidence, and outcome. Use this to track progress and insights.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to update."
            },
            "name": {
              "type": "string",
              "description": "Refined or clarified step description."
            },
            "status": {
              "type": "number",
              "description": "Step completion status: 0 = pending/in progress, 1 = completed."
            },
            "outcome": {
              "type": "string",
              "description": "Results and impact achieved through completing this step."
            },
            "evidence": {
              "type": "string",
              "description": "Concrete proof or observations of step completion."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_destroy_step",
        "description": "Remove a specific step from a goal's action plan.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to be permanently removed."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "goalstory_update_step_notes",
        "description": "Update step notes with additional context, insights, or reflections in markdown format. Use this to capture valuable information from discussions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the step to update."
            },
            "notes": {
              "type": "string",
              "description": "Additional context, insights, or reflections in markdown format."
            }
          },
          "required": [
            "id",
            "notes"
          ]
        }
      },
      {
        "name": "goalstory_create_story",
        "description": "Generate and save a highly personalized story that visualizes achievement of the current goal/step. Uses understanding of the user's beliefs, motivations, and context to create engaging mental imagery. If context is needed, gathers it through user discussion and profile data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal this story supports."
            },
            "step_id": {
              "type": "string",
              "description": "Unique identifier of the specific step this story visualizes."
            },
            "title": {
              "type": "string",
              "description": "Engaging headline that captures the essence of the story."
            },
            "story_text": {
              "type": "string",
              "description": "Detailed narrative that vividly illustrates goal/step achievement."
            }
          },
          "required": [
            "goal_id",
            "step_id",
            "title",
            "story_text"
          ]
        }
      },
      {
        "name": "goalstory_read_stories",
        "description": "Access the collection of personalized stories created for a specific goal/step pair, supporting reflection and motivation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal_id": {
              "type": "string",
              "description": "Unique identifier of the goal whose stories to retrieve."
            },
            "step_id": {
              "type": "string",
              "description": "Unique identifier of the step whose stories to retrieve."
            },
            "page": {
              "type": "number",
              "description": "Page number for viewing subsets of stories (starts at 1)."
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of stories to return per page."
            }
          },
          "required": [
            "goal_id",
            "step_id"
          ]
        }
      },
      {
        "name": "goalstory_read_one_story",
        "description": "Retrieve a specific story to revisit the visualization and mental imagery created for goal achievement.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the story to retrieve."
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  "heurist-mesh-agent": {
    "name": "heurist-mesh-agent",
    "display_name": "Mesh Agent",
    "description": "Access specialized web3 AI agents for blockchain analysis, smart contract security, token metrics, and blockchain interactions through the [Heurist Mesh network](https://github.com/heurist-network/heurist-agent-framework/tree/main/mesh).",
    "repository": {
      "type": "git",
      "url": "https://github.com/heurist-network/heurist-mesh-mcp-server"
    },
    "homepage": "https://github.com/heurist-network/heurist-mesh-mcp-server",
    "author": {
      "name": "Heurist Network"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Heurist",
      "Agent Framework",
      "Blockchain Tools"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/heurist-network/heurist-mesh-mcp-server",
          "mesh-tool-server"
        ],
        "env": {
          "HEURIST_API_KEY": "${HEURIST_API_KEY}"
        }
      }
    },
    "arguments": {
      "HEURIST_API_KEY": {
        "description": "API key for accessing the Heurist services.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "coingeckotokeninfoagent_get_coingecko_id",
        "description": "Search for a token by name to get its CoinGecko ID. This tool helps you find the correct CoinGecko ID for any cryptocurrency when you only know its name or symbol. The CoinGecko ID is required for fetching detailed token information using other CoinGecko tools.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "token_name": {
              "type": "string",
              "description": "The token name to search for"
            }
          },
          "required": [
            "token_name"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_token_info",
        "description": "Get detailed token information and market data using CoinGecko ID. This tool provides comprehensive cryptocurrency data including current price, market cap, trading volume, price changes, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coingecko_id": {
              "type": "string",
              "description": "The CoinGecko ID of the token"
            }
          },
          "required": [
            "coingecko_id"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_trending_coins",
        "description": "Get the current top trending cryptocurrencies on CoinGecko. This tool retrieves a list of the most popular cryptocurrencies based on trading volume and social media mentions.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_token_price_multi",
        "description": "Fetch price data for multiple tokens at once using CoinGecko IDs. Efficiently retrieves current prices and optional market data for multiple cryptocurrencies in a single API call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "Comma-separated CoinGecko IDs of the tokens to query"
            },
            "vs_currencies": {
              "type": "string",
              "description": "Comma-separated target currencies (e.g., usd,eur,btc)",
              "default": "usd"
            },
            "include_market_cap": {
              "type": "boolean",
              "description": "Include market capitalization data",
              "default": false
            },
            "include_24hr_vol": {
              "type": "boolean",
              "description": "Include 24hr trading volume data",
              "default": false
            },
            "include_24hr_change": {
              "type": "boolean",
              "description": "Include 24hr price change percentage",
              "default": false
            },
            "include_last_updated_at": {
              "type": "boolean",
              "description": "Include timestamp of when the data was last updated",
              "default": false
            },
            "precision": {
              "type": "string",
              "description": "Decimal precision for currency values (e.g., 'full' for maximum precision)",
              "default": false
            }
          },
          "required": [
            "ids",
            "vs_currencies"
          ]
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_categories_list",
        "description": "Get a list of all available cryptocurrency categories from CoinGecko. This tool retrieves all the category IDs and names that can be used for further category-specific queries.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_category_data",
        "description": "Get market data for all cryptocurrency categories from CoinGecko. This tool retrieves comprehensive information about all categories including market cap, volume, market cap change, top coins in each category, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "order": {
              "type": "string",
              "description": "Sort order for categories (default: market_cap_desc)",
              "enum": [
                "market_cap_desc",
                "market_cap_asc",
                "name_desc",
                "name_asc",
                "market_cap_change_24h_desc",
                "market_cap_change_24h_asc"
              ]
            }
          },
          "required": []
        }
      },
      {
        "name": "coingeckotokeninfoagent_get_tokens_by_category",
        "description": "Get a list of tokens within a specific category. This tool retrieves token data for all cryptocurrencies that belong to a particular category, including price, market cap, volume, and price changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "string",
              "description": "The CoinGecko category ID (e.g., 'layer-1')"
            },
            "vs_currency": {
              "type": "string",
              "description": "The currency to show results in (default: usd)",
              "default": "usd"
            },
            "order": {
              "type": "string",
              "description": "Sort order for tokens (default: market_cap_desc)",
              "enum": [
                "market_cap_desc",
                "market_cap_asc",
                "volume_desc",
                "volume_asc",
                "id_asc",
                "id_desc"
              ],
              "default": "market_cap_desc"
            },
            "per_page": {
              "type": "integer",
              "description": "Number of results per page (1-250, default: 100)",
              "default": 100,
              "minimum": 1,
              "maximum": 250
            },
            "page": {
              "type": "integer",
              "description": "Page number (default: 1)",
              "default": 1,
              "minimum": 1
            }
          },
          "required": [
            "category_id"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_search_pairs",
        "description": "Search for trading pairs on decentralized exchanges by token name, symbol, or address. This tool helps you find specific trading pairs across multiple DEXs and blockchains. It returns information about the pairs including price, volume, liquidity, and the exchanges where they're available. Data comes from DexScreener and covers major DEXs on most blockchains. The search results may be incomplete if the token is not traded on any of the supported chains.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "Search term (token name, symbol, or address)"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_get_specific_pair_info",
        "description": "Get detailed information about a specific trading pair on a decentralized exchange by chain and pair address. This tool provides comprehensive data about a DEX trading pair including current price, 24h volume, liquidity, price changes, and trading history. Data comes from DexScreener and is updated in real-time. You must specify both the blockchain and the exact pair contract address. The pair address is the LP contract address, not the quote token address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "type": "string",
              "description": "Chain identifier (e.g., solana, bsc, ethereum, base)"
            },
            "pair_address": {
              "type": "string",
              "description": "The pair contract address to look up"
            }
          },
          "required": [
            "chain",
            "pair_address"
          ]
        }
      },
      {
        "name": "dexscreenertokeninfoagent_get_token_pairs",
        "description": "Get all trading pairs for a specific token across decentralized exchanges by chain and token address. This tool retrieves a comprehensive list of all DEX pairs where the specified token is traded on a particular blockchain. It provides data on each pair including the paired token, exchange, price, volume, and liquidity. Data comes from DexScreener and is updated in real-time. You must specify both the blockchain and the exact token contract address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chain": {
              "type": "string",
              "description": "Chain identifier (e.g., solana, bsc, ethereum, base)"
            },
            "token_address": {
              "type": "string",
              "description": "The token contract address to look up all pairs for"
            }
          },
          "required": [
            "chain",
            "token_address"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_search_mentions",
        "description": "Search for mentions of specific tokens or topics on Twitter. This tool finds discussions about cryptocurrencies, blockchain projects, or other topics of interest. It provides the tweets and mentions of smart accounts (only influential ones) and does not contain all tweets. Use this when you want to understand what influential people are saying about a particular token or topic on Twitter. Each of the search keywords should be one word or phrase. A maximum of 5 keywords are allowed. One key word should be one concept. Never use long sentences or phrases as keywords.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of keywords to search for"
            },
            "days_ago": {
              "type": "number",
              "description": "Number of days to look back",
              "default": 20
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results (minimum: 20)",
              "default": 20
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_search_account",
        "description": "Search for a Twitter account with both mention search and account statistics. This tool provides engagement metrics, follower growth, and mentions by smart users. It does not contain all tweets, but only those of influential users. It also identifies the topics and cryptocurrencies they frequently discuss. Data comes from ELFA API and can analyze several weeks of historical activity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "Twitter username to analyze (without @)"
            },
            "days_ago": {
              "type": "number",
              "description": "Number of days to look back for mentions",
              "default": 30
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of mention results",
              "default": 20
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "elfatwitterintelligenceagent_get_trending_tokens",
        "description": "Get current trending tokens on Twitter. This tool identifies which cryptocurrencies and tokens are generating the most buzz on Twitter right now. The results include token names, their relative popularity, and sentiment indicators. Use this when you want to discover which cryptocurrencies are currently being discussed most actively on social media. Data comes from ELFA API and represents real-time trends.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time_window": {
              "type": "string",
              "description": "Time window to analyze",
              "default": "24h"
            }
          }
        }
      },
      {
        "name": "exasearchagent_exa_web_search",
        "description": "Search for webpages related to a query using Exa search. This tool performs a web search and returns relevant results including titles, snippets, and URLs. It's useful for finding up-to-date information on any topic, but may fail to find information of niche topics such like small cap crypto projects. Use this when you need to gather information from across the web.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "The search term"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 10)"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "exasearchagent_exa_answer_question",
        "description": "Get a direct answer to a question using Exa's answer API. This tool provides concise, factual answers to specific questions by searching and analyzing content from across the web. Use this when you need a direct answer to a specific question rather than a list of search results. It may fail to find information of niche topics such like small cap crypto projects.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The question to answer"
            }
          },
          "required": [
            "question"
          ]
        }
      },
      {
        "name": "firecrawlsearchagent_firecrawl_web_search",
        "description": "Execute a web search query by reading the web pages using Firecrawl. It provides more comprehensive information than standard web search by extracting the full contents from the pages. Use this when you need in-depth information on a topic. Data comes from Firecrawl search API. It may fail to find information of niche topics such like small cap crypto projects.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search_term": {
              "type": "string",
              "description": "The search term to execute"
            }
          },
          "required": [
            "search_term"
          ]
        }
      },
      {
        "name": "firecrawlsearchagent_firecrawl_extract_web_data",
        "description": "Extract structured data from one or multiple web pages using natural language instructions using Firecrawl. This tool can process single URLs or entire domains (using wildcards like example.com/*). Use this when you need specific information from websites rather than general search results. You must specify what data to extract from the pages using the 'extraction_prompt' parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract data from. Can include wildcards (e.g., 'example.com/*') to crawl entire domains."
            },
            "extraction_prompt": {
              "type": "string",
              "description": "Natural language description of what data to extract from the pages."
            }
          },
          "required": [
            "urls",
            "extraction_prompt"
          ]
        }
      },
      {
        "name": "goplusanalysisagent_fetch_security_details",
        "description": "Fetch security details of a blockchain token contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contract_address": {
              "type": "string",
              "description": "The token contract address"
            },
            "chain_id": {
              "type": "string",
              "description": "The blockchain chain ID or 'solana' for Solana tokens. Supported chains: Ethereum (1), Optimism (10), Cronos (25), BSC (56), Gnosis (100), HECO (128), Polygon (137), Fantom (250), KCC (321), zkSync Era (324), ETHW (10001), FON (201022), Arbitrum (42161), Avalanche (43114), Linea Mainnet (59144), Base (8453), Tron (tron), Scroll (534352), opBNB (204), Mantle (5000), ZKFair (42766), Blast (81457), Manta Pacific (169), Berachain Artio Testnet (80085), Merlin (4200), Bitlayer Mainnet (200901), zkLink Nova (810180), X Layer Mainnet (196), Solana (solana)",
              "default": 1
            }
          },
          "required": [
            "contract_address"
          ]
        }
      }
    ]
  },
  "json": {
    "name": "json",
    "display_name": "JSON Model Context Protocol",
    "description": "JSON handling and processing server with advanced query capabilities using JSONPath syntax and support for array, string, numeric, and date operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GongRzhe/JSON-MCP-Server"
    },
    "homepage": "https://github.com/GongRzhe/JSON-MCP-Server",
    "author": {
      "name": "GongRzhe"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "json",
      "data querying",
      "standardized tools"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@gongrzhe/server-json-mcp@1.0.3"
        ]
      }
    },
    "tools": [
      {
        "name": "query",
        "description": "Query JSON data using JSONPath syntax",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON data source"
            },
            "jsonPath": {
              "type": "string",
              "description": "JSONPath expression (e.g. $.store.book[*].author)"
            }
          },
          "required": [
            "url",
            "jsonPath"
          ]
        }
      },
      {
        "name": "filter",
        "description": "Filter JSON data using conditions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON data source"
            },
            "jsonPath": {
              "type": "string",
              "description": "Base JSONPath expression"
            },
            "condition": {
              "type": "string",
              "description": "Filter condition (e.g. @.price < 10)"
            }
          },
          "required": [
            "url",
            "jsonPath",
            "condition"
          ]
        }
      }
    ]
  },
  "algorand": {
    "name": "algorand",
    "display_name": "Algorand Implementation",
    "description": "A comprehensive MCP server for tooling interactions (40+) and resource accessibility (60+) plus many useful prompts for interacting with the Algorand blockchain.",
    "repository": {
      "type": "git",
      "url": "https://github.com/GoPlausible/algorand-mcp"
    },
    "homepage": "https://github.com/GoPlausible/algorand-mcp",
    "author": {
      "name": "GoPlausible",
      "url": "https://goplausible.com"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Algorand",
      "Blockchain"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "algorand-mcp"
        ],
        "env": {
          "NFD_API_KEY": "${NFD_API_KEY}",
          "NFD_API_URL": "${NFD_API_URL}",
          "ALGORAND_ALGOD": "${ALGORAND_ALGOD}",
          "ALGORAND_TOKEN": "${ALGORAND_TOKEN}",
          "ALGORAND_INDEXER": "${ALGORAND_INDEXER}",
          "ALGORAND_INDEXER_API": "${ALGORAND_INDEXER_API}",
          "ALGORAND_INDEXER_PORT": "${ALGORAND_INDEXER_PORT}",
          "ALGORAND_NETWORK": "${ALGORAND_NETWORK}"
        }
      }
    },
    "arguments": {
      "NFD_API_KEY": {
        "description": "API key for the NFD service, required for accessing domain functionalities.",
        "required": true,
        "example": "your_nfd_api_key_here"
      },
      "NFD_API_URL": {
        "description": "The URL endpoint for the NFD API service.",
        "required": false,
        "example": "https://api.nf.domains"
      },
      "ALGORAND_ALGOD": {
        "description": "The URL endpoint for the Algorand Algod node.",
        "required": true,
        "example": "https://testnet-api.algonode.cloud"
      },
      "ALGORAND_TOKEN": {
        "description": "The token required to interact with the Algorand Algod node, usually a blank string for testnets.",
        "required": false,
        "example": ""
      },
      "ALGORAND_INDEXER": {
        "description": "The URL endpoint for the Algorand Indexer service.",
        "required": true,
        "example": "https://testnet-idx.algonode.cloud"
      },
      "ALGORAND_INDEXER_API": {
        "description": "The API endpoint for accessing Algorand indexer functionalities.",
        "required": false,
        "example": "https://testnet-idx.algonode.cloud/v2"
      },
      "ALGORAND_INDEXER_PORT": {
        "description": "The port for the Algorand indexer service, usually left blank for default settings.",
        "required": false,
        "example": ""
      },
      "ALGORAND_NETWORK": {
        "description": "The network type being used (e.g., testnet or mainnet).",
        "required": true,
        "example": "testnet"
      }
    }
  },
  "keycloak-mcp": {
    "name": "keycloak-mcp",
    "display_name": "Keycloak Model Context Protocol",
    "description": "This MCP server enables natural language interaction with Keycloak for user and realm management including creating, deleting, and listing users and realms.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ChristophEnglisch/keycloak-model-context-protocol"
    },
    "homepage": "https://github.com/ChristophEnglisch/keycloak-model-context-protocol",
    "author": {
      "name": "ChristophEnglisch"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Keycloak",
      "User Management",
      "Realm Management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "keycloak-model-context-protocol"
        ],
        "env": {
          "KEYCLOAK_URL": "${KEYCLOAK_URL}",
          "KEYCLOAK_ADMIN": "${KEYCLOAK_ADMIN}",
          "KEYCLOAK_ADMIN_PASSWORD": "${KEYCLOAK_ADMIN_PASSWORD}"
        }
      }
    },
    "arguments": {
      "KEYCLOAK_URL": {
        "description": "The URL of the Keycloak server instance that the MCP will connect to.",
        "required": true,
        "example": "http://localhost:8080"
      },
      "KEYCLOAK_ADMIN": {
        "description": "The admin username for accessing the Keycloak server.",
        "required": true,
        "example": "admin"
      },
      "KEYCLOAK_ADMIN_PASSWORD": {
        "description": "The password for the admin user to access the Keycloak server.",
        "required": true,
        "example": "admin"
      }
    }
  },
  "coin-api-mcp": {
    "name": "coin-api-mcp",
    "display_name": "Coin API",
    "description": "Provides access to [coinmarketcap](https://coinmarketcap.com/) cryptocurrency data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/longmans/coin_api_mcp"
    },
    "homepage": "https://github.com/longmans/coin_api_mcp",
    "author": {
      "name": "longmans"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "CoinMarketCap",
      "Cryptocurrency",
      "Data"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/longmans/coin_api_mcp",
          "coin-api"
        ],
        "env": {
          "COINMARKETCAP_API_KEY": "${COINMARKETCAP_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Fetch List of Coins",
        "description": "Retrieve a paginated list of all active cryptocurrencies with market data.",
        "prompt": "Call `listing-coins` to get the latest cryptocurrency listings."
      },
      {
        "title": "Get Coin Information",
        "description": "Retrieve detailed information about a specific cryptocurrency by its ID or symbol.",
        "prompt": "Call `get-coin-info` using the cryptocurrency ID."
      }
    ],
    "arguments": {
      "COINMARKETCAP_API_KEY": {
        "description": "The API key required to access CoinMarketCap data.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "listing-coins",
        "description": "Returns a paginated list of all active cryptocurrencies with latest market data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start": {
              "type": "integer",
              "description": "Optionally offset the start (1-based index) of the paginated list of items to return.",
              "minimum": 1
            },
            "limit": {
              "type": "integer",
              "description": "Optionally specify the number of results to return.",
              "minimum": 1,
              "maximum": 5000
            },
            "price_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum USD price to filter results by.",
              "minimum": 0
            },
            "price_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum USD price to filter results by.",
              "minimum": 0
            },
            "market_cap_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum market cap to filter results by.",
              "minimum": 0
            },
            "market_cap_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum market cap to filter results by.",
              "minimum": 0
            },
            "volume_24h_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum 24 hour USD volume to filter results by.",
              "minimum": 0
            },
            "volume_24h_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum 24 hour USD volume to filter results by.",
              "minimum": 0
            },
            "circulating_supply_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum circulating supply to filter results by.",
              "minimum": 0
            },
            "circulating_supply_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum circulating supply to filter results by.",
              "minimum": 0
            },
            "percent_change_24h_min": {
              "type": "number",
              "description": "Optionally specify a threshold of minimum 24 hour percent change to filter results by.",
              "minimum": -100
            },
            "percent_change_24h_max": {
              "type": "number",
              "description": "Optionally specify a threshold of maximum 24 hour percent change to filter results by.",
              "minimum": -100
            },
            "convert": {
              "type": "string",
              "description": "Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols."
            },
            "convert_id": {
              "type": "string",
              "description": "Optionally calculate market quotes by CoinMarketCap ID instead of symbol."
            },
            "sort": {
              "type": "string",
              "description": "What field to sort the list of cryptocurrencies by.",
              "enum": [
                "market_cap",
                "name",
                "symbol",
                "date_added",
                "market_cap_strict",
                "price",
                "circulating_supply",
                "total_supply",
                "max_supply",
                "num_market_pairs",
                "volume_24h",
                "percent_change_1h",
                "percent_change_24h",
                "percent_change_7d",
                "market_cap_by_total_supply_strict",
                "volume_7d",
                "volume_30d"
              ]
            },
            "sort_dir": {
              "type": "string",
              "description": "The direction in which to order cryptocurrencies against the specified sort.",
              "enum": [
                "asc",
                "desc"
              ]
            },
            "cryptocurrency_type": {
              "type": "string",
              "description": "The type of cryptocurrency to include.",
              "enum": [
                "all",
                "coins",
                "tokens"
              ]
            },
            "tag": {
              "type": "string",
              "description": "The tag of cryptocurrency to include.",
              "enum": [
                "all",
                "defi",
                "filesharing"
              ]
            },
            "aux": {
              "type": "string",
              "description": "Optionally specify a comma-separated list of supplemental data fields to return."
            }
          },
          "required": []
        }
      },
      {
        "name": "get-coin-info",
        "description": "Get coins' information includes details like logo, description, official website URL, social links, and links to a cryptocurrency's technical documentation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "One or more comma-separated CoinMarketCap cryptocurrency IDs. Example: \"1,2\""
            },
            "slug": {
              "type": "string",
              "description": "Alternatively pass a comma-separated list of cryptocurrency slugs. Example: \"bitcoin,ethereum\""
            },
            "symbol": {
              "type": "string",
              "description": "Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\""
            },
            "address": {
              "type": "string",
              "description": "Alternatively pass in a contract address. Example: \"0xc40af1e4fecfa05ce6bab79dcd8b373d2e436c4e\""
            },
            "skip_invalid": {
              "type": "boolean",
              "description": "Pass true to relax request validation rules. When requesting records on multiple cryptocurrencies an error is returned if any invalid cryptocurrencies are requested or a cryptocurrency does not have matching records in the requested timeframe. If set to true, invalid lookups will be skipped allowing valid cryptocurrencies to still be returned.",
              "default": false
            },
            "aux": {
              "type": "string",
              "description": "Optionally specify a comma-separated list of supplemental data fields to return. Pass urls,logo,description,tags,platform,date_added,notice,status to include all auxiliary fields."
            }
          },
          "required": []
        }
      },
      {
        "name": "get-coin-quotes",
        "description": "the latest market quote for 1 or more cryptocurrencies. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "One or more comma-separated cryptocurrency CoinMarketCap IDs. Example: 1,2"
            },
            "slug": {
              "type": "string",
              "description": "Alternatively pass a comma-separated list of cryptocurrency slugs. Example: \"bitcoin,ethereum\""
            },
            "symbol": {
              "type": "string",
              "description": "Alternatively pass one or more comma-separated cryptocurrency symbols. Example: \"BTC,ETH\""
            },
            "convert": {
              "type": "string",
              "description": "Optionally calculate market quotes in up to 120 currencies at once by passing a comma-separated list of cryptocurrency or fiat currency symbols."
            },
            "convert_id": {
              "type": "string",
              "description": "Optionally calculate market quotes by CoinMarketCap ID instead of symbol. This option is identical to\u00a0convert\u00a0outside of ID format."
            },
            "aux": {
              "type": "string",
              "description": "\"num_market_pairs,cmc_rank,date_added,tags,platform,max_supply,circulating_supply,total_supply,is_active,is_fiat\"Optionally specify a comma-separated list of supplemental data fields to return."
            },
            "skip_invalid": {
              "type": "boolean",
              "description": "Pass true to relax request validation rules.",
              "default": false
            }
          },
          "required": []
        }
      }
    ]
  },
  "pif": {
    "name": "pif",
    "display_name": "PIF Framework",
    "description": "A Personal Intelligence Framework (PIF), providing tools for file operations, structured reasoning, and journal-based documentation to support continuity and evolving human-AI collaboration across sessions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hungryrobot1/MCP-PIF"
    },
    "homepage": "https://github.com/hungryrobot1/MCP-PIF",
    "author": {
      "name": "hungryrobot1"
    },
    "license": "MIT",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "PIF",
      "TypeScript",
      "Node.js"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/hungryrobot1/MCP-PIF"
        ]
      }
    },
    "examples": [
      {
        "title": "Reasoning Example",
        "description": "Create a structured thought pattern.",
        "prompt": "reason: { thoughts: [{ content: 'Initial observation' }, { content: 'Building on previous thought', relationType: 'sequence', relationTo: 0 }] }"
      },
      {
        "title": "Journal Creation Example",
        "description": "Document development for future reference.",
        "prompt": "journal_create: { title: 'Implementation Pattern', content: 'Insights about development...', tags: ['development', 'patterns'] }"
      }
    ],
    "arguments": {
      "MCP_WORKSPACE_ROOT": {
        "description": "Environment variable to specify a workspace location for the server.",
        "required": false,
        "example": "/path/to/workspace"
      },
      "MCP_CONFIG": {
        "description": "Environment variable containing a JSON string of configuration options for the server.",
        "required": false,
        "example": "{\"key\": \"value\"}"
      }
    }
  },
  "graphql-schema": {
    "name": "graphql-schema",
    "display_name": "GraphQL Schema Model Context Protocol",
    "description": "Allow LLMs to explore large GraphQL schemas without bloating the context.",
    "repository": {
      "type": "git",
      "url": "https://github.com/hannesj/mcp-graphql-schema"
    },
    "homepage": "https://github.com/hannesj/mcp-graphql-schema",
    "author": {
      "name": "hannesj"
    },
    "license": "[NOT GIVEN]",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GraphQL",
      "LLMs",
      "Schema",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-graphql-schema",
          "/ABSOLUTE/PATH/TO/schema.graphqls"
        ]
      }
    },
    "examples": [
      {
        "title": "List all query fields",
        "description": "Retrieve a list of all available root-level fields for GraphQL queries.",
        "prompt": "What query fields are available in this GraphQL schema?"
      },
      {
        "title": "User query field details",
        "description": "Get detailed definition for the \"user\" query field.",
        "prompt": "Show me the details of the \"user\" query field."
      },
      {
        "title": "Mutation operations",
        "description": "List all mutation operations that can be performed in the schema.",
        "prompt": "What mutation operations can I perform in this schema?"
      },
      {
        "title": "List all types",
        "description": "Retrieve a list of all types defined in the schema.",
        "prompt": "List all types defined in this schema."
      },
      {
        "title": "Type definition",
        "description": "Show the definition of the \"Product\" type.",
        "prompt": "Show me the definition of the \"Product\" type."
      },
      {
        "title": "Order type fields",
        "description": "List all fields of the \"Order\" type.",
        "prompt": "List all fields of the \"Order\" type."
      },
      {
        "title": "Search for types and fields",
        "description": "Search the schema for types and fields related to \"customer.\"",
        "prompt": "Search for types and fields related to \"customer\"."
      }
    ]
  },
  "lightdash": {
    "name": "lightdash",
    "display_name": "Lightdash",
    "description": "Interact with [Lightdash](https://www.lightdash.com/), a BI tool.",
    "repository": {
      "type": "git",
      "url": "https://github.com/syucream/lightdash-mcp-server"
    },
    "homepage": "https://github.com/syucream/lightdash-mcp-server",
    "author": {
      "name": "syucream"
    },
    "license": "MIT",
    "categories": [
      "Analytics"
    ],
    "tags": [
      "Lightdash",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "lightdash-mcp-server"
        ],
        "env": {
          "LIGHTDASH_API_KEY": "${LIGHTDASH_API_KEY}",
          "LIGHTDASH_API_URL": "${LIGHTDASH_API_URL}"
        }
      }
    },
    "arguments": {
      "LIGHTDASH_API_KEY": {
        "description": "Your Lightdash PAT (Personal Access Token) required for authenticating API requests.",
        "required": true,
        "example": "your_personal_access_token_here"
      },
      "LIGHTDASH_API_URL": {
        "description": "The base URL for the Lightdash API that you are connecting to.",
        "required": true,
        "example": "https://your.base.url"
      }
    },
    "tools": [
      {
        "name": "lightdash_list_projects",
        "description": "List all projects in the Lightdash organization",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "lightdash_get_project",
        "description": "Get details of a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_spaces",
        "description": "List all spaces in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_charts",
        "description": "List all charts in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_list_dashboards",
        "description": "List all dashboards in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_custom_metrics",
        "description": "Get custom metrics for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_catalog",
        "description": "Get catalog for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_metrics_catalog",
        "description": "Get metrics catalog for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_charts_as_code",
        "description": "Get charts as code for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_dashboards_as_code",
        "description": "Get dashboards as code for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            }
          },
          "required": [
            "projectUuid"
          ]
        }
      },
      {
        "name": "lightdash_get_metadata",
        "description": "Get metadata for a specific table in the data catalog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            },
            "table": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "projectUuid",
            "table"
          ]
        }
      },
      {
        "name": "lightdash_get_analytics",
        "description": "Get analytics for a specific table in the data catalog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectUuid": {
              "type": "string",
              "format": "uuid",
              "description": "The UUID of the project. You can obtain it from the project list."
            },
            "table": {
              "type": "string"
            }
          },
          "required": [
            "projectUuid",
            "table"
          ]
        }
      },
      {
        "name": "lightdash_get_user_attributes",
        "description": "Get organization user attributes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "goodnews": {
    "name": "goodnews",
    "display_name": "Goodnews",
    "description": "A simple MCP server that delivers curated positive and uplifting news stories.",
    "repository": {
      "type": "git",
      "url": "https://github.com/VectorInstitute/mcp-goodnews"
    },
    "homepage": "https://github.com/VectorInstitute/mcp-goodnews",
    "author": {
      "name": "VectorInstitute"
    },
    "license": "Apache 2.0",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "positive news",
      "uplifting",
      "Cohere",
      "NewsAPI"
    ],
    "examples": [
      {
        "title": "Fetch list of good news",
        "description": "Retrieve uplifting news articles using MCP Goodnews.",
        "prompt": "Show me some good news from today."
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/VectorInstitute/mcp-goodnews",
          "server.py"
        ],
        "env": {
          "NEWS_API_KEY": "<newsapi-api-key>",
          "COHERE_API_KEY": "<cohere-api-key>"
        }
      }
    },
    "arguments": {
      "NEWS_API_KEY": {
        "description": "API key for NewsAPI to fetch news articles",
        "required": true,
        "example": "your_newsapi_key_here"
      },
      "COHERE_API_KEY": {
        "description": "API key for Cohere to analyze sentiment of news articles",
        "required": true,
        "example": "your_cohere_api_key_here"
      }
    }
  },
  "postman": {
    "name": "postman",
    "display_name": "Postman",
    "description": "MCP server for running Postman Collections locally via Newman. Allows for simple execution of Postman Server and returns the results of whether the collection passed all the tests.",
    "repository": {
      "type": "git",
      "url": "https://github.com/shannonlal/mcp-postman"
    },
    "homepage": "https://github.com/shannonlal/mcp-postman",
    "author": {
      "name": "shannonlal"
    },
    "license": "ISC",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Postman",
      "Newman",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/shannonlal/mcp-postman"
        ]
      }
    },
    "tools": [
      {
        "name": "run-collection",
        "description": "Run a Postman Collection using Newman",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Path or URL to the Postman collection"
            },
            "environment": {
              "type": "string",
              "description": "Optional path or URL to environment file"
            },
            "globals": {
              "type": "string",
              "description": "Optional path or URL to globals file"
            },
            "iterationCount": {
              "type": "number",
              "description": "Optional number of iterations to run"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "reaper": {
    "name": "reaper",
    "display_name": "Reaper",
    "description": "Interact with your [Reaper](https://www.reaper.fm/) (Digital Audio Workstation) projects.",
    "repository": {
      "type": "git",
      "url": "https://github.com/dschuler36/reaper-mcp-server"
    },
    "homepage": "https://github.com/dschuler36/reaper-mcp-server",
    "author": {
      "name": "dschuler36"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Reaper",
      "Claude"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/dschuler36/reaper-mcp-server",
          "reaper-mcp-server",
          "--reaper-projects-dir",
          "${REAPER_PROJECTS_DIR}"
        ]
      }
    },
    "examples": [
      {
        "title": "Ask about a Reaper project",
        "description": "Request information about a specific Reaper project you have.",
        "prompt": "What are the tracks in my 'Project A' Reaper file?"
      },
      {
        "title": "Find Reaper projects",
        "description": "Use the tool to locate all Reaper projects in the configured directory.",
        "prompt": "Find all my Reaper projects."
      }
    ],
    "arguments": {
      "REAPER_PROJECTS_DIR": {
        "description": "The directory where Reaper projects are stored, allowing the MCP server to find and interact with them.",
        "required": true,
        "example": "/path/to/reaper/projects"
      }
    }
  },
  "hyperliquid": {
    "name": "hyperliquid",
    "display_name": "Hyperliquid",
    "description": "An MCP server implementation that integrates the Hyperliquid SDK for exchange data.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mektigboy/server-hyperliquid"
    },
    "license": "MIT",
    "author": {
      "name": "mektigboy"
    },
    "homepage": "https://github.com/mektigboy/server-hyperliquid",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Hyperliquid",
      "Exchange"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mektigboy/server-hyperliquid"
        ]
      }
    },
    "tools": [
      {
        "name": "get_all_mids",
        "description": "Get mid prices for all coins on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_candle_snapshot",
        "description": "Get candlestick data for a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coin": {
              "type": "string",
              "description": "The symbol of the token to get candlestick data for"
            },
            "interval": {
              "type": "string",
              "description": "Time interval (e.g., '15m', '1h')"
            },
            "startTime": {
              "type": "number",
              "description": "Start time in milliseconds since epoch"
            },
            "endTime": {
              "type": "number",
              "description": "End time in milliseconds since epoch (optional)"
            }
          },
          "required": [
            "coin",
            "interval",
            "startTime"
          ]
        }
      },
      {
        "name": "get_l2_book",
        "description": "Get the L2 book of a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "The symbol of the token to get the price of"
            },
            "required": [
              "symbol"
            ]
          }
        }
      }
    ]
  },
  "evm-mcp-server": {
    "name": "evm-mcp-server",
    "display_name": "EVM Server",
    "description": "Comprehensive blockchain services for 30+ EVM networks, supporting native tokens, ERC20, NFTs, smart contracts, transactions, and ENS resolution.",
    "repository": {
      "type": "git",
      "url": "https://github.com/mcpdotdirect/evm-mcp-server"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Ethereum",
      "Smart Contracts",
      "AI",
      "Token Transfers",
      "NFTs"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@mcpdotdirect/evm-mcp-server"
        ]
      }
    },
    "author": {
      "name": "mcpdotdirect"
    },
    "homepage": "https://github.com/mcpdotdirect/evm-mcp-server",
    "tools": [
      {
        "name": "get_chain_info",
        "description": "Get information about an EVM network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          }
        }
      },
      {
        "name": "resolve_ens",
        "description": "Resolve an ENS name to an Ethereum address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ensName": {
              "type": "string",
              "description": "ENS name to resolve (e.g., 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. ENS resolution works best on Ethereum mainnet. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "ensName"
          ]
        }
      },
      {
        "name": "get_supported_networks",
        "description": "Get a list of supported EVM networks",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_block_by_number",
        "description": "Get a block by its block number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "blockNumber": {
              "type": "number",
              "description": "The block number to fetch"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "blockNumber"
          ]
        }
      },
      {
        "name": "get_latest_block",
        "description": "Get the latest block from the EVM",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          }
        }
      },
      {
        "name": "get_balance",
        "description": "Get the native token balance (ETH, MATIC, etc.) for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The wallet address or ENS name (e.g., '0x1234...' or 'vitalik.eth') to check the balance for"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_erc20_balance",
        "description": "Get the ERC20 token balance of an Ethereum address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The Ethereum address to check"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The ERC20 token contract address"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_token_balance",
        "description": "Get the balance of an ERC20 token for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the ERC20 token (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC or 'uniswap.eth')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address or ENS name to check the balance for (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_transaction",
        "description": "Get detailed information about a specific transaction by its hash. Includes sender, recipient, value, data, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "The transaction hash to look up (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "get_transaction_receipt",
        "description": "Get a transaction receipt by its hash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "The transaction hash to look up"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "estimate_gas",
        "description": "Estimate the gas cost for a transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "The recipient address"
            },
            "value": {
              "type": "string",
              "description": "The amount of ETH to send in ether (e.g., '0.1')"
            },
            "data": {
              "type": "string",
              "description": "The transaction data as a hex string"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "to"
          ]
        }
      },
      {
        "name": "transfer_eth",
        "description": "Transfer native tokens (ETH, MATIC, etc.) to an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "to": {
              "type": "string",
              "description": "The recipient address or ENS name (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "amount": {
              "type": "string",
              "description": "Amount to send in ETH (or the native token of the network), as a string (e.g., '0.1')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "to",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_erc20",
        "description": "Transfer ERC20 tokens to another address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sending account (this is used for signing and is never stored)"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The address of the ERC20 token contract"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient address"
            },
            "amount": {
              "type": "string",
              "description": "The amount of tokens to send (in token units, e.g., '10' for 10 tokens)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "toAddress",
            "amount"
          ]
        }
      },
      {
        "name": "approve_token_spending",
        "description": "Approve another address (like a DeFi protocol or exchange) to spend your ERC20 tokens. This is often required before interacting with DeFi protocols.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the token owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC20 token to approve for spending (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC on Ethereum)"
            },
            "spenderAddress": {
              "type": "string",
              "description": "The contract address being approved to spend your tokens (e.g., a DEX or lending protocol)"
            },
            "amount": {
              "type": "string",
              "description": "The amount of tokens to approve in token units, not wei (e.g., '1000' to approve spending 1000 tokens). Use a very large number for unlimited approval."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "spenderAddress",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_nft",
        "description": "Transfer an NFT (ERC721 token) from one address to another. Requires the private key of the current owner for signing the transaction.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the NFT owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific NFT to transfer (e.g., '1234')"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient wallet address that will receive the NFT"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "tokenId",
            "toAddress"
          ]
        }
      },
      {
        "name": "transfer_erc1155",
        "description": "Transfer ERC1155 tokens to another address. ERC1155 is a multi-token standard that can represent both fungible and non-fungible tokens in a single contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the token owner account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to transfer (e.g., '1234')"
            },
            "amount": {
              "type": "string",
              "description": "The quantity of tokens to send (e.g., '1' for a single NFT or '10' for 10 fungible tokens)"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient wallet address that will receive the tokens"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "tokenId",
            "amount",
            "toAddress"
          ]
        }
      },
      {
        "name": "transfer_token",
        "description": "Transfer ERC20 tokens to an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the ERC20 token to transfer (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC or 'uniswap.eth')"
            },
            "toAddress": {
              "type": "string",
              "description": "The recipient address or ENS name that will receive the tokens (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "amount": {
              "type": "string",
              "description": "Amount of tokens to send as a string (e.g., '100' for 100 tokens). This will be adjusted for the token's decimals."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "privateKey",
            "tokenAddress",
            "toAddress",
            "amount"
          ]
        }
      },
      {
        "name": "read_contract",
        "description": "Read data from a smart contract by calling a view/pure function. This doesn't modify blockchain state and doesn't require gas or signing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the smart contract to interact with"
            },
            "abi": {
              "type": "array",
              "description": "The ABI (Application Binary Interface) of the smart contract function, as a JSON array"
            },
            "functionName": {
              "type": "string",
              "description": "The name of the function to call on the contract (e.g., 'balanceOf')"
            },
            "args": {
              "type": "array",
              "description": "The arguments to pass to the function, as an array (e.g., ['0x1234...'])"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "functionName"
          ]
        }
      },
      {
        "name": "write_contract",
        "description": "Write data to a smart contract by calling a state-changing function. This modifies blockchain state and requires gas payment and transaction signing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the smart contract to interact with"
            },
            "abi": {
              "type": "array",
              "description": "The ABI (Application Binary Interface) of the smart contract function, as a JSON array"
            },
            "functionName": {
              "type": "string",
              "description": "The name of the function to call on the contract (e.g., 'transfer')"
            },
            "args": {
              "type": "array",
              "description": "The arguments to pass to the function, as an array (e.g., ['0x1234...', '1000000000000000000'])"
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sending account in hex format (with or without 0x prefix). SECURITY: This is used only for transaction signing and is not stored."
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "functionName",
            "args",
            "privateKey"
          ]
        }
      },
      {
        "name": "is_contract",
        "description": "Check if an address is a smart contract or an externally owned account (EOA)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The wallet or contract address or ENS name to check (e.g., '0x1234...' or 'uniswap.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_token_info",
        "description": "Get comprehensive information about an ERC20 token including name, symbol, decimals, total supply, and other metadata. Use this to analyze any token on EVM chains.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC20 token (e.g., '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' for USDC on Ethereum)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_token_balance_erc20",
        "description": "Get ERC20 token balance for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address to check balance for"
            },
            "tokenAddress": {
              "type": "string",
              "description": "The ERC20 token contract address"
            },
            "network": {
              "type": "string",
              "description": "Network name or chain ID. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "address",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "get_nft_info",
        "description": "Get detailed information about a specific NFT (ERC721 token), including collection name, symbol, token URI, and current owner if available.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific NFT token to query (e.g., '1234')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId"
          ]
        }
      },
      {
        "name": "check_nft_ownership",
        "description": "Check if an address owns a specific NFT",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address or ENS name of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for BAYC or 'boredapeyachtclub.eth')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the NFT to check (e.g., '1234')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address or ENS name to check ownership against (e.g., '0x1234...' or 'vitalik.eth')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', etc.) or chain ID. Supports all EVM-compatible networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_erc1155_token_uri",
        "description": "Get the metadata URI for an ERC1155 token (multi-token standard used for both fungible and non-fungible tokens). The URI typically points to JSON metadata about the token.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to query metadata for (e.g., '1234')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId"
          ]
        }
      },
      {
        "name": "get_nft_balance",
        "description": "Get the total number of NFTs owned by an address from a specific collection. This returns the count of NFTs, not individual token IDs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the NFT collection (e.g., '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D' for Bored Ape Yacht Club)"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address to check the NFT balance for (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. Most NFTs are on Ethereum mainnet, which is the default."
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_erc1155_balance",
        "description": "Get the balance of a specific ERC1155 token ID owned by an address. ERC1155 allows multiple tokens of the same ID, so the balance can be greater than 1.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tokenAddress": {
              "type": "string",
              "description": "The contract address of the ERC1155 token collection (e.g., '0x76BE3b62873462d2142405439777e971754E8E77')"
            },
            "tokenId": {
              "type": "string",
              "description": "The ID of the specific token to check the balance for (e.g., '1234')"
            },
            "ownerAddress": {
              "type": "string",
              "description": "The wallet address to check the token balance for (e.g., '0x1234...')"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'ethereum', 'optimism', 'arbitrum', 'base', 'polygon') or chain ID. ERC1155 tokens exist across many networks. Defaults to Ethereum mainnet."
            }
          },
          "required": [
            "tokenAddress",
            "tokenId",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_address_from_private_key",
        "description": "Get the EVM address derived from a private key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "Private key in hex format (with or without 0x prefix). SECURITY: This is used only for address derivation and is not stored."
            }
          },
          "required": [
            "privateKey"
          ]
        }
      }
    ]
  },
  "neovim": {
    "name": "neovim",
    "display_name": "Neovim Server",
    "description": "An MCP Server for your Neovim session.",
    "repository": {
      "type": "git",
      "url": "https://github.com/bigcodegen/mcp-neovim-server"
    },
    "homepage": "https://github.com/bigcodegen/mcp-neovim-server",
    "author": {
      "name": "bigcodegen"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Neovim",
      "MCP",
      "Claude Desktop"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "mcp-neovim-server"
        ],
        "env": {
          "ALLOW_SHELL_COMMANDS": "${ALLOW_SHELL_COMMANDS}",
          "NVIM_SOCKET_PATH": "${NVIM_SOCKET_PATH}"
        }
      }
    },
    "arguments": {
      "ALLOW_SHELL_COMMANDS": {
        "description": "Set to 'true' to enable shell command execution (e.g. `!ls`).",
        "required": false,
        "example": "true"
      },
      "NVIM_SOCKET_PATH": {
        "description": "Set to the path of your Neovim socket.",
        "required": false,
        "example": "/tmp/nvim"
      }
    },
    "tools": [
      {
        "name": "vim_buffer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filename": {
              "type": "string",
              "description": "Optional file name to view a specific buffer"
            }
          }
        }
      },
      {
        "name": "vim_command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "Vim command to execute (use ! prefix for shell commands if enabled)"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "vim_status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filename": {
              "type": "string",
              "description": "Optional file name to get status for a specific buffer"
            }
          }
        }
      },
      {
        "name": "vim_edit",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startLine": {
              "type": "number",
              "description": "The line number where editing should begin (1-indexed)"
            },
            "mode": {
              "type": "string",
              "enum": [
                "insert",
                "replace",
                "replaceAll"
              ],
              "description": "Whether to insert new content, replace existing content, or replace entire buffer"
            },
            "lines": {
              "type": "string",
              "description": "The text content to insert or use as replacement"
            }
          },
          "required": [
            "startLine",
            "mode",
            "lines"
          ]
        }
      },
      {
        "name": "vim_window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "enum": [
                "split",
                "vsplit",
                "only",
                "close",
                "wincmd h",
                "wincmd j",
                "wincmd k",
                "wincmd l"
              ],
              "description": "Window manipulation command: split or vsplit to create new window, only to keep just current window, close to close current window, or wincmd with h/j/k/l to navigate between windows"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "vim_mark",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mark": {
              "type": "string",
              "pattern": "^[a-z]$",
              "description": "Single lowercase letter [a-z] to use as the mark name"
            },
            "line": {
              "type": "number",
              "description": "The line number where the mark should be placed (1-indexed)"
            },
            "column": {
              "type": "number",
              "description": "The column number where the mark should be placed (0-indexed)"
            }
          },
          "required": [
            "mark",
            "line",
            "column"
          ]
        }
      },
      {
        "name": "vim_register",
        "inputSchema": {
          "type": "object",
          "properties": {
            "register": {
              "type": "string",
              "pattern": "^[a-z\\\"]$",
              "description": "Register name - a lowercase letter [a-z] or double-quote [\"] for the unnamed register"
            },
            "content": {
              "type": "string",
              "description": "The text content to store in the specified register"
            }
          },
          "required": [
            "register",
            "content"
          ]
        }
      },
      {
        "name": "vim_visual",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startLine": {
              "type": "number",
              "description": "The starting line number for visual selection (1-indexed)"
            },
            "startColumn": {
              "type": "number",
              "description": "The starting column number for visual selection (0-indexed)"
            },
            "endLine": {
              "type": "number",
              "description": "The ending line number for visual selection (1-indexed)"
            },
            "endColumn": {
              "type": "number",
              "description": "The ending column number for visual selection (0-indexed)"
            }
          },
          "required": [
            "startLine",
            "startColumn",
            "endLine",
            "endColumn"
          ]
        }
      }
    ]
  },
  "aws-resources-operations": {
    "name": "aws-resources-operations",
    "display_name": "AWS Resources",
    "description": "Run generated python code to securely query or modify any AWS resources supported by boto3.",
    "repository": {
      "type": "git",
      "url": "https://github.com/baryhuang/mcp-server-aws-resources-python"
    },
    "homepage": "https://github.com/baryhuang/mcp-server-aws-resources-python",
    "author": {
      "name": "baryhuang"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "AWS",
      "Docker",
      "boto3"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}",
          "-e",
          "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}",
          "-e",
          "AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION}",
          "buryhuang/mcp-server-aws-resources:latest"
        ],
        "env": {
          "AWS_ACCESS_KEY_ID": "${AWS_ACCESS_KEY_ID}",
          "AWS_SECRET_ACCESS_KEY": "${AWS_SECRET_ACCESS_KEY}",
          "AWS_DEFAULT_REGION": "${AWS_DEFAULT_REGION}"
        }
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "Your AWS access key.",
        "required": true,
        "example": "your_access_key_id_here"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "Your AWS secret key.",
        "required": true,
        "example": "your_secret_access_key_here"
      },
      "AWS_DEFAULT_REGION": {
        "description": "AWS region to operate in. Defaults to 'us-east-1' if not set.",
        "required": false,
        "example": "us-east-1"
      }
    },
    "tools": [
      {
        "name": "query_aws_resources",
        "description": "Execute a boto3 code snippet to query AWS resources",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code_snippet": {
              "type": "string",
              "description": "Python code using boto3 to query AWS resources. The code should have default execution setting variable named 'result'. Example code: 'result = boto3.client('s3').list_buckets()'"
            }
          },
          "required": [
            "code_snippet"
          ]
        }
      }
    ]
  },
  "filesystem": {
    "name": "filesystem",
    "display_name": "Filesystem",
    "description": "Secure file operations with configurable access controls",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/filesystem",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Node.js",
      "server",
      "filesystem",
      "operations"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-filesystem",
          "${USER_FILESYSTEM_DIRECTORY}",
          "${USER_FILESYSTEM_ALLOWED_DIR}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_DIRECTORY},dst=/projects/Desktop",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_ALLOWED_DIR},dst=/projects/other/allowed/dir,ro",
          "--mount",
          "type=bind,src=${USER_FILESYSTEM_ALLOWED_FILE},dst=/projects/path/to/file.txt",
          "mcp/filesystem",
          "/projects"
        ]
      }
    },
    "arguments": {
      "USER_FILESYSTEM_DIRECTORY": {
        "description": "The directory to be mounted in the container",
        "required": true,
        "example": "/Users/username/Desktop"
      },
      "USER_FILESYSTEM_ALLOWED_DIR": {
        "description": "The directory to be mounted in the container",
        "required": true,
        "example": "/Users/username/Desktop"
      }
    },
    "tools": [
      {
        "name": "read_file",
        "description": "Read the complete contents of a file from the file system. Handles various text encodings and provides detailed error messages if the file cannot be read. Use this tool when you need to examine the contents of a single file. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "read_multiple_files",
        "description": "Read the contents of multiple files simultaneously. This is more efficient than reading files one by one when you need to analyze or compare multiple files. Each file's content is returned with its path as a reference. Failed reads for individual files won't stop the entire operation. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "write_file",
        "description": "Create a new file or completely overwrite an existing file with new content. Use with caution as it will overwrite existing files without warning. Handles text content with proper encoding. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "content": {
              "type": "string"
            }
          },
          "required": [
            "path",
            "content"
          ]
        }
      },
      {
        "name": "edit_file",
        "description": "Make line-based edits to a text file. Each edit replaces exact line sequences with new content. Returns a git-style diff showing the changes made. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "edits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "oldText": {
                    "type": "string",
                    "description": "Text to search for - must match exactly"
                  },
                  "newText": {
                    "type": "string",
                    "description": "Text to replace with"
                  }
                },
                "required": [
                  "oldText",
                  "newText"
                ],
                "additionalProperties": false
              }
            },
            "dryRun": {
              "type": "boolean",
              "default": false,
              "description": "Preview changes using git-style diff format"
            }
          },
          "required": [
            "path",
            "edits"
          ]
        }
      },
      {
        "name": "create_directory",
        "description": "Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. If the directory already exists, this operation will succeed silently. Perfect for setting up directory structures for projects or ensuring required paths exist. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_directory",
        "description": "Get a detailed listing of all files and directories in a specified path. Results clearly distinguish between files and directories with [FILE] and [DIR] prefixes. This tool is essential for understanding directory structure and finding specific files within a directory. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "directory_tree",
        "description": "Get a recursive tree view of files and directories as a JSON structure. Each entry includes 'name', 'type' (file/directory), and 'children' for directories. Files have no children array, while directories always have a children array (which may be empty). The output is formatted with 2-space indentation for readability. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "move_file",
        "description": "Move or rename files and directories. Can move files between directories and rename them in a single operation. If the destination exists, the operation will fail. Works across different directories and can be used for simple renaming within the same directory. Both source and destination must be within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source": {
              "type": "string"
            },
            "destination": {
              "type": "string"
            }
          },
          "required": [
            "source",
            "destination"
          ]
        }
      },
      {
        "name": "search_files",
        "description": "Recursively search for files and directories matching a pattern. Searches through all subdirectories from the starting path. The search is case-insensitive and matches partial names. Returns full paths to all matching items. Great for finding files when you don't know their exact location. Only searches within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "pattern": {
              "type": "string"
            },
            "excludePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": []
            }
          },
          "required": [
            "path",
            "pattern"
          ]
        }
      },
      {
        "name": "get_file_info",
        "description": "Retrieve detailed metadata about a file or directory. Returns comprehensive information including size, creation time, last modified time, permissions, and type. This tool is perfect for understanding file characteristics without reading the actual content. Only works within allowed directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list_allowed_directories",
        "description": "Returns the list of directories that this server is allowed to access. Use this to understand which directories are available before trying to access files.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  "ergo-blockchain-mcp": {
    "name": "ergo-blockchain-mcp",
    "display_name": "Ergo Blockchain Explorer",
    "description": "-An MCP server to integrate Ergo Blockchain Node and Explorer APIs for checking address balances, analyzing transactions, viewing transaction history, performing forensic analysis of addresses, searching for tokens, and monitoring network status.",
    "repository": {
      "type": "git",
      "url": "https://github.com/marctheshark3/ergo-mcp"
    },
    "homepage": "https://github.com/marctheshark3/ergo-mcp",
    "author": {
      "name": "marctheshark3"
    },
    "license": "MIT",
    "categories": [
      "Finance"
    ],
    "tags": [
      "Ergo",
      "Blockchain",
      "Python",
      "API"
    ],
    "examples": [
      {
        "title": "Running the MCP Server as a Module",
        "description": "Run the server using Python module command.",
        "prompt": "```bash\n# Make sure your virtual environment is activated:\n# Using the full path (recommended):\n/path/to/your/project/.venv/bin/python -m ergo_explorer\n\n# Or with activated virtual environment:\npython -m ergo_explorer\n```"
      },
      {
        "title": "Running Tests",
        "description": "Execute tests using pytest framework.",
        "prompt": "```bash\n# Run all tests\npython -m pytest\n\n# Run specific test files\npython -m pytest tests/unit/test_address_tools.py\n```"
      }
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "ergo-mcp"
        ],
        "env": {
          "SERVER_HOST": "<YOUR_HOST>",
          "SERVER_PORT": "<YOUR_PORT>",
          "SERVER_WORKERS": "<YOUR_WORKERS>",
          "ERGO_NODE_API": "<YOUR_ERGO_NODE_API>",
          "ERGO_NODE_API_KEY": "<YOUR_ERGO_NODE_API_KEY>"
        }
      }
    },
    "arguments": {
      "SERVER_HOST": {
        "description": "Host to bind the server to (default: 0.0.0.0)",
        "required": false,
        "example": "localhost"
      },
      "SERVER_PORT": {
        "description": "Port to run the server on (default: 3001)",
        "required": false,
        "example": "3001"
      },
      "SERVER_WORKERS": {
        "description": "Number of worker processes (default: 4)",
        "required": false,
        "example": "4"
      },
      "ERGO_NODE_API": {
        "description": "URL of the Ergo node API (for node-specific features)",
        "required": false,
        "example": "http://localhost:8080"
      },
      "ERGO_NODE_API_KEY": {
        "description": "API key for the Ergo node (if required)",
        "required": false,
        "example": "your_api_key"
      }
    }
  },
  "nasa": {
    "name": "nasa",
    "display_name": "NASA",
    "description": "Access to a unified gateway of NASA's data sources including but not limited to APOD, NEO, EPIC, GIBS.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ProgramComputer/NASA-MCP-server"
    },
    "homepage": "https://github.com/ProgramComputer/NASA-MCP-server",
    "author": {
      "name": "ProgramComputer"
    },
    "license": "ISC",
    "categories": [
      "Knowledge Base"
    ],
    "tags": [
      "NASA",
      "API",
      "Data",
      "Space",
      "Science"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@programcomputer/nasa-mcp-server"
        ],
        "env": {
          "NASA_API_KEY": "${NASA_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Today's Astronomy Picture of the Day",
        "description": "Fetch the APOD from NASA's API.",
        "prompt": "GET /nasa/apod"
      },
      {
        "title": "Get Mars Rover Photos",
        "description": "Retrieve photos taken by the Curiosity rover on a specific sol.",
        "prompt": "GET /nasa/mars-rover?rover=curiosity&sol=1000"
      },
      {
        "title": "Search for Near Earth Objects",
        "description": "Find any near earth objects recorded in a specified date range.",
        "prompt": "GET /nasa/neo?start_date=2023-01-01&end_date=2023-01-07"
      }
    ],
    "arguments": {
      "NASA_API_KEY": {
        "description": "Your NASA API key (get at api.nasa.gov)",
        "required": false,
        "example": "DEMO_KEY"
      }
    },
    "tools": [
      {
        "name": "nasa/apod",
        "description": "Fetch NASA's Astronomy Picture of the Day",
        "inputSchema": {
          "type": "object",
          "properties": {
            "date": {
              "type": "string",
              "description": "The date of the APOD image to retrieve (YYYY-MM-DD)"
            },
            "count": {
              "type": "number",
              "description": "Count of random APODs to retrieve"
            },
            "start_date": {
              "type": "string",
              "description": "Start date for date range search (YYYY-MM-DD)"
            },
            "end_date": {
              "type": "string",
              "description": "End date for date range search (YYYY-MM-DD)"
            },
            "thumbs": {
              "type": "boolean",
              "description": "Return URL of thumbnail for video content"
            }
          },
          "required": [
            "date"
          ]
        }
      },
      {
        "name": "nasa/neo",
        "description": "Near Earth Object Web Service - information about asteroids",
        "inputSchema": {
          "type": "object",
          "properties": {
            "start_date": {
              "type": "string",
              "description": "Start date for asteroid search (YYYY-MM-DD)"
            },
            "end_date": {
              "type": "string",
              "description": "End date for asteroid search (YYYY-MM-DD)"
            },
            "asteroid_id": {
              "type": "string",
              "description": "ID of a specific asteroid"
            }
          },
          "required": [
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "nasa/epic",
        "description": "Earth Polychromatic Imaging Camera - views of Earth",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "Image collection (natural or enhanced)"
            },
            "date": {
              "type": "string",
              "description": "Date of the image (YYYY-MM-DD)"
            }
          }
        }
      },
      {
        "name": "nasa/gibs",
        "description": "Global Imagery Browse Services - satellite imagery",
        "inputSchema": {
          "type": "object",
          "properties": {
            "layer": {
              "type": "string",
              "description": "Layer name (e.g., MODIS_Terra_CorrectedReflectance_TrueColor)"
            },
            "date": {
              "type": "string",
              "description": "Date of imagery (YYYY-MM-DD)"
            },
            "format": {
              "type": "string",
              "description": "Image format (png, jpg, jpeg)"
            },
            "resolution": {
              "type": "number",
              "description": "Resolution in pixels per degree"
            }
          },
          "required": [
            "layer",
            "date"
          ]
        }
      },
      {
        "name": "nasa/cmr",
        "description": "NASA Common Metadata Repository - search for NASA data collections",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string",
              "description": "Search keyword"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            },
            "sort_key": {
              "type": "string",
              "description": "Field to sort results by"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "nasa/firms",
        "description": "NASA Fire Information for Resource Management System - fire data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            },
            "days": {
              "type": "number",
              "description": "Number of days of data to retrieve"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ]
        }
      },
      {
        "name": "nasa/images",
        "description": "NASA Image and Video Library - search NASA's media archive",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Search query"
            },
            "media_type": {
              "type": "string",
              "description": "Media type (image, video, audio)"
            },
            "year_start": {
              "type": "string",
              "description": "Start year for results"
            },
            "year_end": {
              "type": "string",
              "description": "End year for results"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            }
          },
          "required": [
            "q"
          ]
        }
      },
      {
        "name": "nasa/exoplanet",
        "description": "NASA Exoplanet Archive - data about planets beyond our solar system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "description": "Database table to query"
            },
            "select": {
              "type": "string",
              "description": "Columns to return"
            },
            "where": {
              "type": "string",
              "description": "Filter conditions"
            },
            "order": {
              "type": "string",
              "description": "Ordering of results"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results"
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "nasa/donki",
        "description": "Space Weather Database Of Notifications, Knowledge, Information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Type of space weather event"
            },
            "startDate": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "endDate": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "nasa/mars-rover",
        "description": "NASA Mars Rover Photos - images from Mars rovers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rover": {
              "type": "string",
              "description": "Name of the rover (curiosity, opportunity, spirit, perseverance)"
            },
            "sol": {
              "type": "number",
              "description": "Martian sol (day) of the photos"
            },
            "earth_date": {
              "type": "string",
              "description": "Earth date of the photos (YYYY-MM-DD)"
            },
            "camera": {
              "type": "string",
              "description": "Camera name"
            },
            "page": {
              "type": "number",
              "description": "Page number for pagination"
            }
          },
          "required": [
            "rover"
          ]
        }
      },
      {
        "name": "nasa/eonet",
        "description": "Earth Observatory Natural Event Tracker - natural events data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category": {
              "type": "string",
              "description": "Event category (wildfires, volcanoes, etc.)"
            },
            "days": {
              "type": "number",
              "description": "Number of days to look back"
            },
            "source": {
              "type": "string",
              "description": "Data source"
            },
            "status": {
              "type": "string",
              "description": "Event status (open, closed)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of events to return"
            }
          }
        }
      },
      {
        "name": "nasa/power",
        "description": "Prediction of Worldwide Energy Resources - meteorological data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parameters": {
              "type": "string",
              "description": "Comma-separated data parameters"
            },
            "community": {
              "type": "string",
              "description": "User community (RE, SB, AG, etc.)"
            },
            "longitude": {
              "type": "number",
              "description": "Longitude coordinate"
            },
            "latitude": {
              "type": "number",
              "description": "Latitude coordinate"
            },
            "start": {
              "type": "string",
              "description": "Start date (YYYYMMDD)"
            },
            "end": {
              "type": "string",
              "description": "End date (YYYYMMDD)"
            },
            "format": {
              "type": "string",
              "description": "Response format (json, csv, etc.)"
            }
          },
          "required": [
            "parameters",
            "community",
            "longitude",
            "latitude",
            "start",
            "end"
          ]
        }
      },
      {
        "name": "jpl/sbdb",
        "description": "Small-Body Database (SBDB) - asteroid and comet data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sstr": {
              "type": "string",
              "description": "Search string (e.g., asteroid name, number, or designation)"
            },
            "cad": {
              "type": "boolean",
              "description": "Include close approach data"
            }
          },
          "required": [
            "sstr"
          ]
        }
      },
      {
        "name": "jpl/fireball",
        "description": "Fireball data - atmospheric impact events",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "date-min": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "date-max": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            }
          }
        }
      },
      {
        "name": "jpl/jd_cal",
        "description": "Julian Day number to/from calendar date/time converter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jd": {
              "type": "string",
              "description": "Julian date to convert to calendar date"
            },
            "cd": {
              "type": "string",
              "description": "Calendar date to convert to Julian date (YYYY-MM-DD or YYYY-MM-DDThh:mm:ss format)"
            }
          }
        }
      },
      {
        "name": "jpl/nhats",
        "description": "Human-accessible NEOs (Near-Earth Objects) data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dv": {
              "type": "number",
              "description": "Minimum total delta-V (km/s). Values: 4-12, default: 12"
            },
            "dur": {
              "type": "number",
              "description": "Minimum total mission duration (days). Values: 60-450, default: 450"
            },
            "stay": {
              "type": "number",
              "description": "Minimum stay time (days). Values: 8, 16, 24, 32, default: 8"
            },
            "launch": {
              "type": "string",
              "description": "Launch window (year range). Values: 2020-2025, 2025-2030, 2030-2035, 2035-2040, 2040-2045, 2020-2045, default: 2020-2045"
            },
            "h": {
              "type": "number",
              "description": "Object's maximum absolute magnitude (mag). Values: 16-30"
            },
            "occ": {
              "type": "number",
              "description": "Object's maximum orbit condition code. Values: 0-8"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2000 SG344' or '433')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID (e.g., '2000433')"
            },
            "plot": {
              "type": "boolean",
              "description": "Include base-64 encoded plot image"
            }
          }
        }
      },
      {
        "name": "jpl/cad",
        "description": "Asteroid and comet close approaches to the planets in the past and future",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dist-max": {
              "type": "string",
              "description": "Maximum approach distance (e.g., 0.05, 10LD). Default: 0.05 au"
            },
            "dist-min": {
              "type": "string",
              "description": "Minimum approach distance. Default: none"
            },
            "date-min": {
              "type": "string",
              "description": "Start date for search (YYYY-MM-DD). Default: now"
            },
            "date-max": {
              "type": "string",
              "description": "End date for search (YYYY-MM-DD). Default: +60 days"
            },
            "body": {
              "type": "string",
              "description": "Body to find close approaches to (e.g., Earth, Mars, ALL). Default: Earth"
            },
            "sort": {
              "type": "string",
              "description": "Sort field: date, dist, dist-min, v-inf, v-rel, h, object. Default: date"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2000 SG344' or '433')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID (e.g., '2000433')"
            },
            "neo": {
              "type": "boolean",
              "description": "Limit to NEOs. Default: true"
            },
            "fullname": {
              "type": "boolean",
              "description": "Include full object name in result. Default: false"
            }
          }
        }
      },
      {
        "name": "jpl/sentry",
        "description": "JPL Sentry - NEO Earth impact risk assessment data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "date-min": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD)"
            },
            "date-max": {
              "type": "string",
              "description": "End date (YYYY-MM-DD)"
            },
            "des": {
              "type": "string",
              "description": "Object designation (e.g., '2011 AG5' or '29075')"
            },
            "spk": {
              "type": "string",
              "description": "Object SPK-ID"
            },
            "h-max": {
              "type": "number",
              "description": "Maximum absolute magnitude (size filter)"
            },
            "ps-min": {
              "type": "string",
              "description": "Minimum Palermo Scale value"
            },
            "ip-min": {
              "type": "string",
              "description": "Minimum impact probability"
            },
            "removed": {
              "type": "boolean",
              "description": "Get objects removed from Sentry monitoring"
            },
            "all": {
              "type": "boolean",
              "description": "Get all virtual impactors data"
            }
          }
        }
      },
      {
        "name": "jpl/horizons",
        "description": "JPL Horizons - Solar system objects ephemeris data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "format": {
              "type": "string",
              "description": "Response format (json, text)",
              "enum": [
                "json",
                "text"
              ]
            },
            "COMMAND": {
              "type": "string",
              "description": "Target object identifier (e.g., '499' for Mars, '1' for Ceres, 'C/2020 F3' for Comet NEOWISE)"
            },
            "OBJ_DATA": {
              "type": "string",
              "description": "Include object data",
              "enum": [
                "YES",
                "NO"
              ]
            },
            "MAKE_EPHEM": {
              "type": "string",
              "description": "Generate ephemeris",
              "enum": [
                "YES",
                "NO"
              ]
            },
            "EPHEM_TYPE": {
              "type": "string",
              "description": "Type of ephemeris (OBSERVER, VECTORS, ELEMENTS)",
              "enum": [
                "OBSERVER",
                "VECTORS",
                "ELEMENTS"
              ]
            },
            "CENTER": {
              "type": "string",
              "description": "Coordinate center (e.g., '500@399' for Earth)"
            },
            "START_TIME": {
              "type": "string",
              "description": "Start time for ephemeris (e.g., '2023-01-01')"
            },
            "STOP_TIME": {
              "type": "string",
              "description": "Stop time for ephemeris (e.g., '2023-01-02')"
            },
            "STEP_SIZE": {
              "type": "string",
              "description": "Step size for ephemeris points (e.g., '1d' for daily, '1h' for hourly)"
            },
            "QUANTITIES": {
              "type": "string",
              "description": "Observable quantities to include (e.g., 'A' for all, or '1,2,20,23' for specific ones)"
            },
            "OUT_UNITS": {
              "type": "string",
              "description": "Output units for vector tables",
              "enum": [
                "KM-S",
                "AU-D",
                "KM-D"
              ]
            }
          },
          "required": [
            "COMMAND"
          ]
        }
      }
    ]
  },
  "discourse": {
    "name": "discourse",
    "display_name": "Discourse",
    "description": "A MCP server to search Discourse posts on a Discourse forum.",
    "repository": {
      "type": "git",
      "url": "https://github.com/AshDevFr/discourse-mcp-server"
    },
    "license": "MIT",
    "tags": [
      "discourse",
      "search"
    ],
    "author": {
      "name": "AshDevFr"
    },
    "homepage": "https://github.com/AshDevFr/discourse-mcp-server",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@ashdev/discourse-mcp-server"
        ],
        "env": {
          "DISCOURSE_API_URL": "${DISCOURSE_API_URL}",
          "DISCOURSE_API_KEY": "${DISCOURSE_API_KEY}",
          "DISCOURSE_API_USERNAME": "${DISCOURSE_API_USERNAME}"
        }
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "DISCOURSE_API_URL=${DISCOURSE_API_URL}",
          "-e",
          "DISCOURSE_API_KEY=${DISCOURSE_API_KEY}",
          "-e",
          "DISCOURSE_API_USERNAME=${DISCOURSE_API_USERNAME}",
          "ashdev/discourse-mcp-server"
        ]
      }
    },
    "arguments": {
      "DISCOURSE_API_URL": {
        "description": "API URL for the Discourse forum that the server will connect to.",
        "required": true,
        "example": "https://try.discourse.org"
      },
      "DISCOURSE_API_KEY": {
        "description": "API key for authenticating to the Discourse forum.",
        "required": true,
        "example": "1234"
      },
      "DISCOURSE_API_USERNAME": {
        "description": "Username for authenticating to the Discourse forum.",
        "required": true,
        "example": "ash"
      }
    },
    "categories": [
      "Web Services"
    ],
    "tools": [
      {
        "name": "search_posts",
        "description": "Search Discourse posts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "minLength": 5,
              "description": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "webflow": {
    "name": "webflow",
    "display_name": "Webflow",
    "description": "Interfact with the Webflow APIs",
    "repository": {
      "type": "git",
      "url": "https://github.com/kapilduraphe/webflow-mcp-server"
    },
    "homepage": "https://github.com/kapilduraphe/webflow-mcp-server",
    "author": {
      "name": "kapilduraphe"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "webflow",
      "api"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/kapilduraphe/webflow-mcp-server"
        ],
        "env": {
          "WEBFLOW_API_TOKEN": "${WEBFLOW_API_TOKEN}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Sites",
        "description": "Retrieve a list of all Webflow sites accessible to the authenticated user.",
        "prompt": "get_sites"
      },
      {
        "title": "Get Site",
        "description": "Retrieve detailed information about a specific Webflow site by ID.",
        "prompt": "get_site siteId"
      }
    ],
    "arguments": {
      "WEBFLOW_API_TOKEN": {
        "description": "Your Webflow API token to authenticate requests to the Webflow API. This token is required for the server to function and should be kept secure.",
        "required": true,
        "example": "your-api-token"
      }
    }
  },
  "airtable": {
    "name": "airtable",
    "display_name": "Airtable",
    "description": "Airtable Model Context Protocol Server.",
    "repository": {
      "type": "git",
      "url": "https://github.com/felores/airtable-mcp"
    },
    "author": {
      "name": "felores"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Airtable",
      "Database",
      "API"
    ],
    "arguments": {
      "AIRTABLE_API_KEY": {
        "description": "Airtable API key for authenticating with the Airtable API",
        "required": true,
        "example": "pat.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      }
    },
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@felores/airtable-mcp-server"
        ],
        "env": {
          "AIRTABLE_API_KEY": "${AIRTABLE_API_KEY}"
        },
        "description": "Run with npx (requires npm install)"
      }
    },
    "homepage": "https://github.com/felores/airtable-mcp",
    "tools": [
      {
        "name": "list_bases",
        "description": "List all accessible Airtable bases",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_tables",
        "description": "List all tables in a base",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            }
          },
          "required": [
            "base_id"
          ]
        }
      },
      {
        "name": "create_table",
        "description": "Create a new table in a base",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the new table"
            },
            "description": {
              "type": "string",
              "description": "Description of the table"
            },
            "fields": {
              "type": "array",
              "description": "Initial fields for the table",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Name of the field"
                  },
                  "type": {
                    "type": "string",
                    "description": "Type of the field (e.g., singleLineText, multilineText, number, etc.)"
                  },
                  "description": {
                    "type": "string",
                    "description": "Description of the field"
                  },
                  "options": {
                    "type": "object",
                    "description": "Field-specific options"
                  }
                },
                "required": [
                  "name",
                  "type"
                ]
              }
            }
          },
          "required": [
            "base_id",
            "table_name"
          ]
        }
      },
      {
        "name": "update_table",
        "description": "Update a table's schema",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table to update"
            },
            "name": {
              "type": "string",
              "description": "New name for the table"
            },
            "description": {
              "type": "string",
              "description": "New description for the table"
            }
          },
          "required": [
            "base_id",
            "table_id"
          ]
        }
      },
      {
        "name": "create_field",
        "description": "Create a new field in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table"
            },
            "field": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the field"
                },
                "type": {
                  "type": "string",
                  "description": "Type of the field"
                },
                "description": {
                  "type": "string",
                  "description": "Description of the field"
                },
                "options": {
                  "type": "object",
                  "description": "Field-specific options"
                }
              },
              "required": [
                "name",
                "type"
              ]
            }
          },
          "required": [
            "base_id",
            "table_id",
            "field"
          ]
        }
      },
      {
        "name": "update_field",
        "description": "Update a field in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_id": {
              "type": "string",
              "description": "ID of the table"
            },
            "field_id": {
              "type": "string",
              "description": "ID of the field to update"
            },
            "updates": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "New name for the field"
                },
                "description": {
                  "type": "string",
                  "description": "New description for the field"
                },
                "options": {
                  "type": "object",
                  "description": "New field-specific options"
                }
              }
            }
          },
          "required": [
            "base_id",
            "table_id",
            "field_id",
            "updates"
          ]
        }
      },
      {
        "name": "list_records",
        "description": "List records in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "max_records": {
              "type": "number",
              "description": "Maximum number of records to return"
            }
          },
          "required": [
            "base_id",
            "table_name"
          ]
        }
      },
      {
        "name": "create_record",
        "description": "Create a new record in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "fields": {
              "type": "object",
              "description": "Record fields as key-value pairs"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "fields"
          ]
        }
      },
      {
        "name": "update_record",
        "description": "Update an existing record in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to update"
            },
            "fields": {
              "type": "object",
              "description": "Record fields to update as key-value pairs"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id",
            "fields"
          ]
        }
      },
      {
        "name": "delete_record",
        "description": "Delete a record from a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to delete"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id"
          ]
        }
      },
      {
        "name": "search_records",
        "description": "Search for records in a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "field_name": {
              "type": "string",
              "description": "Name of the field to search in"
            },
            "value": {
              "type": "string",
              "description": "Value to search for"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "field_name",
            "value"
          ]
        }
      },
      {
        "name": "get_record",
        "description": "Get a single record by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_id": {
              "type": "string",
              "description": "ID of the base"
            },
            "table_name": {
              "type": "string",
              "description": "Name of the table"
            },
            "record_id": {
              "type": "string",
              "description": "ID of the record to retrieve"
            }
          },
          "required": [
            "base_id",
            "table_name",
            "record_id"
          ]
        }
      }
    ]
  },
  "sequential-thinking": {
    "name": "sequential-thinking",
    "display_name": "Sequential Thinking",
    "description": "Dynamic and reflective problem-solving through thought sequences",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/blob/main/src/sequentialthinking",
    "author": {
      "name": "modelcontextprotocol"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "dynamic thinking",
      "reflective process",
      "structured thinking"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-sequential-thinking"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/sequentialthinking"
        ]
      }
    },
    "examples": [
      {
        "title": "Example Usage",
        "description": "Using the Sequential Thinking tool for a complex problem",
        "prompt": "Break down the complex problem of organizing an event into manageable steps."
      }
    ],
    "tools": [
      {
        "name": "sequentialthinking",
        "description": "A detailed tool for dynamic and reflective problem-solving through thoughts.\nThis tool helps analyze problems through a flexible thinking process that can adapt and evolve.\nEach thought can build on, question, or revise previous insights as understanding deepens.\n\nWhen to use this tool:\n- Breaking down complex problems into steps\n- Planning and design with room for revision\n- Analysis that might need course correction\n- Problems where the full scope might not be clear initially\n- Problems that require a multi-step solution\n- Tasks that need to maintain context over multiple steps\n- Situations where irrelevant information needs to be filtered out\n\nKey features:\n- You can adjust total_thoughts up or down as you progress\n- You can question or revise previous thoughts\n- You can add more thoughts even after reaching what seemed like the end\n- You can express uncertainty and explore alternative approaches\n- Not every thought needs to build linearly - you can branch or backtrack\n- Generates a solution hypothesis\n- Verifies the hypothesis based on the Chain of Thought steps\n- Repeats the process until satisfied\n- Provides a correct answer\n\nParameters explained:\n- thought: Your current thinking step, which can include:\n* Regular analytical steps\n* Revisions of previous thoughts\n* Questions about previous decisions\n* Realizations about needing more analysis\n* Changes in approach\n* Hypothesis generation\n* Hypothesis verification\n- next_thought_needed: True if you need more thinking, even if at what seemed like the end\n- thought_number: Current number in sequence (can go beyond initial total if needed)\n- total_thoughts: Current estimate of thoughts needed (can be adjusted up/down)\n- is_revision: A boolean indicating if this thought revises previous thinking\n- revises_thought: If is_revision is true, which thought number is being reconsidered\n- branch_from_thought: If branching, which thought number is the branching point\n- branch_id: Identifier for the current branch (if any)\n- needs_more_thoughts: If reaching end but realizing more thoughts needed\n\nYou should:\n1. Start with an initial estimate of needed thoughts, but be ready to adjust\n2. Feel free to question or revise previous thoughts\n3. Don't hesitate to add more thoughts if needed, even at the \"end\"\n4. Express uncertainty when present\n5. Mark thoughts that revise previous thinking or branch into new paths\n6. Ignore information that is irrelevant to the current step\n7. Generate a solution hypothesis when appropriate\n8. Verify the hypothesis based on the Chain of Thought steps\n9. Repeat the process until satisfied with the solution\n10. Provide a single, ideally correct answer as the final output\n11. Only set next_thought_needed to false when truly done and a satisfactory answer is reached",
        "inputSchema": {
          "type": "object",
          "properties": {
            "thought": {
              "type": "string",
              "description": "Your current thinking step"
            },
            "nextThoughtNeeded": {
              "type": "boolean",
              "description": "Whether another thought step is needed"
            },
            "thoughtNumber": {
              "type": "integer",
              "description": "Current thought number",
              "minimum": 1
            },
            "totalThoughts": {
              "type": "integer",
              "description": "Estimated total thoughts needed",
              "minimum": 1
            },
            "isRevision": {
              "type": "boolean",
              "description": "Whether this revises previous thinking"
            },
            "revisesThought": {
              "type": "integer",
              "description": "Which thought is being reconsidered",
              "minimum": 1
            },
            "branchFromThought": {
              "type": "integer",
              "description": "Branching point thought number",
              "minimum": 1
            },
            "branchId": {
              "type": "string",
              "description": "Branch identifier"
            },
            "needsMoreThoughts": {
              "type": "boolean",
              "description": "If more thoughts are needed"
            }
          },
          "required": [
            "thought",
            "nextThoughtNeeded",
            "thoughtNumber",
            "totalThoughts"
          ]
        }
      }
    ]
  },
  "hdw-linkedin": {
    "name": "hdw-linkedin",
    "display_name": "HDW",
    "description": "Access to profile data and management of user account with [HorizonDataWave.ai](https://horizondatawave.ai/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/horizondatawave/hdw-mcp-server"
    },
    "homepage": "https://github.com/horizondatawave/hdw-mcp-server",
    "author": {
      "name": "horizondatawave"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "LinkedIn",
      "API access",
      "Data retrieval",
      "User management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@horizondatawave/mcp"
        ],
        "env": {
          "HDW_ACCESS_TOKEN": "${HDW_ACCESS_TOKEN}",
          "HDW_ACCOUNT_ID": "${HDW_ACCOUNT_ID}"
        }
      }
    },
    "arguments": {
      "HDW_ACCESS_TOKEN": {
        "description": "Access token for HorizonDataWave API, used for authentication and authorization to access user data.",
        "required": true,
        "example": "YOUR_HD_W_ACCESS_TOKEN"
      },
      "HDW_ACCOUNT_ID": {
        "description": "Account ID for HorizonDataWave API, used to identify the user's account.",
        "required": true,
        "example": "YOUR_HD_W_ACCOUNT_ID"
      }
    },
    "tools": [
      {
        "name": "search_linkedin_users",
        "description": "Search for LinkedIn users with various filters like keywords, name, title, company, location etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user page."
            },
            "first_name": {
              "type": "string",
              "description": "Exact first name"
            },
            "last_name": {
              "type": "string",
              "description": "Exact last name"
            },
            "title": {
              "type": "string",
              "description": "Exact word in the title"
            },
            "company_keywords": {
              "type": "string",
              "description": "Exact word in the company name"
            },
            "school_keywords": {
              "type": "string",
              "description": "Exact word in the school name"
            },
            "current_company": {
              "type": "string",
              "description": "Company URN or name"
            },
            "past_company": {
              "type": "string",
              "description": "Past company URN or name"
            },
            "location": {
              "type": "string",
              "description": "Location name or URN"
            },
            "industry": {
              "type": "string",
              "description": "Industry URN or name"
            },
            "education": {
              "type": "string",
              "description": "Education URN or name"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (max 1000)",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_profile",
        "description": "Get detailed information about a LinkedIn user profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User alias, URL, or URN"
            },
            "with_experience": {
              "type": "boolean",
              "description": "Include experience info",
              "default": true
            },
            "with_education": {
              "type": "boolean",
              "description": "Include education info",
              "default": true
            },
            "with_skills": {
              "type": "boolean",
              "description": "Include skills info",
              "default": true
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "get_linkedin_email_user",
        "description": "Get LinkedIn user details by email",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "description": "Email address"
            },
            "count": {
              "type": "number",
              "description": "Max results",
              "default": 5
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "get_linkedin_user_posts",
        "description": "Get LinkedIn posts for a user by URN (must include prefix, example: fsd_profile:ACoAAEWn01QBWENVMWqyM3BHfa1A-xsvxjdaXsY)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max posts",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_reactions",
        "description": "Get LinkedIn reactions for a user by URN (must include prefix, example: fsd_profile:ACoAA...)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max reactions",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_chat_messages",
        "description": "Get top chat messages from LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User URN for filtering messages (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "description": "Max messages to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_chat_message",
        "description": "Send a chat message via LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "text": {
              "type": "string",
              "description": "Message text"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user",
            "text"
          ]
        }
      },
      {
        "name": "send_linkedin_connection",
        "description": "Send a connection invitation to LinkedIn user. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_post_comment",
        "description": "Create a comment on a LinkedIn post or on another comment. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Comment text"
            },
            "urn": {
              "type": "string",
              "description": "URN of the activity or comment to comment on (e.g., 'activity:123' or 'comment:(activity:123,456)')"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "text",
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_connections",
        "description": "Get list of LinkedIn user connections. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connected_after": {
              "type": "number",
              "description": "Filter users that added after the specified date (timestamp)"
            },
            "count": {
              "type": "number",
              "description": "Max connections to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": []
        }
      },
      {
        "name": "get_linkedin_post_reposts",
        "description": "Get LinkedIn reposts for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "count": {
              "type": "number",
              "description": "Max reposts to return",
              "default": 50
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_post_comments",
        "description": "Get LinkedIn comments for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "sort": {
              "type": "string",
              "description": "Sort type (relevance or recent)",
              "enum": [
                "relevance",
                "recent"
              ],
              "default": "relevance"
            },
            "count": {
              "type": "number",
              "description": "Max comments to return",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_google_company",
        "description": "Search for LinkedIn companies using Google search. First result is usually the best match.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Company keywords for search. For example, company name or company website",
              "examples": [
                [
                  "Software as a Service (SaaS)"
                ],
                [
                  "google.com"
                ]
              ]
            },
            "with_urn": {
              "type": "boolean",
              "description": "Include URNs in response (increases execution time)",
              "default": false
            },
            "count_per_keyword": {
              "type": "number",
              "description": "Max results per keyword",
              "default": 1,
              "minimum": 1,
              "maximum": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "get_linkedin_company",
        "description": "Get detailed information about a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company": {
              "type": "string",
              "description": "Company Alias or URL or URN (example: 'openai' or 'company:1441')"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "company"
          ]
        }
      },
      {
        "name": "get_linkedin_company_employees",
        "description": "Get employees of a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Company URNs (example: ['company:14064608'])"
            },
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching employees",
              "examples": [
                "Alex"
              ]
            },
            "first_name": {
              "type": "string",
              "description": "Search for exact first name",
              "examples": [
                "Bill"
              ]
            },
            "last_name": {
              "type": "string",
              "description": "Search for exact last name",
              "examples": [
                "Gates"
              ]
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "companies",
            "count"
          ]
        }
      },
      {
        "name": "send_linkedin_post",
        "description": "Create a post on LinkedIn. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Post text content"
            },
            "visibility": {
              "type": "string",
              "description": "Post visibility",
              "enum": [
                "ANYONE",
                "CONNECTIONS_ONLY"
              ],
              "default": "ANYONE"
            },
            "comment_scope": {
              "type": "string",
              "description": "Who can comment on the post",
              "enum": [
                "ALL",
                "CONNECTIONS_ONLY",
                "NONE"
              ],
              "default": "ALL"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "linkedin_sn_search_users",
        "description": "Advanced search for LinkedIn users using Sales Navigator filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user profile. Using this may reduce result count."
            },
            "first_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact first names to search for"
            },
            "last_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact last names to search for"
            },
            "current_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in current titles"
            },
            "location": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Location URN (geo:*) or name, or array of them"
            },
            "education": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Education URN (company:*) or name, or array of them"
            },
            "languages": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Arabic",
                  "English",
                  "Spanish",
                  "Portuguese",
                  "Chinese",
                  "French",
                  "Italian",
                  "Russian",
                  "German",
                  "Dutch",
                  "Turkish",
                  "Tagalog",
                  "Polish",
                  "Korean",
                  "Japanese",
                  "Malay",
                  "Norwegian",
                  "Danish",
                  "Romanian",
                  "Swedish",
                  "Bahasa Indonesia",
                  "Czech"
                ]
              },
              "description": "Profile languages"
            },
            "past_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in past titles"
            },
            "functions": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Accounting",
                  "Administrative",
                  "Arts and Design",
                  "Business",
                  "Development",
                  "Community and Social Services",
                  "Consulting",
                  "Education",
                  "Engineering",
                  "Entrepreneurship",
                  "Finance",
                  "Healthcare Services",
                  "Human Resources",
                  "Information Technology",
                  "Legal",
                  "Marketing",
                  "Media and Communication",
                  "Military and Protective Services",
                  "Operations",
                  "Product Management",
                  "Program and Project Management",
                  "Purchasing",
                  "Quality Assurance",
                  "Research",
                  "Real Estate",
                  "Sales",
                  "Customer Success and Support"
                ]
              },
              "description": "Job functions"
            },
            "levels": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Entry",
                  "Director",
                  "Owner",
                  "CXO",
                  "Vice President",
                  "Experienced Manager",
                  "Entry Manager",
                  "Strategic",
                  "Senior",
                  "Trainy"
                ]
              },
              "description": "Job seniority levels"
            },
            "years_in_the_current_company": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ]
              },
              "description": "Years in current company ranges"
            },
            "years_in_the_current_position": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ]
              },
              "description": "Years in current position ranges"
            },
            "company_sizes": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Self-employed",
                  "1-10",
                  "11-50",
                  "51-200",
                  "201-500",
                  "501-1,000",
                  "1,001-5,000",
                  "5,001-10,000",
                  "10,001+"
                ]
              },
              "description": "Company size ranges"
            },
            "company_types": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Public Company",
                  "Privately Held",
                  "Non Profit",
                  "Educational Institution",
                  "Partnership",
                  "Self Employed",
                  "Self Owned",
                  "Government Agency"
                ]
              },
              "description": "Company types"
            },
            "company_locations": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Company location URN (geo:*) or name, or array of them"
            },
            "current_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Current company URN (company:*) or name, or array of them"
            },
            "past_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Past company URN (company:*) or name, or array of them"
            },
            "industry": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Industry URN (industry:*) or name, or array of them"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (max 2500)",
              "default": 10,
              "minimum": 1,
              "maximum": 2500
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300,
              "minimum": 20,
              "maximum": 1500
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_conversations",
        "description": "Get list of LinkedIn conversations from the messaging interface. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "connected_after": {
              "type": "number",
              "description": "Filter conversations created after the specified date (timestamp)"
            },
            "count": {
              "type": "number",
              "description": "Max conversations to return",
              "default": 20
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds",
              "default": 300
            }
          },
          "required": []
        }
      },
      {
        "name": "google_search",
        "description": "Search for information using Google search API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query. For example: 'python fastapi'"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of results (from 1 to 20)",
              "default": 10
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in seconds (20-1500)",
              "default": 300
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  "unity-integration-advanced": {
    "name": "unity-integration-advanced",
    "display_name": "Unity Integration",
    "description": "Advanced Unity3d Game Engine MCP which supports ,Execution of Any Editor Related Code Directly Inside of Unity, Fetch Logs, Get Editor State and Allow File Access of the Project making it much more useful in Script Editing or asset creation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/quazaai/UnityMCPIntegration"
    },
    "homepage": "https://github.com/quazaai/UnityMCPIntegration",
    "author": {
      "name": "quazaai"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Unity",
      "Integration",
      "AI"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/quazaai/UnityMCPIntegration"
        ],
        "env": {
          "MCP_WEBSOCKET_PORT": "${MCP_WEBSOCKET_PORT}"
        }
      }
    },
    "examples": [
      {
        "title": "Get Unity Editor State",
        "description": "Retrieve comprehensive information about the current Unity project and editor state.",
        "prompt": "get_editor_state()"
      },
      {
        "title": "Execute C# Code",
        "description": "Run specific C# code directly within the Unity Editor.",
        "prompt": "execute_editor_command('Debug.Log(\"Hello, World!\");')"
      }
    ],
    "arguments": {
      "MCP_WEBSOCKET_PORT": {
        "description": "Environment variable to specify the WebSocket port used by the MCP server.",
        "required": false,
        "example": "5010"
      }
    },
    "tools": [
      {
        "name": "get_current_scene_info",
        "description": "Retrieve information about the current scene in Unity Editor with configurable detail level",
        "inputSchema": {
          "type": "object",
          "properties": {
            "detailLevel": {
              "type": "string",
              "enum": [
                "RootObjectsOnly",
                "FullHierarchy"
              ],
              "description": "RootObjectsOnly: Returns just root GameObjects. FullHierarchy: Returns complete hierarchy with all children.",
              "default": "RootObjectsOnly"
            }
          }
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "scene"
        ],
        "returns": {
          "type": "object",
          "description": "Returns information about the current scene and its hierarchy based on requested detail level"
        }
      },
      {
        "name": "get_game_objects_info",
        "description": "Retrieve detailed information about specific GameObjects in the current scene",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceIDs": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of GameObject instance IDs to get information for",
              "minItems": 1
            },
            "detailLevel": {
              "type": "string",
              "enum": [
                "BasicInfo",
                "IncludeComponents",
                "IncludeChildren",
                "IncludeComponentsAndChildren"
              ],
              "description": "BasicInfo: Basic GameObject information. IncludeComponents: Includes component details. IncludeChildren: Includes child GameObjects. IncludeComponentsAndChildren: Includes both components and a full hierarchy with components on children.",
              "default": "IncludeComponents"
            }
          },
          "required": [
            "instanceIDs"
          ]
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "gameobjects"
        ],
        "returns": {
          "type": "object",
          "description": "Returns detailed information about the requested GameObjects"
        }
      },
      {
        "name": "execute_editor_command",
        "description": "Execute C# code directly in the Unity Editor - allows full flexibility including custom namespaces and multiple classes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "C# code to execute in Unity Editor. You MUST define a public class named \"McpScript\" with a public static method named \"Execute\" that returns an object. Example: \"public class McpScript { public static object Execute() { /* your code here */ return result; } }\". You can include any necessary namespaces, additional classes, and methods.",
              "minLength": 1
            }
          },
          "required": [
            "code"
          ]
        },
        "category": "Editor Control",
        "tags": [
          "unity",
          "editor",
          "command",
          "c#"
        ],
        "returns": {
          "type": "object",
          "description": "Returns the execution result, execution time, and status"
        }
      },
      {
        "name": "get_logs",
        "description": "Retrieve Unity Editor logs with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "types": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Log",
                  "Warning",
                  "Error",
                  "Exception"
                ]
              },
              "description": "Filter logs by type"
            },
            "count": {
              "type": "number",
              "description": "Maximum number of log entries to return",
              "minimum": 1,
              "maximum": 1000
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "message",
                  "stackTrace",
                  "logType",
                  "timestamp"
                ]
              },
              "description": "Specify which fields to include in the output"
            },
            "messageContains": {
              "type": "string",
              "description": "Filter logs by message content"
            },
            "stackTraceContains": {
              "type": "string",
              "description": "Filter logs by stack trace content"
            },
            "timestampAfter": {
              "type": "string",
              "description": "Filter logs after this ISO timestamp"
            },
            "timestampBefore": {
              "type": "string",
              "description": "Filter logs before this ISO timestamp"
            }
          }
        },
        "category": "Debugging",
        "tags": [
          "unity",
          "editor",
          "logs",
          "debugging"
        ],
        "returns": {
          "type": "array",
          "description": "Returns an array of log entries matching the specified filters"
        }
      },
      {
        "name": "verify_connection",
        "description": "Verify that the MCP server has an active connection to Unity Editor",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "category": "Connection",
        "tags": [
          "unity",
          "editor",
          "connection"
        ],
        "returns": {
          "type": "object",
          "description": "Returns connection status information"
        }
      },
      {
        "name": "get_editor_state",
        "description": "Get the current Unity Editor state including project information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "category": "Editor State",
        "tags": [
          "unity",
          "editor",
          "project"
        ],
        "returns": {
          "type": "object",
          "description": "Returns detailed information about the current Unity Editor state, project settings, and environment"
        }
      },
      {
        "name": "read_file",
        "description": "Read the contents of a file from the Unity project. Paths are relative to the project's Assets folder. For example, use 'Scenes/MainScene.unity' to read Assets/Scenes/MainScene.unity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to read. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file"
        ]
      },
      {
        "name": "read_multiple_files",
        "description": "Read the contents of multiple files from the Unity project simultaneously.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of file paths to read. Paths can be absolute or relative to Unity project Assets folder."
            }
          },
          "required": [
            "paths"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "batch"
        ]
      },
      {
        "name": "write_file",
        "description": "Create a new file or completely overwrite an existing file in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to write. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            },
            "content": {
              "type": "string",
              "description": "Content to write to the file"
            }
          },
          "required": [
            "path",
            "content"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "write"
        ]
      },
      {
        "name": "edit_file",
        "description": "Make precise edits to a text file in the Unity project. Returns a git-style diff showing changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to edit. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            },
            "edits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "oldText": {
                    "type": "string",
                    "description": "Text to search for - must match exactly"
                  },
                  "newText": {
                    "type": "string",
                    "description": "Text to replace with"
                  }
                },
                "required": [
                  "oldText",
                  "newText"
                ],
                "additionalProperties": false
              },
              "description": "Array of edit operations to apply"
            },
            "dryRun": {
              "type": "boolean",
              "default": false,
              "description": "Preview changes using git-style diff format"
            }
          },
          "required": [
            "path",
            "edits"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "edit"
        ]
      },
      {
        "name": "list_directory",
        "description": "Get a listing of all files and directories in a specified path in the Unity project. Paths are relative to the Assets folder unless absolute. For example, use 'Scenes' to list all files in Assets/Scenes directory. Use empty string to list the Assets folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the directory to list. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Scenes\" will list all files in the Assets/Scenes directory."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "directory",
          "list"
        ]
      },
      {
        "name": "directory_tree",
        "description": "Get a recursive tree view of files and directories in the Unity project as a JSON structure.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the directory to get tree of. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Prefabs\" will show the tree for Assets/Prefabs."
            },
            "maxDepth": {
              "type": "number",
              "default": 5,
              "description": "Maximum depth to traverse"
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "directory",
          "tree"
        ]
      },
      {
        "name": "search_files",
        "description": "Recursively search for files and directories matching a pattern in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to search from. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder. Example: \"Scripts\" will search within Assets/Scripts."
            },
            "pattern": {
              "type": "string",
              "description": "Pattern to search for"
            },
            "excludePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Patterns to exclude"
            }
          },
          "required": [
            "path",
            "pattern"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "search"
        ]
      },
      {
        "name": "get_file_info",
        "description": "Retrieve detailed metadata about a file or directory in the Unity project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Path to the file to get info for. Can be absolute or relative to Unity project Assets folder. If empty, defaults to the Assets folder."
            }
          },
          "required": [
            "path"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "file",
          "metadata"
        ]
      },
      {
        "name": "find_assets_by_type",
        "description": "Find all Unity assets of a specified type (e.g., Material, Prefab, Scene, Script) in the project. Set searchPath to an empty string to search the entire Assets folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetType": {
              "type": "string",
              "description": "Type of assets to find (e.g., \"Material\", \"Prefab\", \"Scene\", \"Script\")"
            },
            "searchPath": {
              "type": "string",
              "default": "",
              "description": "Directory to search in. Can be absolute or relative to Unity project Assets folder. An empty string will search the entire Assets folder."
            },
            "maxDepth": {
              "type": "number",
              "default": 1,
              "description": "Maximum depth to search. 1 means search only in the specified directory, 2 includes immediate subdirectories, and so on. Set to -1 for unlimited depth."
            }
          },
          "required": [
            "assetType"
          ]
        },
        "category": "Filesystem",
        "tags": [
          "unity",
          "filesystem",
          "assets",
          "search"
        ]
      }
    ]
  },
  "playwright": {
    "name": "playwright",
    "display_name": "Playwright",
    "description": "This MCP Server will help you run browser automation and webscraping using Playwright",
    "repository": {
      "type": "git",
      "url": "https://github.com/executeautomation/mcp-playwright"
    },
    "homepage": "https://github.com/executeautomation/mcp-playwright",
    "author": {
      "name": "executeautomation"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "Playwright",
      "Browser Automation"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@executeautomation/playwright-mcp-server"
        ]
      }
    },
    "tools": [
      {
        "name": "start_codegen_session",
        "description": "Start a new code generation session to record Playwright actions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "options": {
              "type": "object",
              "description": "Code generation options",
              "properties": {
                "outputPath": {
                  "type": "string",
                  "description": "Directory path where generated tests will be saved (use absolute path)"
                },
                "testNamePrefix": {
                  "type": "string",
                  "description": "Prefix to use for generated test names (default: 'GeneratedTest')"
                },
                "includeComments": {
                  "type": "boolean",
                  "description": "Whether to include descriptive comments in generated tests"
                }
              },
              "required": [
                "outputPath"
              ]
            }
          },
          "required": [
            "options"
          ]
        }
      },
      {
        "name": "end_codegen_session",
        "description": "End a code generation session and generate the test file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to end"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "get_codegen_session",
        "description": "Get information about a code generation session",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to retrieve"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "clear_codegen_session",
        "description": "Clear a code generation session without generating a test",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "ID of the session to clear"
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "playwright_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to navigate to the website specified"
            },
            "browserType": {
              "type": "string",
              "description": "Browser type to use (chromium, firefox, webkit). Defaults to chromium",
              "enum": [
                "chromium",
                "firefox",
                "webkit"
              ]
            },
            "width": {
              "type": "number",
              "description": "Viewport width in pixels (default: 1280)"
            },
            "height": {
              "type": "number",
              "description": "Viewport height in pixels (default: 720)"
            },
            "timeout": {
              "type": "number",
              "description": "Navigation timeout in milliseconds"
            },
            "waitUntil": {
              "type": "string",
              "description": "Navigation wait condition"
            },
            "headless": {
              "type": "boolean",
              "description": "Run browser in headless mode (default: false)"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_screenshot",
        "description": "Take a screenshot of the current page or a specific element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the screenshot"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for element to screenshot"
            },
            "width": {
              "type": "number",
              "description": "Width in pixels (default: 800)"
            },
            "height": {
              "type": "number",
              "description": "Height in pixels (default: 600)"
            },
            "storeBase64": {
              "type": "boolean",
              "description": "Store screenshot in base64 format (default: true)"
            },
            "fullPage": {
              "type": "boolean",
              "description": "Store screenshot of the entire page (default: false)"
            },
            "savePng": {
              "type": "boolean",
              "description": "Save screenshot as PNG file (default: false)"
            },
            "downloadsDir": {
              "type": "string",
              "description": "Custom downloads directory path (default: user's Downloads folder)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "playwright_click",
        "description": "Click an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to click"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "playwright_iframe_click",
        "description": "Click an element in an iframe on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "iframeSelector": {
              "type": "string",
              "description": "CSS selector for the iframe containing the element to click"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to click"
            }
          },
          "required": [
            "iframeSelector",
            "selector"
          ]
        }
      },
      {
        "name": "playwright_fill",
        "description": "fill out an input field",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for input field"
            },
            "value": {
              "type": "string",
              "description": "Value to fill"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "playwright_select",
        "description": "Select an element on the page with Select tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to select"
            },
            "value": {
              "type": "string",
              "description": "Value to select"
            }
          },
          "required": [
            "selector",
            "value"
          ]
        }
      },
      {
        "name": "playwright_hover",
        "description": "Hover an element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for element to hover"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "playwright_evaluate",
        "description": "Execute JavaScript in the browser console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "script": {
              "type": "string",
              "description": "JavaScript code to execute"
            }
          },
          "required": [
            "script"
          ]
        }
      },
      {
        "name": "playwright_console_logs",
        "description": "Retrieve console logs from the browser with filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Type of logs to retrieve (all, error, warning, log, info, debug)",
              "enum": [
                "all",
                "error",
                "warning",
                "log",
                "info",
                "debug"
              ]
            },
            "search": {
              "type": "string",
              "description": "Text to search for in logs (handles text with square brackets)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of logs to return"
            },
            "clear": {
              "type": "boolean",
              "description": "Whether to clear logs after retrieval (default: false)"
            }
          },
          "required": []
        }
      },
      {
        "name": "playwright_close",
        "description": "Close the browser and release all resources",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_get",
        "description": "Perform an HTTP GET request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform GET operation"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_post",
        "description": "Perform an HTTP POST request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform POST operation"
            },
            "value": {
              "type": "string",
              "description": "Data to post in the body"
            },
            "token": {
              "type": "string",
              "description": "Bearer token for authorization"
            },
            "headers": {
              "type": "object",
              "description": "Additional headers to include in the request",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_put",
        "description": "Perform an HTTP PUT request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform PUT operation"
            },
            "value": {
              "type": "string",
              "description": "Data to PUT in the body"
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_patch",
        "description": "Perform an HTTP PATCH request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform PUT operation"
            },
            "value": {
              "type": "string",
              "description": "Data to PATCH in the body"
            }
          },
          "required": [
            "url",
            "value"
          ]
        }
      },
      {
        "name": "playwright_delete",
        "description": "Perform an HTTP DELETE request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to perform DELETE operation"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "playwright_expect_response",
        "description": "Ask Playwright to start waiting for a HTTP response. This tool initiates the wait operation but does not wait for its completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique & arbitrary identifier to be used for retrieving this response later with `Playwright_assert_response`."
            },
            "url": {
              "type": "string",
              "description": "URL pattern to match in the response."
            }
          },
          "required": [
            "id",
            "url"
          ]
        }
      },
      {
        "name": "playwright_assert_response",
        "description": "Wait for and validate a previously initiated HTTP response wait operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Identifier of the HTTP response initially expected using `Playwright_expect_response`."
            },
            "value": {
              "type": "string",
              "description": "Data to expect in the body of the HTTP response. If provided, the assertion will fail if this value is not found in the response body."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "playwright_custom_user_agent",
        "description": "Set a custom User Agent for the browser",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userAgent": {
              "type": "string",
              "description": "Custom User Agent for the Playwright browser instance"
            }
          },
          "required": [
            "userAgent"
          ]
        }
      },
      {
        "name": "playwright_get_visible_text",
        "description": "Get the visible text content of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_get_visible_html",
        "description": "Get the HTML content of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_go_back",
        "description": "Navigate back in browser history",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_go_forward",
        "description": "Navigate forward in browser history",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "playwright_drag",
        "description": "Drag an element to a target location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sourceSelector": {
              "type": "string",
              "description": "CSS selector for the element to drag"
            },
            "targetSelector": {
              "type": "string",
              "description": "CSS selector for the target location"
            }
          },
          "required": [
            "sourceSelector",
            "targetSelector"
          ]
        }
      },
      {
        "name": "playwright_press_key",
        "description": "Press a keyboard key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Key to press (e.g. 'Enter', 'ArrowDown', 'a')"
            },
            "selector": {
              "type": "string",
              "description": "Optional CSS selector to focus before pressing key"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "playwright_save_as_pdf",
        "description": "Save the current page as a PDF file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "outputPath": {
              "type": "string",
              "description": "Directory path where PDF will be saved"
            },
            "filename": {
              "type": "string",
              "description": "Name of the PDF file (default: page.pdf)"
            },
            "format": {
              "type": "string",
              "description": "Page format (e.g. 'A4', 'Letter')"
            },
            "printBackground": {
              "type": "boolean",
              "description": "Whether to print background graphics"
            },
            "margin": {
              "type": "object",
              "description": "Page margins",
              "properties": {
                "top": {
                  "type": "string"
                },
                "right": {
                  "type": "string"
                },
                "bottom": {
                  "type": "string"
                },
                "left": {
                  "type": "string"
                }
              }
            }
          },
          "required": [
            "outputPath"
          ]
        }
      }
    ]
  },
  "productboard": {
    "name": "productboard",
    "display_name": "Productboard",
    "description": "Integrate the Productboard API into agentic workflows via MCP.",
    "repository": {
      "type": "git",
      "url": "https://github.com/kenjihikmatullah/productboard-mcp"
    },
    "author": {
      "name": "kenjihikmatullah"
    },
    "license": "MIT",
    "categories": [
      "Productivity"
    ],
    "tags": [
      "Productboard",
      "API"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "productboard-mcp"
        ],
        "env": {
          "PRODUCTBOARD_ACCESS_TOKEN": "<YOUR_TOKEN>"
        }
      }
    },
    "homepage": "https://github.com/kenjihikmatullah/productboard-mcp",
    "arguments": {
      "PRODUCTBOARD_ACCESS_TOKEN": {
        "description": "An access token needed to authenticate with the Productboard API. This token is required to make requests to the API and must be kept confidential.",
        "required": true,
        "example": "your_access_token_here"
      }
    },
    "tools": [
      {
        "name": "get_products",
        "description": "Returns detail of all products. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_product_detail",
        "description": "Returns detailed information about a specific product",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string",
              "description": "ID of the product to retrieve"
            }
          },
          "required": [
            "productId"
          ]
        }
      },
      {
        "name": "get_features",
        "description": "Returns a list of all features. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_feature_detail",
        "description": "Returns detailed information about a specific feature",
        "inputSchema": {
          "type": "object",
          "properties": {
            "featureId": {
              "type": "string",
              "description": "ID of the feature to retrieve"
            }
          },
          "required": [
            "featureId"
          ]
        }
      },
      {
        "name": "get_components",
        "description": "Returns a list of all components. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_component_detail",
        "description": "Returns detailed information about a specific component",
        "inputSchema": {
          "type": "object",
          "properties": {
            "componentId": {
              "type": "string",
              "description": "ID of the component to retrieve"
            }
          },
          "required": [
            "componentId"
          ]
        }
      },
      {
        "name": "get_feature_statuses",
        "description": "Returns a list of all feature statuses. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_notes",
        "description": "Returns a list of all notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "last": {
              "type": "string",
              "description": "Return only notes created since given span of months (m), days (s), or hours (h). E.g. 6m | 10d | 24h | 1h. Cannot be combined with createdFrom, createdTo, dateFrom, or dateTo"
            },
            "createdFrom": {
              "type": "string",
              "format": "date",
              "description": "Return only notes created since given date. Cannot be combined with last"
            },
            "createdTo": {
              "type": "string",
              "format": "date",
              "description": "Return only notes created before or equal to the given date. Cannot be combined with last"
            },
            "updatedFrom": {
              "type": "string",
              "format": "date",
              "description": "Return only notes updated since given date"
            },
            "updatedTo": {
              "type": "string",
              "format": "date",
              "description": "Return only notes updated before or equal to the given date"
            },
            "term": {
              "type": "string",
              "description": "Return only notes by fulltext search"
            },
            "featureId": {
              "type": "string",
              "description": "Return only notes for specific feature ID or its descendants"
            },
            "companyId": {
              "type": "string",
              "description": "Return only notes for specific company ID"
            },
            "ownerEmail": {
              "type": "string",
              "description": "Return only notes owned by a specific owner email"
            },
            "source": {
              "type": "string",
              "description": "Return only notes from a specific source origin. This is the unique string identifying the external system from which the data came"
            },
            "anyTag": {
              "type": "string",
              "description": "Return only notes that have been assigned any of the tags in the array. Cannot be combined with allTags"
            },
            "allTags": {
              "type": "string",
              "description": "Return only notes that have been assigned all of the tags in the array. Cannot be combined with anyTag"
            },
            "pageLimit": {
              "type": "number",
              "description": "Page limit"
            },
            "pageCursor": {
              "type": "string",
              "description": "Page cursor to get next page of results"
            }
          }
        }
      },
      {
        "name": "get_note_detail",
        "description": "Returns detailed information about a specific note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "ID of the note to retrieve"
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "get_companies",
        "description": "Returns a list of all companies. This API is paginated and the page limit is always 100",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1
            }
          }
        }
      },
      {
        "name": "get_company_detail",
        "description": "Returns detailed information about a specific company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companyId": {
              "type": "string",
              "description": "ID of the company to retrieve"
            }
          },
          "required": [
            "companyId"
          ]
        }
      }
    ]
  },
  "qwen-max": {
    "name": "qwen-max",
    "display_name": "Qwen Max",
    "description": "A Model Context Protocol (MCP) server implementation for the Qwen models.",
    "repository": {
      "type": "git",
      "url": "https://github.com/66julienmartin/MCP-server-Qwen_Max"
    },
    "homepage": "https://github.com/66julienmartin/MCP-server-Qwen_Max",
    "author": {
      "name": "66julienmartin"
    },
    "license": "MIT",
    "categories": [
      "AI Systems"
    ],
    "tags": [
      "Qwen Max",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@gongrzhe/quickchart-mcp-server"
        ]
      }
    },
    "arguments": {
      "DASHSCOPE_API_KEY": {
        "description": "API key required for authentication with the Dashscope service.",
        "required": true,
        "example": "your-api-key-here"
      }
    },
    "tools": [
      {
        "name": "generate_chart",
        "description": "Generate a chart using QuickChart",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Chart type (bar, line, pie, doughnut, radar, polarArea, scatter, bubble, radialGauge, speedometer)"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels for data points"
            },
            "datasets": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "data": {
                    "type": "array"
                  },
                  "backgroundColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "borderColor": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "additionalConfig": {
                    "type": "object"
                  }
                },
                "required": [
                  "data"
                ]
              }
            },
            "title": {
              "type": "string"
            },
            "options": {
              "type": "object"
            }
          },
          "required": [
            "type",
            "datasets"
          ]
        }
      },
      {
        "name": "download_chart",
        "description": "Download a chart image to a local file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "config": {
              "type": "object",
              "description": "Chart configuration object"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the chart image should be saved"
            }
          },
          "required": [
            "config",
            "outputPath"
          ]
        }
      }
    ]
  },
  "fetch": {
    "name": "fetch",
    "display_name": "Fetch",
    "description": "A server that flexibly fetches HTML, JSON, Markdown, or plaintext.",
    "repository": {
      "type": "git",
      "url": "https://github.com/zcaceres/fetch-mcp"
    },
    "homepage": "https://github.com/zcaceres/fetch-mcp",
    "author": {
      "name": "zcaceres"
    },
    "license": "MIT",
    "categories": [
      "Web Services"
    ],
    "tags": [
      "fetch",
      "web",
      "api",
      "html",
      "json",
      "markdown",
      "plain text"
    ],
    "examples": [
      {
        "title": "Fetch HTML",
        "description": "Fetch a website and return the content as HTML",
        "prompt": "fetch_html(url: string, headers?: object) -> string"
      },
      {
        "title": "Fetch JSON",
        "description": "Fetch a JSON file from a URL",
        "prompt": "fetch_json(url: string, headers?: object) -> object"
      },
      {
        "title": "Fetch Plain Text",
        "description": "Fetch a website and return the content as plain text",
        "prompt": "fetch_txt(url: string, headers?: object) -> string"
      },
      {
        "title": "Fetch Markdown",
        "description": "Fetch a website and return the content as Markdown",
        "prompt": "fetch_markdown(url: string, headers?: object) -> string"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/zcaceres/fetch-mcp"
        ]
      }
    },
    "arguments": {
      "url": {
        "description": "URL of the website to fetch",
        "required": true,
        "example": "https://example.com"
      },
      "headers": {
        "description": "Custom headers to include in the request",
        "required": false,
        "example": "{\"Authorization\": \"Bearer token\"}"
      }
    },
    "tools": [
      {
        "name": "fetch_html",
        "description": "Fetch a website and return the content as HTML",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_markdown",
        "description": "Fetch a website and return the content as Markdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_txt",
        "description": "Fetch a website, return the content as plain text (no HTML)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_json",
        "description": "Fetch a JSON file from a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the JSON to fetch"
            },
            "headers": {
              "type": "object",
              "description": "Optional headers to include in the request"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  "inoyu": {
    "name": "inoyu",
    "display_name": "Inoyu Apache Unomi",
    "description": "Interact with an Apache Unomi CDP customer data platform to retrieve and update customer profiles",
    "repository": {
      "type": "git",
      "url": "https://github.com/sergehuber/inoyu-mcp-unomi-server"
    },
    "homepage": "https://github.com/sergehuber/inoyu-mcp-unomi-server",
    "author": {
      "name": "sergehuber"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Apache Unomi",
      "User Profiles",
      "Context Management"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "@inoyu/mcp-unomi-server"
        ],
        "env": {
          "UNOMI_BASE_URL": "${UNOMI_BASE_URL}",
          "UNOMI_USERNAME": "${UNOMI_USERNAME}",
          "UNOMI_PASSWORD": "${UNOMI_PASSWORD}",
          "UNOMI_PROFILE_ID": "${UNOMI_PROFILE_ID}",
          "UNOMI_KEY": "${UNOMI_KEY}",
          "UNOMI_EMAIL": "${UNOMI_EMAIL}",
          "UNOMI_SOURCE_ID": "${UNOMI_SOURCE_ID}"
        }
      }
    },
    "arguments": {
      "UNOMI_BASE_URL": {
        "description": "The base URL of your Apache Unomi server (e.g., http://your-unomi-server:8181)",
        "required": true
      },
      "UNOMI_USERNAME": {
        "description": "The username to authenticate with the Apache Unomi server, default is 'karaf'",
        "required": true
      },
      "UNOMI_PASSWORD": {
        "description": "The password to authenticate with the Apache Unomi server, default is 'karaf'",
        "required": true
      },
      "UNOMI_PROFILE_ID": {
        "description": "The ID of the user profile to be used for context management",
        "required": false
      },
      "UNOMI_KEY": {
        "description": "The authorization key required for secured operations with the Unomi server, defaults to '670c26d1cc413346c3b2fd9ce65dab41'",
        "required": false
      },
      "UNOMI_EMAIL": {
        "description": "The email address associated with the user profile, used for profile lookup",
        "required": false
      },
      "UNOMI_SOURCE_ID": {
        "description": "An identifier for the source of the request (e.g., claude-desktop)",
        "required": false
      }
    },
    "tools": [
      {
        "name": "get_my_profile",
        "description": "Get your profile using environment variables.",
        "inputSchema": {
          "requireSegments": {
            "type": "boolean",
            "description": "Include segment information",
            "optional": true
          },
          "requireScores": {
            "type": "boolean",
            "description": "Include scoring information",
            "optional": true
          }
        },
        "required": []
      },
      {
        "name": "update_my_profile",
        "description": "Update properties of your profile.",
        "inputSchema": {
          "properties": {
            "type": "object",
            "description": "Properties to update"
          }
        },
        "required": [
          "properties"
        ]
      },
      {
        "name": "get_profile",
        "description": "Retrieve a specific profile by ID.",
        "inputSchema": {
          "profileId": {
            "type": "string",
            "description": "ID of the profile to retrieve"
          }
        },
        "required": [
          "profileId"
        ]
      },
      {
        "name": "search_profiles",
        "description": "Search for profiles.",
        "inputSchema": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of results to return",
            "optional": true
          },
          "offset": {
            "type": "integer",
            "description": "Pagination offset",
            "optional": true
          }
        },
        "required": [
          "query"
        ]
      },
      {
        "name": "create_scope",
        "description": "Create a new Unomi scope.",
        "inputSchema": {
          "scope": {
            "type": "string",
            "description": "Identifier for the scope"
          },
          "name": {
            "type": "string",
            "description": "Name of the scope",
            "optional": true
          },
          "description": {
            "type": "string",
            "description": "Description of the scope",
            "optional": true
          }
        },
        "required": [
          "scope"
        ]
      }
    ]
  },
  "everything": {
    "name": "everything",
    "display_name": "Everything",
    "description": "This MCP server exercises all the features of the MCP protocol. It is a test server for builders of MCP clients.",
    "repository": {
      "type": "git",
      "url": "https://github.com/modelcontextprotocol/servers"
    },
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/everything#readme",
    "author": {
      "name": "MCP Team"
    },
    "license": "MIT",
    "categories": [
      "MCP Tools"
    ],
    "tags": [
      "testing",
      "reference",
      "example",
      "demo"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "@modelcontextprotocol/server-everything"
        ],
        "package": "@modelcontextprotocol/server-everything",
        "env": {},
        "description": "Install and run using NPX",
        "recommended": true
      }
    },
    "examples": [
      {
        "title": "Test tool usage",
        "description": "Test various tools provided by the server",
        "prompt": "Show me how to use the different tools in this MCP server."
      },
      {
        "title": "Test resources",
        "description": "Demonstrate accessing resources",
        "prompt": "Demonstrate how to access and use resources from this MCP server."
      }
    ],
    "tools": [
      {
        "name": "echo",
        "description": "Echoes back the input",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Message to echo"
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "add",
        "description": "Adds two numbers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": {
              "type": "number",
              "description": "First number"
            },
            "b": {
              "type": "number",
              "description": "Second number"
            }
          },
          "required": [
            "a",
            "b"
          ]
        }
      },
      {
        "name": "printEnv",
        "description": "Prints all environment variables, helpful for debugging MCP server configuration",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "longRunningOperation",
        "description": "Demonstrates a long running operation with progress updates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "duration": {
              "type": "number",
              "default": 10,
              "description": "Duration of the operation in seconds"
            },
            "steps": {
              "type": "number",
              "default": 5,
              "description": "Number of steps in the operation"
            }
          }
        }
      },
      {
        "name": "sampleLLM",
        "description": "Samples from an LLM using MCP's sampling feature",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "The prompt to send to the LLM"
            },
            "maxTokens": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of tokens to generate"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "getTinyImage",
        "description": "Returns the MCP_TINY_IMAGE",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "annotatedMessage",
        "description": "Demonstrates how annotations can be used to provide metadata about content",
        "inputSchema": {
          "type": "object",
          "properties": {
            "messageType": {
              "type": "string",
              "enum": [
                "error",
                "success",
                "debug"
              ],
              "description": "Type of message to demonstrate different annotation patterns"
            },
            "includeImage": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include an example image"
            }
          },
          "required": [
            "messageType"
          ]
        }
      }
    ]
  },
  "godot": {
    "name": "godot",
    "display_name": "Godot",
    "description": "A MCP server providing comprehensive Godot engine integration for project editing, debugging, and scene management.",
    "repository": {
      "type": "git",
      "url": "https://github.com/Coding-Solo/godot-mcp"
    },
    "homepage": "https://github.com/Coding-Solo/godot-mcp",
    "author": {
      "name": "Coding Solo",
      "url": "https://github.com/Coding-Solo"
    },
    "license": "MIT",
    "categories": [
      "Media Creation"
    ],
    "tags": [
      "Godot",
      "AI",
      "Game"
    ],
    "examples": [
      {
        "title": "Launch Godot Editor",
        "description": "Launch the Godot editor for a specific project.",
        "prompt": "Launch the Godot editor for my project at /path/to/project"
      },
      {
        "title": "Run Godot Project",
        "description": "Execute Godot projects in debug mode.",
        "prompt": "Run my Godot project and show me any errors"
      },
      {
        "title": "Get Project Info",
        "description": "Retrieve detailed information about the project structure.",
        "prompt": "Get information about my Godot project structure"
      },
      {
        "title": "Debug Assistance",
        "description": "Help debug errors in Godot projects.",
        "prompt": "Help me debug this error in my Godot project: [paste error]"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/Coding-Solo/godot-mcp"
        ]
      }
    },
    "tools": [
      {
        "name": "launch_editor",
        "description": "Launch Godot editor for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "run_project",
        "description": "Run the Godot project and capture output",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scene": {
              "type": "string",
              "description": "Optional: Specific scene to run"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "get_debug_output",
        "description": "Get the current debug output and errors",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "stop_project",
        "description": "Stop the currently running Godot project",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_godot_version",
        "description": "Get the installed Godot version",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_projects",
        "description": "List Godot projects in a directory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directory": {
              "type": "string",
              "description": "Directory to search for Godot projects"
            },
            "recursive": {
              "type": "boolean",
              "description": "Whether to search recursively (default: false)"
            }
          },
          "required": [
            "directory"
          ]
        }
      },
      {
        "name": "get_project_info",
        "description": "Retrieve metadata about a Godot project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      },
      {
        "name": "create_scene",
        "description": "Create a new Godot scene file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path where the scene file will be saved (relative to project)"
            },
            "rootNodeType": {
              "type": "string",
              "description": "Type of the root node (e.g., Node2D, Node3D)",
              "default": "Node2D"
            }
          },
          "required": [
            "projectPath",
            "scenePath"
          ]
        }
      },
      {
        "name": "add_node",
        "description": "Add a node to an existing scene",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "parentNodePath": {
              "type": "string",
              "description": "Path to the parent node (e.g., \"root\" or \"root/Player\")",
              "default": "root"
            },
            "nodeType": {
              "type": "string",
              "description": "Type of node to add (e.g., Sprite2D, CollisionShape2D)"
            },
            "nodeName": {
              "type": "string",
              "description": "Name for the new node"
            },
            "properties": {
              "type": "object",
              "description": "Optional properties to set on the node"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "nodeType",
            "nodeName"
          ]
        }
      },
      {
        "name": "load_sprite",
        "description": "Load a sprite into a Sprite2D node",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "nodePath": {
              "type": "string",
              "description": "Path to the Sprite2D node (e.g., \"root/Player/Sprite2D\")"
            },
            "texturePath": {
              "type": "string",
              "description": "Path to the texture file (relative to project)"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "nodePath",
            "texturePath"
          ]
        }
      },
      {
        "name": "export_mesh_library",
        "description": "Export a scene as a MeshLibrary resource",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (.tscn) to export"
            },
            "outputPath": {
              "type": "string",
              "description": "Path where the mesh library (.res) will be saved"
            },
            "meshItemNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Names of specific mesh items to include (defaults to all)"
            }
          },
          "required": [
            "projectPath",
            "scenePath",
            "outputPath"
          ]
        }
      },
      {
        "name": "save_scene",
        "description": "Save changes to a scene file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "scenePath": {
              "type": "string",
              "description": "Path to the scene file (relative to project)"
            },
            "newPath": {
              "type": "string",
              "description": "Optional: New path to save the scene to (for creating variants)"
            }
          },
          "required": [
            "projectPath",
            "scenePath"
          ]
        }
      },
      {
        "name": "get_uid",
        "description": "Get the UID for a specific file in a Godot project (for Godot 4.4+)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            },
            "filePath": {
              "type": "string",
              "description": "Path to the file (relative to project) for which to get the UID"
            }
          },
          "required": [
            "projectPath",
            "filePath"
          ]
        }
      },
      {
        "name": "update_project_uids",
        "description": "Update UID references in a Godot project by resaving resources (for Godot 4.4+)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectPath": {
              "type": "string",
              "description": "Path to the Godot project directory"
            }
          },
          "required": [
            "projectPath"
          ]
        }
      }
    ]
  },
  "aws": {
    "name": "aws",
    "display_name": "AWS",
    "description": "Perform operations on your AWS resources using an LLM.",
    "repository": {
      "type": "git",
      "url": "https://github.com/rishikavikondala/mcp-server-aws"
    },
    "homepage": "https://github.com/rishikavikondala/mcp-server-aws",
    "author": {
      "name": "rishikavikondala"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "s3",
      "dynamodb",
      "aws"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/rishikavikondala/mcp-server-aws",
          "mcp-server-aws"
        ]
      }
    },
    "arguments": {
      "AWS_ACCESS_KEY_ID": {
        "description": "This is the access key ID for your AWS account, required for authenticating requests to AWS services.",
        "required": true,
        "example": "AKIAEXAMPLE"
      },
      "AWS_SECRET_ACCESS_KEY": {
        "description": "This is the secret access key for your AWS account, used in conjunction with the access key ID to authenticate requests.",
        "required": true,
        "example": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
      },
      "AWS_REGION": {
        "description": "This specifies the AWS region you want to use for your operations. It defaults to `us-east-1` if not provided.",
        "required": false,
        "example": "us-west-2"
      }
    },
    "tools": [
      {
        "name": "s3_bucket_create",
        "description": "Create a new S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket to create"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_bucket_list",
        "description": "List all S3 buckets",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "s3_bucket_delete",
        "description": "Delete an S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket to delete"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_object_upload",
        "description": "Upload an object to S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object in the bucket"
            },
            "file_content": {
              "type": "string",
              "description": "Base64 encoded file content for upload"
            }
          },
          "required": [
            "bucket_name",
            "object_key",
            "file_content"
          ]
        }
      },
      {
        "name": "s3_object_delete",
        "description": "Delete an object from S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object to delete"
            }
          },
          "required": [
            "bucket_name",
            "object_key"
          ]
        }
      },
      {
        "name": "s3_object_list",
        "description": "List objects in an S3 bucket",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            }
          },
          "required": [
            "bucket_name"
          ]
        }
      },
      {
        "name": "s3_object_read",
        "description": "Read an object's content from S3",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bucket_name": {
              "type": "string",
              "description": "Name of the S3 bucket"
            },
            "object_key": {
              "type": "string",
              "description": "Key/path of the object to read"
            }
          },
          "required": [
            "bucket_name",
            "object_key"
          ]
        }
      },
      {
        "name": "dynamodb_table_create",
        "description": "Create a new DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key_schema": {
              "type": "array",
              "description": "Key schema for table creation"
            },
            "attribute_definitions": {
              "type": "array",
              "description": "Attribute definitions for table creation"
            }
          },
          "required": [
            "table_name",
            "key_schema",
            "attribute_definitions"
          ]
        }
      },
      {
        "name": "dynamodb_table_describe",
        "description": "Get details about a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_table_list",
        "description": "List all DynamoDB tables",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "dynamodb_table_delete",
        "description": "Delete a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_table_update",
        "description": "Update a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "attribute_definitions": {
              "type": "array",
              "description": "Updated attribute definitions"
            }
          },
          "required": [
            "table_name",
            "attribute_definitions"
          ]
        }
      },
      {
        "name": "dynamodb_item_put",
        "description": "Put an item into a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "item": {
              "type": "object",
              "description": "Item data to put"
            }
          },
          "required": [
            "table_name",
            "item"
          ]
        }
      },
      {
        "name": "dynamodb_item_get",
        "description": "Get an item from a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            }
          },
          "required": [
            "table_name",
            "key"
          ]
        }
      },
      {
        "name": "dynamodb_item_update",
        "description": "Update an item in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            },
            "item": {
              "type": "object",
              "description": "Updated item data"
            }
          },
          "required": [
            "table_name",
            "key",
            "item"
          ]
        }
      },
      {
        "name": "dynamodb_item_delete",
        "description": "Delete an item from a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key": {
              "type": "object",
              "description": "Key to identify the item"
            }
          },
          "required": [
            "table_name",
            "key"
          ]
        }
      },
      {
        "name": "dynamodb_item_query",
        "description": "Query items in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "key_condition": {
              "type": "string",
              "description": "Key condition expression"
            },
            "expression_values": {
              "type": "object",
              "description": "Expression attribute values"
            }
          },
          "required": [
            "table_name",
            "key_condition",
            "expression_values"
          ]
        }
      },
      {
        "name": "dynamodb_item_scan",
        "description": "Scan items in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "filter_expression": {
              "type": "string",
              "description": "Filter expression"
            },
            "expression_attributes": {
              "type": "object",
              "properties": {
                "values": {
                  "type": "object",
                  "description": "Expression attribute values"
                },
                "names": {
                  "type": "object",
                  "description": "Expression attribute names"
                }
              }
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_batch_get",
        "description": "Batch get multiple items from DynamoDB tables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "request_items": {
              "type": "object",
              "description": "Map of table names to keys to retrieve",
              "additionalProperties": {
                "type": "object",
                "properties": {
                  "Keys": {
                    "type": "array",
                    "items": {
                      "type": "object"
                    }
                  },
                  "ConsistentRead": {
                    "type": "boolean"
                  },
                  "ProjectionExpression": {
                    "type": "string"
                  }
                },
                "required": [
                  "Keys"
                ]
              }
            }
          },
          "required": [
            "request_items"
          ]
        }
      },
      {
        "name": "dynamodb_item_batch_write",
        "description": "Batch write operations (put/delete) for DynamoDB items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "operation": {
              "type": "string",
              "enum": [
                "put",
                "delete"
              ],
              "description": "Type of batch operation (put or delete)"
            },
            "items": {
              "type": "array",
              "description": "Array of items to process"
            },
            "key_attributes": {
              "type": "array",
              "description": "For delete operations, specify which attributes form the key",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "table_name",
            "operation",
            "items"
          ]
        }
      },
      {
        "name": "dynamodb_describe_ttl",
        "description": "Get the TTL settings for a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            }
          },
          "required": [
            "table_name"
          ]
        }
      },
      {
        "name": "dynamodb_update_ttl",
        "description": "Update the TTL settings for a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "type": "string",
              "description": "Name of the DynamoDB table"
            },
            "ttl_enabled": {
              "type": "boolean",
              "description": "Whether TTL should be enabled"
            },
            "ttl_attribute": {
              "type": "string",
              "description": "The attribute name to use for TTL"
            }
          },
          "required": [
            "table_name",
            "ttl_enabled",
            "ttl_attribute"
          ]
        }
      },
      {
        "name": "dynamodb_batch_execute",
        "description": "Execute multiple PartiQL statements in a batch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "statements": {
              "type": "array",
              "description": "List of PartiQL statements to execute",
              "items": {
                "type": "string"
              }
            },
            "parameters": {
              "type": "array",
              "description": "List of parameter lists for each statement",
              "items": {
                "type": "array"
              }
            }
          },
          "required": [
            "statements",
            "parameters"
          ]
        }
      }
    ]
  },
  "github-actions": {
    "name": "github-actions",
    "display_name": "GitHub Actions",
    "description": "A Model Context Protocol (MCP) server for interacting with Github Actions.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ko1ynnky/github-actions-mcp-server"
    },
    "homepage": "https://github.com/ko1ynnky/github-actions-mcp-server",
    "author": {
      "name": "ko1ynnky"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "GitHub Actions",
      "Workflow Management",
      "Automation"
    ],
    "examples": [
      {
        "title": "List Workflows",
        "description": "List workflows in a GitHub repository.",
        "prompt": "const result = await listWorkflows({ owner: 'your-username', repo: 'your-repository' });"
      },
      {
        "title": "Trigger Workflow",
        "description": "Trigger a workflow in a GitHub repository.",
        "prompt": "const result = await triggerWorkflow({ owner: 'your-username', repo: 'your-repository', workflowId: 'ci.yml', ref: 'main', inputs: { environment: 'production' }});"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/ko1ynnky/github-actions-mcp-server"
        ],
        "env": {
          "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_PERSONAL_ACCESS_TOKEN}"
        }
      }
    },
    "arguments": {
      "GITHUB_PERSONAL_ACCESS_TOKEN": {
        "description": "A personal access token required for authentication with GitHub API, used to access user repositories and perform actions.",
        "required": true,
        "example": "ghp_16CharTokenHere"
      }
    }
  },
  "docker": {
    "name": "docker",
    "display_name": "Docker Integration",
    "description": "Integrate with Docker to manage containers, images, volumes, and networks.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ckreiling/mcp-server-docker"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Deploy an nginx container",
        "description": "Deploy an nginx container exposing it on port 9000",
        "prompt": "name: `nginx`, containers: \"deploy an nginx container exposing it on port 9000\""
      },
      {
        "title": "Deploy a WordPress and MySQL container",
        "description": "Deploy a WordPress container and a supporting MySQL container, exposing WordPress on port 9000",
        "prompt": "name: `wordpress`, containers: \"deploy a WordPress container and a supporting MySQL container, exposing Wordpress on port 9000\""
      }
    ],
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Docker",
      "Container",
      "Image",
      "Volume",
      "Network"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ckreiling/mcp-server-docker",
          "mcp-server-docker"
        ]
      }
    },
    "tools": [
      {
        "name": "list_containers",
        "description": "List all Docker containers",
        "inputSchema": {
          "$defs": {
            "ListContainersFilters": {
              "properties": {
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListContainersFilters",
              "type": "object"
            }
          },
          "properties": {
            "all": {
              "default": false,
              "description": "Show all containers (default shows just running)",
              "title": "All",
              "type": "boolean"
            },
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListContainersFilters"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter containers"
            }
          },
          "title": "ListContainersInput",
          "type": "object"
        }
      },
      {
        "name": "create_container",
        "description": "Create a new Docker container",
        "inputSchema": {
          "description": "Schema for creating a new container.\n\nThis is passed to the Python Docker SDK directly, so the fields are the same\nas the `docker.containers.create` method.",
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "CreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "run_container",
        "description": "Run an image in a new Docker container",
        "inputSchema": {
          "description": "Schema for creating a new container.\n\nThis is passed to the Python Docker SDK directly, so the fields are the same\nas the `docker.containers.create` method.",
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "CreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "recreate_container",
        "description": "Stop and remove a container, then run a new container. Fails if the container does not exist.",
        "inputSchema": {
          "properties": {
            "detach": {
              "default": true,
              "description": "Run container in the background. Should be True for long-running containers, can be false for short-lived containers",
              "title": "Detach",
              "type": "boolean"
            },
            "image": {
              "description": "Docker image name",
              "title": "Image",
              "type": "string"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container name",
              "title": "Name"
            },
            "entrypoint": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Entrypoint to run in container",
              "title": "Entrypoint"
            },
            "command": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Command to run in container",
              "title": "Command"
            },
            "network": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network to attach the container to",
              "title": "Network"
            },
            "environment": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Environment variables dictionary",
              "title": "Environment"
            },
            "ports": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "items": {
                          "type": "integer"
                        },
                        "type": "array"
                      },
                      {
                        "maxItems": 2,
                        "minItems": 2,
                        "prefixItems": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "integer"
                          }
                        ],
                        "type": "array"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Mapping of container_port to host_port",
              "title": "Ports"
            },
            "volumes": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "type": "object"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume mappings",
              "title": "Volumes"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container labels, either as a dictionary or a list of key=value strings",
              "title": "Labels"
            },
            "auto_remove": {
              "default": false,
              "description": "Automatically remove the container",
              "title": "Auto Remove",
              "type": "boolean"
            },
            "container_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Container ID to recreate. The `name` parameter will be used if this is not provided",
              "title": "Container Id"
            }
          },
          "required": [
            "image"
          ],
          "title": "RecreateContainerInput",
          "type": "object"
        }
      },
      {
        "name": "start_container",
        "description": "Start a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "ContainerActionInput",
          "type": "object"
        }
      },
      {
        "name": "fetch_container_logs",
        "description": "Fetch logs for a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            },
            "tail": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "const": "all",
                  "type": "string"
                }
              ],
              "default": 100,
              "description": "Number of lines to show from the end",
              "title": "Tail"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "FetchContainerLogsInput",
          "type": "object"
        }
      },
      {
        "name": "stop_container",
        "description": "Stop a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "ContainerActionInput",
          "type": "object"
        }
      },
      {
        "name": "remove_container",
        "description": "Remove a Docker container",
        "inputSchema": {
          "properties": {
            "container_id": {
              "description": "Container ID or name",
              "title": "Container Id",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the container",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "container_id"
          ],
          "title": "RemoveContainerInput",
          "type": "object"
        }
      },
      {
        "name": "list_images",
        "description": "List Docker images",
        "inputSchema": {
          "$defs": {
            "ListImagesFilters": {
              "properties": {
                "dangling": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Show dangling images",
                  "title": "Dangling"
                },
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListImagesFilters",
              "type": "object"
            }
          },
          "properties": {
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter images by repository name, if desired",
              "title": "Name"
            },
            "all": {
              "default": false,
              "description": "Show all images (default hides intermediate)",
              "title": "All",
              "type": "boolean"
            },
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListImagesFilters"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter images"
            }
          },
          "title": "ListImagesInput",
          "type": "object"
        }
      },
      {
        "name": "pull_image",
        "description": "Pull a Docker image",
        "inputSchema": {
          "properties": {
            "repository": {
              "description": "Image repository",
              "title": "Repository",
              "type": "string"
            },
            "tag": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "latest",
              "description": "Image tag",
              "title": "Tag"
            }
          },
          "required": [
            "repository"
          ],
          "title": "PullPushImageInput",
          "type": "object"
        }
      },
      {
        "name": "push_image",
        "description": "Push a Docker image",
        "inputSchema": {
          "properties": {
            "repository": {
              "description": "Image repository",
              "title": "Repository",
              "type": "string"
            },
            "tag": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "latest",
              "description": "Image tag",
              "title": "Tag"
            }
          },
          "required": [
            "repository"
          ],
          "title": "PullPushImageInput",
          "type": "object"
        }
      },
      {
        "name": "build_image",
        "description": "Build a Docker image from a Dockerfile",
        "inputSchema": {
          "properties": {
            "path": {
              "description": "Path to build context",
              "title": "Path",
              "type": "string"
            },
            "tag": {
              "description": "Image tag",
              "title": "Tag",
              "type": "string"
            },
            "dockerfile": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Path to Dockerfile",
              "title": "Dockerfile"
            }
          },
          "required": [
            "path",
            "tag"
          ],
          "title": "BuildImageInput",
          "type": "object"
        }
      },
      {
        "name": "remove_image",
        "description": "Remove a Docker image",
        "inputSchema": {
          "properties": {
            "image": {
              "description": "Image ID or name",
              "title": "Image",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the image",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "image"
          ],
          "title": "RemoveImageInput",
          "type": "object"
        }
      },
      {
        "name": "list_networks",
        "description": "List Docker networks",
        "inputSchema": {
          "$defs": {
            "ListNetworksFilter": {
              "properties": {
                "label": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Filter by label, either `key` or `key=value` format",
                  "title": "Label"
                }
              },
              "title": "ListNetworksFilter",
              "type": "object"
            }
          },
          "properties": {
            "filters": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ListNetworksFilter"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Filter networks"
            }
          },
          "title": "ListNetworksInput",
          "type": "object"
        }
      },
      {
        "name": "create_network",
        "description": "Create a Docker network",
        "inputSchema": {
          "properties": {
            "name": {
              "description": "Network name",
              "title": "Name",
              "type": "string"
            },
            "driver": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "bridge",
              "description": "Network driver",
              "title": "Driver"
            },
            "internal": {
              "default": false,
              "description": "Create an internal network",
              "title": "Internal",
              "type": "boolean"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Network labels",
              "title": "Labels"
            }
          },
          "required": [
            "name"
          ],
          "title": "CreateNetworkInput",
          "type": "object"
        }
      },
      {
        "name": "remove_network",
        "description": "Remove a Docker network",
        "inputSchema": {
          "properties": {
            "network_id": {
              "description": "Network ID or name",
              "title": "Network Id",
              "type": "string"
            }
          },
          "required": [
            "network_id"
          ],
          "title": "RemoveNetworkInput",
          "type": "object"
        }
      },
      {
        "name": "list_volumes",
        "description": "List Docker volumes",
        "inputSchema": {
          "properties": {},
          "title": "ListVolumesInput",
          "type": "object"
        }
      },
      {
        "name": "create_volume",
        "description": "Create a Docker volume",
        "inputSchema": {
          "properties": {
            "name": {
              "description": "Volume name",
              "title": "Name",
              "type": "string"
            },
            "driver": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "local",
              "description": "Volume driver",
              "title": "Driver"
            },
            "labels": {
              "anyOf": [
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Volume labels",
              "title": "Labels"
            }
          },
          "required": [
            "name"
          ],
          "title": "CreateVolumeInput",
          "type": "object"
        }
      },
      {
        "name": "remove_volume",
        "description": "Remove a Docker volume",
        "inputSchema": {
          "properties": {
            "volume_name": {
              "description": "Volume name",
              "title": "Volume Name",
              "type": "string"
            },
            "force": {
              "default": false,
              "description": "Force remove the volume",
              "title": "Force",
              "type": "boolean"
            }
          },
          "required": [
            "volume_name"
          ],
          "title": "RemoveVolumeInput",
          "type": "object"
        }
      }
    ]
  },
  "openrpc": {
    "name": "openrpc",
    "display_name": "OpenRPC",
    "description": "Interact with and discover JSON-RPC APIs via [OpenRPC](https://open-rpc.org/).",
    "repository": {
      "type": "git",
      "url": "https://github.com/shanejonas/openrpc-mpc-server"
    },
    "homepage": "https://github.com/shanejonas/openrpc-mpc-server",
    "author": {
      "name": "shanejonas"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "OpenRPC",
      "JSON-RPC"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "openrpc-mpc-server"
        ]
      }
    },
    "tools": [
      {
        "name": "rpc_call",
        "description": "Call any JSON-RPC method on a server with parameters. A user would prompt: Call method <method> on <server url> with params <params>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "server": {
              "type": "string",
              "description": "Server URL"
            },
            "method": {
              "type": "string",
              "description": "JSON-RPC method name to call"
            },
            "params": {
              "type": "string",
              "description": "Stringified Parameters to pass to the method"
            }
          },
          "required": [
            "server",
            "method"
          ]
        }
      },
      {
        "name": "rpc_discover",
        "description": "This uses JSON-RPC to call `rpc.discover` which is part of the OpenRPC Specification for discovery for JSON-RPC servers. A user would prompt: What JSON-RPC methods does this server have? <server url>",
        "inputSchema": {
          "type": "object",
          "properties": {
            "server": {
              "type": "string",
              "description": "Server URL"
            }
          },
          "required": [
            "server"
          ]
        }
      }
    ]
  },
  "xero-mcp-server": {
    "name": "xero-mcp-server",
    "display_name": "Xero",
    "description": "Enabling clients to interact with Xero system for streamlined accounting, invoicing, and business operations.",
    "repository": {
      "type": "git",
      "url": "https://github.com/john-zhang-dev/xero-mcp"
    },
    "license": "MIT",
    "examples": [
      {
        "title": "Visualize my financial position over the last month",
        "description": "",
        "prompt": "Visualize my financial position over the last month"
      },
      {
        "title": "Track my spendings over last week",
        "description": "",
        "prompt": "Track my spendings over last week"
      },
      {
        "title": "Add all transactions from the monthly statement into my revenue account (account code 201) as receive money",
        "description": "",
        "prompt": "Add all transactions from the monthly statement into my revenue account (account code 201) as receive money"
      }
    ],
    "author": {
      "name": "john-zhang-dev"
    },
    "homepage": "https://github.com/john-zhang-dev/xero-mcp",
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "xero-mcp@latest"
        ],
        "env": {
          "XERO_CLIENT_ID": "${XERO_CLIENT_ID}",
          "XERO_CLIENT_SECRET": "${XERO_CLIENT_SECRET}",
          "XERO_REDIRECT_URI": "${XERO_REDIRECT_URI}"
        }
      }
    },
    "arguments": {
      "XERO_CLIENT_ID": {
        "description": "The Client ID obtained from the Xero Developer center after creating an OAuth 2.0 app, required for authentication.",
        "required": true,
        "example": "YOUR_CLIENT_ID"
      },
      "XERO_CLIENT_SECRET": {
        "description": "The Client Secret generated in the Xero Developer center, necessary for authenticating requests.",
        "required": true,
        "example": "YOUR_CLIENT_SECRET"
      },
      "XERO_REDIRECT_URI": {
        "description": "The URI to redirect to after authentication, should typically match the redirect URI specified in the OAuth 2.0 app settings.",
        "required": false,
        "example": "http://localhost:5000/callback"
      }
    },
    "categories": [
      "Finance"
    ],
    "tools": [
      {
        "name": "authenticate",
        "description": "Authenticate with Xero using OAuth2",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_bank_transactions",
        "description": "Creates one or more spent or received money transaction. Only use this tool when user has directly and explicitly ask you to create transactions.",
        "inputSchema": {
          "type": "object",
          "description": "Transactions with an array of BankTransaction objects to create",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            },
            "Warnings": {
              "description": "Displays array of warning messages from the API",
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              }
            },
            "BankTransactions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/BankTransaction"
              }
            }
          },
          "example": "{ bankTransactions: [{ type: \"SPEND\", date: \"2023-01-01\", reference: \"INV-001\", subTotal: \"100\", total: \"115\", totalTax: \"15\", lineItems: [{ accountCode: \"401\", description: \"taxi fare\", lineAmount: \"115\" }], contact: { contactId: \"00000000-0000-0000-0000-000000000000\", name: \"John Doe\" }, \"bankAccount\": { \"accountID\": \"6f7594f2-f059-4d56-9e67-47ac9733bfe9\", \"Code\": \"088\", \"Name\": \"Business Wells Fargo\" } }]}"
        }
      },
      {
        "name": "create_contacts",
        "description": "Creates one or multiple contacts in a Xero organisation. Only use this tool when user has directly and explicitly ask you to create contact.",
        "inputSchema": {
          "type": "object",
          "description": "Contacts with an array of Contact objects to create",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            },
            "Warnings": {
              "description": "Displays array of warning messages from the API",
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              }
            },
            "Contacts": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Contact"
              }
            }
          },
          "example": "{ contacts: [{ name: \"John Doe\" }]}"
        }
      },
      {
        "name": "get_balance_sheet",
        "description": "Returns a balance sheet for the end of the month of the specified date. It also returns the value at the end of the same month for the previous year.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_accounts",
        "description": "Retrieves the full chart of accounts",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_bank_transactions",
        "description": "Retrieves any spent or received money transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter bank transactions. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_contacts",
        "description": "Retrieves all contacts in a Xero organisation",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_invoices",
        "description": "Retrieves sales invoices or purchase bills",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter invoices. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31), DueDate < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_journals",
        "description": "Retrieves journals",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_organisations",
        "description": "Retrieves Xero organisation details",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_payments",
        "description": "Retrieves payments for invoices and credit notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "description": "Filter payments. See example",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)"
            }
          }
        }
      },
      {
        "name": "list_quotes",
        "description": "Retrieves sales quotes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  "home-assistant": {
    "name": "home-assistant",
    "display_name": "Hass",
    "description": "Docker-ready MCP server for Home Assistant with entity management, domain summaries, automation support, and guided conversations. Includes pre-built container images for easy installation.",
    "repository": {
      "type": "git",
      "url": "https://github.com/voska/hass-mcp"
    },
    "homepage": "https://github.com/voska/hass-mcp",
    "author": {
      "name": "voska"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Home Assistant",
      "Claude",
      "LLM",
      "Automation"
    ],
    "installations": {
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "-i",
          "--rm",
          "-e",
          "HA_URL",
          "-e",
          "HA_TOKEN",
          "voska/hass-mcp"
        ],
        "env": {
          "HA_URL": "http://homeassistant.local:8123",
          "HA_TOKEN": "YOUR_LONG_LIVED_TOKEN"
        }
      }
    },
    "examples": [
      {
        "title": "Get Current State",
        "description": "Retrieve the current state of a specific device.",
        "prompt": "What's the current state of my living room lights?"
      },
      {
        "title": "Turn Off Lights",
        "description": "Command to turn off lights in a specific area.",
        "prompt": "Turn off all the lights in the kitchen"
      },
      {
        "title": "List Temperature Sensors",
        "description": "List all sensors related to temperature readings.",
        "prompt": "List all my sensors that contain temperature data"
      },
      {
        "title": "Climate Summary",
        "description": "Get a summary of climate-related entities.",
        "prompt": "Give me a summary of my climate entities"
      },
      {
        "title": "Create Automation",
        "description": "Create an automation based on a specific condition.",
        "prompt": "Create an automation that turns on the lights at sunset"
      },
      {
        "title": "Troubleshoot Automation",
        "description": "Help troubleshoot an automation issue.",
        "prompt": "Help me troubleshoot why my bedroom motion sensor automation isn't working"
      },
      {
        "title": "Search Entities",
        "description": "Search for specific entities related to a query.",
        "prompt": "Search for entities related to my living room"
      }
    ],
    "arguments": {
      "HA_URL": {
        "description": "The URL for the Home Assistant instance where the Hass-MCP server will connect to retrieve and manage entities.",
        "required": true,
        "example": "http://homeassistant.local:8123"
      },
      "HA_TOKEN": {
        "description": "The Long-Lived Access Token from Home Assistant, required for authentication to access the Home Assistant API.",
        "required": true,
        "example": "YOUR_LONG_LIVED_TOKEN"
      }
    },
    "tools": [
      {
        "name": "get_version",
        "description": "\nGet the Home Assistant version\n\nReturns:\n    A string with the Home Assistant version (e.g., \"2025.3.0\")\n",
        "inputSchema": {
          "properties": {},
          "title": "get_versionArguments",
          "type": "object"
        }
      },
      {
        "name": "get_entity",
        "description": "\nGet the state of a Home Assistant entity with optional field filtering\n\nArgs:\n    entity_id: The entity ID to get (e.g. 'light.living_room')\n    fields: Optional list of fields to include (e.g. ['state', 'attr.brightness'])\n    detailed: If True, returns all entity fields without filtering\n            \nExamples:\n    entity_id=\"light.living_room\" - basic state check\n    entity_id=\"light.living_room\", fields=[\"state\", \"attr.brightness\"] - specific fields\n    entity_id=\"light.living_room\", detailed=True - all details\n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            },
            "detailed": {
              "default": false,
              "title": "Detailed",
              "type": "boolean"
            }
          },
          "required": [
            "entity_id"
          ],
          "title": "get_entityArguments",
          "type": "object"
        }
      },
      {
        "name": "entity_action",
        "description": "\nPerform an action on a Home Assistant entity (on, off, toggle)\n\nArgs:\n    entity_id: The entity ID to control (e.g. 'light.living_room')\n    action: The action to perform ('on', 'off', 'toggle')\n    **params: Additional parameters for the service call\n\nReturns:\n    The response from Home Assistant\n\nExamples:\n    entity_id=\"light.living_room\", action=\"on\", brightness=255\n    entity_id=\"switch.garden_lights\", action=\"off\"\n    entity_id=\"climate.living_room\", action=\"on\", temperature=22.5\n\nDomain-Specific Parameters:\n    - Lights: brightness (0-255), color_temp, rgb_color, transition, effect\n    - Covers: position (0-100), tilt_position\n    - Climate: temperature, target_temp_high, target_temp_low, hvac_mode\n    - Media players: source, volume_level (0-1)\n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "action": {
              "title": "Action",
              "type": "string"
            },
            "params": {
              "title": "params",
              "type": "string"
            }
          },
          "required": [
            "entity_id",
            "action",
            "params"
          ],
          "title": "entity_actionArguments",
          "type": "object"
        }
      },
      {
        "name": "list_entities",
        "description": "\nGet a list of Home Assistant entities with optional filtering\n\nArgs:\n    domain: Optional domain to filter by (e.g., 'light', 'switch', 'sensor')\n    search_query: Optional search term to filter entities by name, id, or attributes\n                 (Note: Does not support wildcards. To get all entities, leave this empty)\n    limit: Maximum number of entities to return (default: 100)\n    fields: Optional list of specific fields to include in each entity\n    detailed: If True, returns all entity fields without filtering\n\nReturns:\n    A list of entity dictionaries with lean formatting by default\n\nExamples:\n    domain=\"light\" - get all lights\n    search_query=\"kitchen\", limit=20 - search entities\n    domain=\"sensor\", detailed=True - full sensor details\n\nBest Practices:\n    - Use lean format (default) for most operations\n    - Prefer domain filtering over no filtering\n    - For domain overviews, use domain_summary_tool instead of list_entities\n    - Only request detailed=True when necessary for full attribute inspection\n    - To get all entity types/domains, use list_entities without a domain filter, \n      then extract domains from entity_ids\n",
        "inputSchema": {
          "properties": {
            "domain": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Domain"
            },
            "search_query": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Search Query"
            },
            "limit": {
              "default": 100,
              "title": "Limit",
              "type": "integer"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Fields"
            },
            "detailed": {
              "default": false,
              "title": "Detailed",
              "type": "boolean"
            }
          },
          "title": "list_entitiesArguments",
          "type": "object"
        }
      },
      {
        "name": "search_entities_tool",
        "description": "\nSearch for entities matching a query string\n\nArgs:\n    query: The search query to match against entity IDs, names, and attributes.\n          (Note: Does not support wildcards. To get all entities, leave this blank or use list_entities tool)\n    limit: Maximum number of results to return (default: 20)\n\nReturns:\n    A dictionary containing search results and metadata:\n    - count: Total number of matching entities found\n    - results: List of matching entities with essential information\n    - domains: Map of domains with counts (e.g. {\"light\": 3, \"sensor\": 2})\n    \nExamples:\n    query=\"temperature\" - find temperature entities\n    query=\"living room\", limit=10 - find living room entities\n    query=\"\", limit=500 - list all entity types\n    \n",
        "inputSchema": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            },
            "limit": {
              "default": 20,
              "title": "Limit",
              "type": "integer"
            }
          },
          "required": [
            "query"
          ],
          "title": "search_entities_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "domain_summary_tool",
        "description": "\nGet a summary of entities in a specific domain\n\nArgs:\n    domain: The domain to summarize (e.g., 'light', 'switch', 'sensor')\n    example_limit: Maximum number of examples to include for each state\n\nReturns:\n    A dictionary containing:\n    - total_count: Number of entities in the domain\n    - state_distribution: Count of entities in each state\n    - examples: Sample entities for each state\n    - common_attributes: Most frequently occurring attributes\n    \nExamples:\n    domain=\"light\" - get light summary\n    domain=\"climate\", example_limit=5 - climate summary with more examples\nBest Practices:\n    - Use this before retrieving all entities in a domain to understand what's available    ",
        "inputSchema": {
          "properties": {
            "domain": {
              "title": "Domain",
              "type": "string"
            },
            "example_limit": {
              "default": 3,
              "title": "Example Limit",
              "type": "integer"
            }
          },
          "required": [
            "domain"
          ],
          "title": "domain_summary_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "system_overview",
        "description": "\nGet a comprehensive overview of the entire Home Assistant system\n\nReturns:\n    A dictionary containing:\n    - total_entities: Total count of all entities\n    - domains: Dictionary of domains with their entity counts and state distributions\n    - domain_samples: Representative sample entities for each domain (2-3 per domain)\n    - domain_attributes: Common attributes for each domain\n    - area_distribution: Entities grouped by area (if available)\n    \nExamples:\n    Returns domain counts, sample entities, and common attributes\nBest Practices:\n    - Use this as the first call when exploring an unfamiliar Home Assistant instance\n    - Perfect for building context about the structure of the smart home\n    - After getting an overview, use domain_summary_tool to dig deeper into specific domains\n",
        "inputSchema": {
          "properties": {},
          "title": "system_overviewArguments",
          "type": "object"
        }
      },
      {
        "name": "list_automations",
        "description": "\nGet a list of all automations from Home Assistant\n\nThis function retrieves all automations configured in Home Assistant,\nincluding their IDs, entity IDs, state, and display names.\n\nReturns:\n    A list of automation dictionaries, each containing id, entity_id, \n    state, and alias (friendly name) fields.\n    \nExamples:\n    Returns all automation objects with state and friendly names\n\n",
        "inputSchema": {
          "properties": {},
          "title": "list_automationsArguments",
          "type": "object"
        }
      },
      {
        "name": "restart_ha",
        "description": "\nRestart Home Assistant\n\n\u26a0\ufe0f WARNING: Temporarily disrupts all Home Assistant operations\n\nReturns:\n    Result of restart operation\n",
        "inputSchema": {
          "properties": {},
          "title": "restart_haArguments",
          "type": "object"
        }
      },
      {
        "name": "call_service_tool",
        "description": "\nCall any Home Assistant service (low-level API access)\n\nArgs:\n    domain: The domain of the service (e.g., 'light', 'switch', 'automation')\n    service: The service to call (e.g., 'turn_on', 'turn_off', 'toggle')\n    data: Optional data to pass to the service (e.g., {'entity_id': 'light.living_room'})\n\nReturns:\n    The response from Home Assistant (usually empty for successful calls)\n\nExamples:\n    domain='light', service='turn_on', data={'entity_id': 'light.x', 'brightness': 255}\n    domain='automation', service='reload'\n    domain='fan', service='set_percentage', data={'entity_id': 'fan.x', 'percentage': 50}\n\n",
        "inputSchema": {
          "properties": {
            "domain": {
              "title": "Domain",
              "type": "string"
            },
            "service": {
              "title": "Service",
              "type": "string"
            },
            "data": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Data"
            }
          },
          "required": [
            "domain",
            "service"
          ],
          "title": "call_service_toolArguments",
          "type": "object"
        }
      },
      {
        "name": "get_history",
        "description": "\nGet the history of an entity's state changes\n\nArgs:\n    entity_id: The entity ID to get history for\n    hours: Number of hours of history to retrieve (default: 24)\n\nReturns:\n    A dictionary containing:\n    - entity_id: The entity ID requested\n    - states: List of state objects with timestamps\n    - count: Number of state changes found\n    - first_changed: Timestamp of earliest state change\n    - last_changed: Timestamp of most recent state change\n    \nExamples:\n    entity_id=\"light.living_room\" - get 24h history\n    entity_id=\"sensor.temperature\", hours=168 - get 7 day history\nBest Practices:\n    - Keep hours reasonable (24-72) for token efficiency\n    - Use for entities with discrete state changes rather than continuously changing sensors\n    - Consider the state distribution rather than every individual state    \n",
        "inputSchema": {
          "properties": {
            "entity_id": {
              "title": "Entity Id",
              "type": "string"
            },
            "hours": {
              "default": 24,
              "title": "Hours",
              "type": "integer"
            }
          },
          "required": [
            "entity_id"
          ],
          "title": "get_historyArguments",
          "type": "object"
        }
      },
      {
        "name": "get_error_log",
        "description": "\nGet the Home Assistant error log for troubleshooting\n\nReturns:\n    A dictionary containing:\n    - log_text: The full error log text\n    - error_count: Number of ERROR entries found\n    - warning_count: Number of WARNING entries found\n    - integration_mentions: Map of integration names to mention counts\n    - error: Error message if retrieval failed\n    \nExamples:\n    Returns errors, warnings count and integration mentions\nBest Practices:\n    - Use this tool when troubleshooting specific Home Assistant errors\n    - Look for patterns in repeated errors\n    - Pay attention to timestamps to correlate errors with events\n    - Focus on integrations with many mentions in the log    \n",
        "inputSchema": {
          "properties": {},
          "title": "get_error_logArguments",
          "type": "object"
        }
      }
    ]
  },
  "ns-travel-information": {
    "name": "ns-travel-information",
    "display_name": "NS Travel Information",
    "description": "Access Dutch Railways (NS) real-time train travel information and disruptions through the official NS API.",
    "repository": {
      "type": "git",
      "url": "https://github.com/r-huijts/ns-mcp-server"
    },
    "homepage": "https://github.com/r-huijts/ns-mcp-server",
    "author": {
      "name": "r-huijts"
    },
    "license": "MIT",
    "categories": [
      "Professional Apps"
    ],
    "tags": [
      "NS",
      "Train",
      "Travel",
      "Information"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "ns-mcp-server"
        ],
        "env": {
          "NS_API_KEY": "${NS_API_KEY}"
        }
      }
    },
    "examples": [
      {
        "title": "Check train status",
        "description": "Ask if the 8:15 train from Almere to Amsterdam is running on time.",
        "prompt": "Is my usual 8:15 train from Almere to Amsterdam running on time?"
      },
      {
        "title": "Inquire about delays",
        "description": "Find out if there are any delays on a specific route.",
        "prompt": "Are there any delays on the Rotterdam-Den Haag route today?"
      },
      {
        "title": "Alternative routes",
        "description": "Seek alternative routes in case of maintenance on the direct line.",
        "prompt": "What's the best alternative route to Utrecht if there's maintenance on the direct line?"
      },
      {
        "title": "Get ticket price",
        "description": "Ask for ticket prices for travel between cities.",
        "prompt": "How much does a first-class ticket from Amsterdam to Rotterdam cost?"
      }
    ],
    "arguments": {
      "NS_API_KEY": {
        "description": "Your NS API key, required for authenticating API requests to access NS travel information.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "get_disruptions",
        "description": "Get comprehensive information about current and planned disruptions on the Dutch railway network. Returns details about maintenance work, unexpected disruptions, alternative transport options, impact on travel times, and relevant advice. Can filter for active disruptions and specific disruption types.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isActive": {
              "type": "boolean",
              "description": "Filter to only return active disruptions"
            },
            "type": {
              "type": "string",
              "description": "Type of disruptions to return (e.g., MAINTENANCE, DISRUPTION)",
              "enum": [
                "MAINTENANCE",
                "DISRUPTION"
              ]
            }
          }
        }
      },
      {
        "name": "get_travel_advice",
        "description": "Get detailed travel routes between two train stations, including transfers, real-time updates, platform information, and journey duration. Can plan trips for immediate departure or for a specific future time, with options to optimize for arrival time. Returns multiple route options with status and crowding information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromStation": {
              "type": "string",
              "description": "Name or code of departure station"
            },
            "toStation": {
              "type": "string",
              "description": "Name or code of destination station"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Datetime that the user want to depart from his origin or or arrive at his destination"
            },
            "searchForArrival": {
              "type": "boolean",
              "description": "If true, dateTime is treated as desired arrival time"
            }
          },
          "required": [
            "fromStation",
            "toStation"
          ]
        }
      },
      {
        "name": "get_departures",
        "description": "Get real-time departure information for trains from a specific station, including platform numbers, delays, route details, and any relevant travel notes. Returns a list of upcoming departures with timing, destination, and status information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "station": {
              "type": "string",
              "description": "NS Station code for the station (e.g., ASD for Amsterdam Centraal). Required if uicCode is not provided"
            },
            "uicCode": {
              "type": "string",
              "description": "UIC code for the station. Required if station code is not provided"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Only supported for departures at foreign stations. Defaults to server time (Europe/Amsterdam)"
            },
            "maxJourneys": {
              "type": "number",
              "description": "Number of departures to return",
              "minimum": 1,
              "maximum": 100,
              "default": 40
            },
            "lang": {
              "type": "string",
              "description": "Language for localizing the departures list. Only a small subset of text is translated, mainly notes. Defaults to Dutch",
              "enum": [
                "nl",
                "en"
              ],
              "default": "nl"
            }
          },
          "oneOf": [
            {
              "required": [
                "station"
              ]
            },
            {
              "required": [
                "uicCode"
              ]
            }
          ]
        }
      },
      {
        "name": "get_ovfiets",
        "description": "Get OV-fiets availability at a train station",
        "inputSchema": {
          "type": "object",
          "properties": {
            "stationCode": {
              "type": "string",
              "description": "Station code to check OV-fiets availability for (e.g., ASD for Amsterdam Centraal)"
            }
          },
          "required": [
            "stationCode"
          ]
        }
      },
      {
        "name": "get_station_info",
        "description": "Get detailed information about a train station",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Station name or code to search for"
            },
            "includeNonPlannableStations": {
              "type": "boolean",
              "description": "Include stations where trains do not stop regularly",
              "default": false
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return",
              "minimum": 1,
              "maximum": 50,
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_current_time_in_rfc3339",
        "description": "Get the current server time (Europe/Amsterdam timezone) in RFC3339 format. This can be used as input for other tools that require date-time parameters.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_arrivals",
        "description": "Get real-time arrival information for trains at a specific station, including platform numbers, delays, origin stations, and any relevant travel notes. Returns a list of upcoming arrivals with timing, origin, and status information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "station": {
              "type": "string",
              "description": "NS Station code for the station (e.g., ASD for Amsterdam Centraal). Required if uicCode is not provided"
            },
            "uicCode": {
              "type": "string",
              "description": "UIC code for the station. Required if station code is not provided"
            },
            "dateTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Only supported for arrivals at foreign stations. Defaults to server time (Europe/Amsterdam)"
            },
            "maxJourneys": {
              "type": "number",
              "description": "Number of arrivals to return",
              "minimum": 1,
              "maximum": 100,
              "default": 40
            },
            "lang": {
              "type": "string",
              "description": "Language for localizing the arrivals list. Only a small subset of text is translated, mainly notes. Defaults to Dutch",
              "enum": [
                "nl",
                "en"
              ],
              "default": "nl"
            }
          },
          "oneOf": [
            {
              "required": [
                "station"
              ]
            },
            {
              "required": [
                "uicCode"
              ]
            }
          ]
        }
      },
      {
        "name": "get_prices",
        "description": "Get price information for domestic train journeys, including different travel classes, ticket types, and discounts. Returns detailed pricing information with conditions and validity.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fromStation": {
              "type": "string",
              "description": "UicCode or station code of the origin station"
            },
            "toStation": {
              "type": "string",
              "description": "UicCode or station code of the destination station"
            },
            "travelClass": {
              "type": "string",
              "description": "Travel class to return the price for",
              "enum": [
                "FIRST_CLASS",
                "SECOND_CLASS"
              ]
            },
            "travelType": {
              "type": "string",
              "description": "Return the price for a single or return trip",
              "enum": [
                "single",
                "return"
              ],
              "default": "single"
            },
            "isJointJourney": {
              "type": "boolean",
              "description": "Set to true to return the price including joint journey discount",
              "default": false
            },
            "adults": {
              "type": "integer",
              "description": "Number of adults to return the price for",
              "minimum": 1,
              "default": 1
            },
            "children": {
              "type": "integer",
              "description": "Number of children to return the price for",
              "minimum": 0,
              "default": 0
            },
            "routeId": {
              "type": "string",
              "description": "Specific identifier for the route to take between the two stations. This routeId is returned in the /api/v3/trips call."
            },
            "plannedDepartureTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Used to find the correct route if multiple routes are possible."
            },
            "plannedArrivalTime": {
              "type": "string",
              "description": "Format - date-time (as date-time in RFC3339). Used to find the correct route if multiple routes are possible."
            }
          },
          "required": [
            "fromStation",
            "toStation"
          ]
        }
      }
    ]
  },
  "unity-catalog": {
    "name": "unity-catalog",
    "display_name": "Unity Catalog",
    "description": "An MCP server that enables LLMs to interact with Unity Catalog AI, supporting CRUD operations on Unity Catalog Functions and executing them as MCP tools.",
    "repository": {
      "type": "git",
      "url": "https://github.com/ognis1205/mcp-server-unitycatalog"
    },
    "homepage": "https://github.com/ognis1205/mcp-server-unitycatalog",
    "author": {
      "name": "ognis1205"
    },
    "license": "MIT",
    "categories": [
      "Dev Tools"
    ],
    "tags": [
      "Unity Catalog",
      "API",
      "Functions"
    ],
    "installations": {
      "uvx": {
        "type": "uvx",
        "command": "uvx",
        "args": [
          "--from",
          "git+https://github.com/ognis1205/mcp-server-unitycatalog",
          "mcp-server-unitycatalog",
          "--uc_server",
          "${UC_SERVER}",
          "--uc_catalog",
          "${UC_CATALOG}",
          "--uc_schema",
          "${UC_SCHEMA}"
        ]
      },
      "docker": {
        "type": "docker",
        "command": "docker",
        "args": [
          "run",
          "--rm",
          "-i",
          "mcp/unitycatalog",
          "--uc_server",
          "${UC_SERVER}",
          "--uc_catalog",
          "${UC_CATALOG}",
          "--uc_schema",
          "${UC_SCHEMA}"
        ]
      }
    },
    "arguments": {
      "UC_SERVER": {
        "description": "The base URL of the Unity Catalog server.",
        "required": true,
        "example": "https://my-unity-catalog.com"
      },
      "UC_CATALOG": {
        "description": "The name of the Unity Catalog catalog.",
        "required": true,
        "example": "my_catalog"
      },
      "UC_SCHEMA": {
        "description": "The name of the schema within a Unity Catalog catalog.",
        "required": true,
        "example": "my_schema"
      }
    }
  },
  "typesense": {
    "name": "typesense",
    "display_name": "Typesense",
    "description": "A Model Context Protocol (MCP) server implementation that provides AI models with access to Typesense search capabilities. This server enables LLMs to discover, search, and analyze data stored in Typesense collections.",
    "repository": {
      "type": "git",
      "url": "https://github.com/suhail-ak-s/mcp-typesense-server"
    },
    "homepage": "https://github.com/suhail-ak-s/mcp-typesense-server",
    "author": {
      "name": "suhail-ak-s"
    },
    "license": "MIT",
    "categories": [
      "Databases"
    ],
    "tags": [
      "Typesense",
      "Server",
      "Search"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "typesense-mcp-server",
          "--host",
          "${TYPESENSE_HOST}",
          "--port",
          "8108",
          "--protocol",
          "http",
          "--api-key",
          "${API_KEY}"
        ]
      }
    },
    "examples": [
      {
        "title": "Example Usage with Claude Desktop",
        "description": "Configuration for using Typesense MCP Server with Claude Desktop.",
        "prompt": "{\"mcpServers\": {\"typesense\": {\"command\": \"npx\",\"args\": [\"-y\",\"typesense-mcp-server\",\"--host\", \"your-typesense-host\",\"--port\", \"8108\",\"--protocol\", \"http\",\"--api-key\", \"your-api-key\"]}}}"
      }
    ],
    "arguments": {
      "TYPESENSE_HOST": {
        "description": "The host for the Typesense server. This is the address where your Typesense server is running.",
        "required": true,
        "example": "localhost"
      },
      "API_KEY": {
        "description": "The API key for accessing the Typesense server. This is needed for authentication when making requests to the server.",
        "required": true,
        "example": "your_api_key_here"
      }
    },
    "tools": [
      {
        "name": "typesense_query",
        "description": "Search for relevant documents in the TypeSense database based on the user's query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query entered by the user."
            },
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection to search within."
            },
            "query_by": {
              "type": "string",
              "description": "Comma-separated fields to search in the collection, e.g., 'title,content'."
            },
            "filter_by": {
              "type": "string",
              "description": "Optional filtering criteria, e.g., 'category:Chatbot'."
            },
            "sort_by": {
              "type": "string",
              "description": "Sorting criteria, e.g., 'created_at:desc'."
            },
            "limit": {
              "type": "integer",
              "description": "The maximum number of results to return.",
              "default": 10
            }
          },
          "required": [
            "query",
            "collection",
            "query_by"
          ]
        }
      },
      {
        "name": "typesense_get_document",
        "description": "Retrieve a specific document by ID from a Typesense collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection"
            },
            "document_id": {
              "type": "string",
              "description": "The ID of the document to retrieve"
            }
          },
          "required": [
            "collection",
            "document_id"
          ]
        }
      },
      {
        "name": "typesense_collection_stats",
        "description": "Get statistics about a Typesense collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "collection": {
              "type": "string",
              "description": "The name of the TypeSense collection"
            }
          },
          "required": [
            "collection"
          ]
        }
      }
    ]
  },
  "chatsum": {
    "name": "chatsum",
    "display_name": "Chat Summary",
    "description": "Query and Summarize chat messages with LLM. by [mcpso](https://mcp.so/)",
    "repository": {
      "type": "git",
      "url": "https://github.com/mcpso/mcp-server-chatsum"
    },
    "homepage": "https://github.com/mcpso/mcp-server-chatsum",
    "author": {
      "name": "idoubi",
      "url": "https://bento.me/idoubi"
    },
    "license": "MIT",
    "categories": [
      "Messaging"
    ],
    "tags": [
      "chat",
      "summary"
    ],
    "examples": [
      {
        "title": "Summarize Chat Messages",
        "description": "Use this prompt to summarize chat messages based on given parameters.",
        "prompt": "Summarize these messages: [...]"
      }
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/mcpso/mcp-server-chatsum"
        ],
        "env": {
          "CHAT_DB_PATH": "path-to/mcp-server-chatsum/chatbot/data/chat.db"
        }
      }
    },
    "arguments": {
      "CHAT_DB_PATH": {
        "description": "Path to your chat database file that the server will use to store and retrieve chat messages.",
        "required": true,
        "example": "path-to/mcp-server-chatsum/chatbot/data/chat.db"
      }
    },
    "tools": [
      {
        "name": "query_chat_messages",
        "description": "query chat messages with given parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "room_names": {
              "type": "array",
              "description": "chat room names",
              "items": {
                "type": "string",
                "description": "chat room name"
              }
            },
            "talker_names": {
              "type": "array",
              "description": "talker names",
              "items": {
                "type": "string",
                "description": "talker name"
              }
            },
            "limit": {
              "type": "number",
              "description": "chat messages limit",
              "default": 100
            }
          },
          "required": []
        }
      }
    ]
  },
  "descope": {
    "name": "descope",
    "display_name": "Descope",
    "description": "An MCP server to integrate with [Descope](https://descope.com/) to search audit logs, manage users, and more.",
    "repository": {
      "type": "git",
      "url": "https://github.com/descope-sample-apps/descope-mcp-server"
    },
    "homepage": "https://github.com/descope-sample-apps/descope-mcp-server",
    "author": {
      "name": "Descope",
      "url": "https://descope.com"
    },
    "license": "MIT",
    "categories": [
      "System Tools"
    ],
    "tags": [
      "Descope",
      "API",
      "Server"
    ],
    "installations": {
      "npm": {
        "type": "npm",
        "command": "npx",
        "args": [
          "-y",
          "https://github.com/descope-sample-apps/descope-mcp-server"
        ],
        "env": {
          "DESCOPE_PROJECT_ID": "${DESCOPE_PROJECT_ID}",
          "DESCOPE_MANAGEMENT_KEY": "${DESCOPE_MANAGEMENT_KEY}"
        }
      }
    },
    "arguments": {
      "DESCOPE_PROJECT_ID": {
        "description": "Your Descope Project ID",
        "required": true,
        "example": "12345-abcde-67890-fghij"
      },
      "DESCOPE_MANAGEMENT_KEY": {
        "description": "Your Descope Management Key",
        "required": true,
        "example": "sk_test_4eC39HqLyjEDERyCzKZQz9fgo"
      }
    }
  }
}